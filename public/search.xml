<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue2中的$listeners和v-module</title>
    <url>/135xyq.github.io/2022/01/01/$listeners&amp;v-module/</url>
    <content><![CDATA[<h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><p><strong>针对<code>dom</code>节点的原生事件</strong>，<code>vue</code>支持多种修饰符以简化代码</p>
<p>详见：<a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">事件修饰符、按键修饰符、系统修饰符</a></p>
<h1 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h1><p><code>$listeners</code>是<code>vue</code>的一个实例属性，它用于获取父组件传过来的所有事件函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">event1</span>=<span class="string">&quot;handleEvent1&quot;</span> @<span class="attr">event2</span>=<span class="string">&quot;handleEvent2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="built_in">this</span>.$listeners <span class="comment">// &#123; event1: handleEvent1, event2: handleEvent2 &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>$emit</code>和<code>$listeners</code>通信的异同</p>
<p>相同点：均可实现子组件向父组件传递消息</p>
<p>差异点：</p>
<ul>
<li><code>$emit</code>更加符合单向数据流，子组件仅发出通知，由父组件监听做出改变；而<code>$listeners</code>则是在子组件中直接使用了父组件的方法。</li>
<li>调试工具可以监听到子组件<code>$emit</code>的事件，但无法监听到<code>$listeners</code>中的方法调用。（想想为什么）</li>
<li>由于<code>$listeners</code>中可以获得传递过来的方法，因此调用方法可以得到其返回值。但<code>$emit</code>仅仅是向父组件发出通知，无法知晓父组件处理的结果</li>
</ul>
</blockquote>
<blockquote>
<p>对于上述中的第三点，可以在<code>$emit</code>中传递回调函数来解决</p>
<p>父组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Child @click=&quot;handleClick&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &quot;./Child&quot;</span><br><span class="line">	export default &#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">      Child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      handleClick(data, callback)&#123;</span><br><span class="line">        console.log(data); // 得到子组件事件中的数据</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">          callback(1); // 一段时间后，调用子组件传递的回调函数</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;button @click=&quot;handleClick&quot;&gt;</span><br><span class="line">    click</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">      handleClick()&#123;</span><br><span class="line">        this.$emit(&quot;click&quot;, 123, (data)=&gt;&#123;</span><br><span class="line">          console.log(data); // data为父组件处理完成后得到的数据</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><p><code>v-model</code>指令实质是一个语法糖，它是<code>value</code>属性和<code>input</code>事件的<em>结合体</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;data&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;data=$event.target.value&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>详见：<a href="https://cn.vuejs.org/v2/guide/forms.html">表单输入绑定</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1005 K 次取反后最大化的数组和 找到负数个数，条件判断</title>
    <url>/135xyq.github.io/2021/12/30/1005.%20K%20%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="1005-K-次取反后最大化的数组和-找到负数个数，条件判断"><a href="#1005-K-次取反后最大化的数组和-找到负数个数，条件判断" class="headerlink" title="1005 K 次取反后最大化的数组和 找到负数个数，条件判断"></a>1005 K 次取反后最大化的数组和 找到负数个数，条件判断</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>主要思想就是尽量多的把负数变为正数，负数不够变化时，变化最小的正数。</p>
<ol>
<li>先将数组排序，便于后续操作数组中的数据</li>
<li>找出数组中负数的个数，记录到count中，并且计算原来数组的和记录到sum中</li>
<li>开始判断变化的次数和负数个数的关系<ul>
<li>如果变化的次数小于等于负数的个数，k&lt;=count，则直接找出最小的k个负数，最大和为sum + k个负数绝对值的二倍</li>
<li>如果变化的次数大于负数的个数，继续判断负数的个数是否为0<ol>
<li>为0，则判断k是否为偶数，如果为偶数则直接返回sum,如果为奇数，则直接返回sum - 二倍的nums[0]</li>
<li>不为0，先求出将负数全变为正数的最大值，然后求出变化次数和负数个数的差值temp，继续判断temp是奇数还是偶数<ul>
<li>temp为偶数，直接返回最大值</li>
<li>temp为奇数，继续判断数组是否为全负数，如果是全负数 return maxSum + 2*(nums[nums.length-1])，如果不是则         return maxSum - 2*Math.min(Math.abs(nums[count-1]),Math.abs(nums[count]))。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 统计负数的个数</span></span><br><span class="line"><span class="keyword">var</span> largestSumAfterKNegations = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> count = <span class="number">0</span>;<span class="comment">//负数的个数</span></span><br><span class="line">	<span class="keyword">let</span> maxSum = <span class="number">0</span>;<span class="comment">//可能的最大和</span></span><br><span class="line">	<span class="keyword">let</span> sum = <span class="number">0</span>;<span class="comment">//原来的</span></span><br><span class="line">	nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">	nums.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(item &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			count ++;</span><br><span class="line">		&#125;</span><br><span class="line">		sum += item;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=count)&#123;</span><br><span class="line">		maxSum = sum;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">			maxSum+=(-nums[i]*<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxSum;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;count)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!count)&#123;</span><br><span class="line">			<span class="keyword">if</span>(k%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> sum-<span class="number">2</span>*nums[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">let</span> temp  = k-count;</span><br><span class="line">			maxSum = sum;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">				maxSum+=(-nums[i]*<span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> maxSum;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(count === nums.length)&#123;</span><br><span class="line">					<span class="keyword">return</span> maxSum + <span class="number">2</span>*(nums[nums.length-<span class="number">1</span>])</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> maxSum - <span class="number">2</span>*<span class="built_in">Math</span>.min(<span class="built_in">Math</span>.abs(nums[count-<span class="number">1</span>]),<span class="built_in">Math</span>.abs(nums[count]))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1078. Bigram 分词</title>
    <url>/135xyq.github.io/2021/12/30/1078.%20Bigram%20%E5%88%86%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="1078-Bigram-分词"><a href="#1078-Bigram-分词" class="headerlink" title="1078. Bigram 分词"></a>1078. Bigram 分词</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/occurrences-after-bigram/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将句子按空格分隔开</li>
<li>遍历寻找符合条件的就行</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">text</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">first</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">second</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findOcurrences = <span class="function"><span class="keyword">function</span>(<span class="params">text, first, second</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> thirdWord = [];<span class="comment">//结果</span></span><br><span class="line">	<span class="comment">// 将字符串转为数组</span></span><br><span class="line">	<span class="keyword">const</span> textArr = text.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt;textArr.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(textArr[i]===first &amp;&amp;textArr[i+<span class="number">1</span>] === second)&#123;</span><br><span class="line">			thirdWord.push(textArr[i+<span class="number">2</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> thirdWord;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1122. 数组的相对排序 利用Map集合和数组排序</title>
    <url>/135xyq.github.io/2021/12/30/1122.%20%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="1122-数组的相对排序-利用Map集合和数组排序"><a href="#1122-数组的相对排序-利用Map集合和数组排序" class="headerlink" title="1122. 数组的相对排序 利用Map集合和数组排序"></a>1122. 数组的相对排序 利用Map集合和数组排序</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>先将数组arr1映射到map对象中，用数组的值为键，数组每个值得个数为值</li>
<li>遍历arr2将map中的元素全部取出，顺序排列，注意要<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;map.get(item);i++)&#123;</span><br><span class="line">		result.push(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将每一项都取出，防止遗漏重复项，取出一项后记得删除</li>
<li>再次遍历map取出arr1特有的元素，进行排序再push到大数组中返回</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">arr1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">arr2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> relativeSortArray = <span class="function"><span class="keyword">function</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将arr1映射到Map集合中值为元素的个数</span></span><br><span class="line">	<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">	arr1.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.has(item))&#123;</span><br><span class="line">			map.set(item,map.get(item)+<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			map.set(item,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">let</span> result  =[];</span><br><span class="line">	<span class="comment">//遍历数组arr2按顺序将map中的值push到result中</span></span><br><span class="line">	arr2.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;map.get(item);i++)&#123;</span><br><span class="line">			result.push(item);</span><br><span class="line">		&#125;</span><br><span class="line">		map.delete(item);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">let</span> other = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">			other.push(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result.push(...other.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)) ;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1154. 一年中的第几天 打表求解</title>
    <url>/135xyq.github.io/2021/12/30/1154.%20%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="1154-一年中的第几天-打表求解"><a href="#1154-一年中的第几天-打表求解" class="headerlink" title="1154. 一年中的第几天 打表求解"></a>1154. 一年中的第几天 打表求解</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/day-of-the-year/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先将每个月份的天数存到数组中，再判断该年是不是闰年，闰年的2月份是29天。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">date</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dayOfYear = <span class="function"><span class="keyword">function</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">let</span> months = [<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>];</span><br><span class="line">	<span class="comment">// 年月日拆开</span></span><br><span class="line">	<span class="keyword">const</span> nums = date.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> year = <span class="built_in">parseInt</span>(nums[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">const</span> month = <span class="built_in">parseInt</span>(nums[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">const</span> day = <span class="built_in">parseInt</span>(nums[<span class="number">2</span>])</span><br><span class="line">	<span class="comment">// 判断是不是闰年</span></span><br><span class="line">	<span class="keyword">if</span>((year % <span class="number">4</span> === <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !== <span class="number">0</span>)||year % <span class="number">400</span> === <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(month &gt; <span class="number">2</span>)&#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;month;i++)&#123;</span><br><span class="line">		count += months[i-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	count += day;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>118. 杨辉三角 循环遍历，一层一层计算</title>
    <url>/135xyq.github.io/2021/12/30/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1 id="118-杨辉三角-循环遍历，一层一层计算"><a href="#118-杨辉三角-循环遍历，一层一层计算" class="headerlink" title="118. 杨辉三角 循环遍历，一层一层计算"></a>118. 杨辉三角 循环遍历，一层一层计算</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>定义一个空数组result存放返回值</li>
<li>循环，定义一个新数组temp ，先将数组第一项赋值为1，在循环计算，再判断参数<ul>
<li>参数为1则不在temp最后一项push（1）</li>
<li>不为1则push（1）</li>
</ul>
</li>
<li>将temp添加都result中</li>
</ol>
<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/">原题</a></h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = [<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            temp.push(result[i - <span class="number">2</span>][j - <span class="number">1</span>] + result[i - <span class="number">2</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i !== <span class="number">1</span>) &#123;</span><br><span class="line">            temp.push(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1185. 一周中的第几天</title>
    <url>/135xyq.github.io/2022/01/03/1185.%20%E4%B8%80%E5%91%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="1185-一周中的第几天-Date函数和模拟天数求解"><a href="#1185-一周中的第几天-Date函数和模拟天数求解" class="headerlink" title="1185. 一周中的第几天 Date函数和模拟天数求解"></a>1185. 一周中的第几天 Date函数和模拟天数求解</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/day-of-the-week/">查看原题</a></h2><h2 id="解题思路-使用js日期函数Date"><a href="#解题思路-使用js日期函数Date" class="headerlink" title="解题思路(使用js日期函数Date)"></a>解题思路(使用js日期函数Date)</h2><ol>
<li>通过传入的年月日来创建一个日期对象，注意：month要减一</li>
<li>再用getDay()方法获取一个星期的第几天（0-6）</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">day</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">month</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">year</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dayOfTheWeek = <span class="function"><span class="keyword">function</span>(<span class="params">day, month, year</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> week = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>]</span><br><span class="line">	<span class="keyword">return</span> week[<span class="keyword">new</span> <span class="built_in">Date</span>(year,month-<span class="number">1</span>,day).getDay()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="解题思路（模拟天数求解）"><a href="#解题思路（模拟天数求解）" class="headerlink" title="解题思路（模拟天数求解）"></a>解题思路（模拟天数求解）</h2><ol>
<li>找出第一天的星期数，即1971.01.01是星期五，这是最重要的</li>
<li>找出当前的日期距离1971.01.01的天数<ul>
<li>整年的天数 (year - 1971)* 365 注意加上其中闰年的个数（闰年366天）</li>
<li>整月的天数 (month  - 1) * 每个月的天数</li>
<li>剩下的天数 day</li>
</ul>
</li>
<li>求出总天数加上3再模上7得出星期的下标，加4是因为第一天在星期数组的下标为3</li>
<li>星期数组为：[ “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”,”Sunday”];</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">day</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">month</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">year</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dayOfTheWeek = <span class="function"><span class="keyword">function</span>(<span class="params">day, month, year</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1970 年 12 月 31 日是星期四，</span></span><br><span class="line">	<span class="keyword">const</span> monthDays = [<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>];</span><br><span class="line">	<span class="keyword">const</span> week = [ <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>];</span><br><span class="line">	<span class="keyword">const</span> yearNum = year - <span class="number">1971</span>;</span><br><span class="line">	<span class="keyword">const</span> monthNum = month  - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> dayNum = day;</span><br><span class="line">	<span class="keyword">let</span> daySum = yearNum * <span class="number">365</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1971</span>;i&lt;=year;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((i % <span class="number">4</span> === <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> !== <span class="number">0</span>)||(i % <span class="number">400</span> ===<span class="number">0</span>) )&#123;</span><br><span class="line">			<span class="keyword">if</span>(i === year &amp;&amp; month &lt; <span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				daySum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt;monthNum;i++)&#123;</span><br><span class="line">		daySum+= monthDays[i]</span><br><span class="line">	&#125;</span><br><span class="line">	daySum += dayNum;</span><br><span class="line">	<span class="built_in">console</span>.log((daySum+<span class="number">3</span>)%<span class="number">7</span>)</span><br><span class="line">	<span class="keyword">return</span> week[(daySum+<span class="number">3</span>)%<span class="number">7</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1332. 删除回文子序列</title>
    <url>/135xyq.github.io/2022/01/22/1332.%20%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="1332-删除回文子序列-判断原字符串是否是回文串"><a href="#1332-删除回文子序列-判断原字符串是否是回文串" class="headerlink" title="1332. 删除回文子序列 判断原字符串是否是回文串"></a>1332. 删除回文子序列 判断原字符串是否是回文串</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">查看原题</a></h2><p><img src="https://img-blog.csdnimg.cn/49440f208fed485b9de97693f95364f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为删除的是子回文串，所以最大删除次数为2。当字符串本身是一个回文串，则删除一次就行，如果不是则需要删除2次。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removePalindromeSub = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> length = s.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt;<span class="built_in">Math</span>.floor(length /<span class="number">2</span>);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] !== s[length - i -<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/5236c8516ccd43d6999be986e952a7d1.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>119. 杨辉三角 II 排列组合</title>
    <url>/135xyq.github.io/2021/12/30/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1 id="119-杨辉三角-II-排列组合"><a href="#119-杨辉三角-II-排列组合" class="headerlink" title="119. 杨辉三角 II 排列组合"></a>119. 杨辉三角 II 排列组合</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找出排列组合关系题就写出来了</p>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">原题</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">rowIndex</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getRow = <span class="function"><span class="keyword">function</span>(<span class="params">rowIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []; <span class="comment">//存放结果</span></span><br><span class="line"></span><br><span class="line">    result.push(<span class="number">1</span>); <span class="comment">//第一个特殊处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> t = <span class="number">1</span>; <span class="comment">//分子</span></span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">1</span>; <span class="comment">//分母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            t *= (rowIndex - j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            b *= j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        result.push(t / b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字 循环利用indexOf求解</title>
    <url>/135xyq.github.io/2021/12/30/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="136-只出现一次的数字-循环利用indexOf求解"><a href="#136-只出现一次的数字-循环利用indexOf求解" class="headerlink" title="136. 只出现一次的数字 循环利用indexOf求解"></a>136. 只出现一次的数字 循环利用indexOf求解</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/single-number/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种方法时间复杂度较高<br>利用indexOf方法判断数组当前项在前后是否还能找到与他一样的数，如果不能找到，这个数即为所求。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.indexOf(nums[i], i + <span class="number">1</span>) === -<span class="number">1</span> &amp;&amp; nums.indexOf(nums[i]) === i) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将数组转为set集合，set集合没有重复项</li>
<li>对set集合每一项求和 sum1</li>
<li>对数组求和 sum2</li>
<li>set集合的和sum1表示数组不重复项的和，乘以2再减去sum2即为那个只出现一次的数</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(nums); <span class="comment">//将nums转为集合</span></span><br><span class="line">    <span class="keyword">let</span> sum1 = <span class="number">0</span>; <span class="comment">//求set集合各项的和</span></span><br><span class="line">    <span class="keyword">let</span> sum2 = <span class="number">0</span>; <span class="comment">//求数组的各项和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">        sum1 += item;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">vaule</span> =&gt;</span> &#123;</span><br><span class="line">        sum2 += vaule;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * sum1) - sum2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1446. 连续字符</title>
    <url>/135xyq.github.io/2021/12/30/1446.%20%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="1446-连续字符-滑动窗口"><a href="#1446-连续字符-滑动窗口" class="headerlink" title="1446. 连续字符 滑动窗口"></a>1446. 连续字符 滑动窗口</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/consecutive-characters/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>定义一个总的最大值max = 1，一个局部最大值temp = 1；</li>
<li>循环字符串的每一项，判断当前项与前一项是否相等<ul>
<li>相等，则局部最大值temp++</li>
<li>不相等，则说明要重新开始寻找相同的字符串了，将temp=1;</li>
</ul>
</li>
<li>注意循环要从 1 开始</li>
<li>要不断判断temp 与max的大小，更新max</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxPower = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> max = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> temp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> i ;</span><br><span class="line">	<span class="comment">// 遍历字符串，遇到不是一样的字符据重新计算</span></span><br><span class="line">	<span class="keyword">for</span>(i= <span class="number">1</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i)===s.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">			temp++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			temp = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(temp &gt; max)&#123;</span><br><span class="line">			max =  temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1518. 换酒问题</title>
    <url>/135xyq.github.io/2021/12/30/1518.%20%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1518-换酒问题-不断更新当前瓶子的个数"><a href="#1518-换酒问题-不断更新当前瓶子的个数" class="headerlink" title="1518. 换酒问题 不断更新当前瓶子的个数"></a>1518. 换酒问题 不断更新当前瓶子的个数</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/water-bottles/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>定义变量count表示可以喝的总瓶数，bottles表示当前有多少空瓶子</li>
<li>循环，不断将瓶子换酒在换酒，结束条件为当前的瓶子数小于能兑换一瓶酒的最小瓶子数</li>
<li>更新当前的瓶子数为换到的酒的数量加上不够一瓶酒的瓶子数</li>
<li>更新count的值</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numBottles</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numExchange</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numWaterBottles = <span class="function"><span class="keyword">function</span>(<span class="params">numBottles, numExchange</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> count = numBottles;<span class="comment">//可以喝多少瓶酒</span></span><br><span class="line">	<span class="keyword">let</span> bottles = numBottles;<span class="comment">//有多少瓶子</span></span><br><span class="line">	<span class="keyword">while</span> (bottles &gt;= numExchange)&#123;</span><br><span class="line">		<span class="keyword">let</span> temp = <span class="built_in">Math</span>.floor(bottles / numExchange);<span class="comment">//当前的瓶子可以换多少瓶酒</span></span><br><span class="line">		bottles = temp + (bottles - temp * numExchange);</span><br><span class="line">		count += temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1576. 替换所有的问号</title>
    <url>/135xyq.github.io/2022/01/05/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="1576-替换所有的问号-遍历扫描-多重条件判断-amp-三种符号替换"><a href="#1576-替换所有的问号-遍历扫描-多重条件判断-amp-三种符号替换" class="headerlink" title="1576. 替换所有的问号 遍历扫描 多重条件判断 &amp; 三种符号替换"></a>1576. 替换所有的问号 遍历扫描 多重条件判断 &amp; 三种符号替换</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">查看原题</a></h2><h2 id="解题思路（多重条件判断）"><a href="#解题思路（多重条件判断）" class="headerlink" title="解题思路（多重条件判断）"></a>解题思路（多重条件判断）</h2><p>我的变换格式是：<code>String.fromCharCode((arr[i-1].charCodeAt() - 97 + 23) % 26 + 97</code>来保证前后不重复</p>
<ol>
<li>将字符串转为数组，因为js中字符串无法更改单独一项的值</li>
<li>遍历数组，判断是否是’?’，如果是则分为三种情况<ol>
<li>在开头：判断数组的长度是否为1 ，若为1，则直接返回’a’,若不是则变换后面一个字符，填充到当前位置。</li>
<li>在结尾：变换前一个元素，填充到当前位置。</li>
<li>在中间：判断在前一个元素变换后是否和后一个元素相同，若相同，则使用后一个字符的变换，不相同直接使用。</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> modifyString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arr = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] === <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i === <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr.length === <span class="number">1</span>)&#123;</span><br><span class="line">					arr[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(arr[i+<span class="number">1</span>] === <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">						arr[i] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						arr[i] = <span class="built_in">String</span>.fromCharCode((arr[i+<span class="number">1</span>].charCodeAt() - <span class="number">97</span> + <span class="number">23</span>) % <span class="number">26</span> + <span class="number">97</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i === arr.length -<span class="number">1</span>)&#123;</span><br><span class="line">				arr[i] = <span class="built_in">String</span>.fromCharCode((arr[i-<span class="number">1</span>].charCodeAt() - <span class="number">97</span> + <span class="number">23</span>) % <span class="number">26</span> + <span class="number">97</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">String</span>.fromCharCode((arr[i-<span class="number">1</span>].charCodeAt() - <span class="number">97</span> + <span class="number">23</span>) % <span class="number">26</span> + <span class="number">97</span>) === arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">					arr[i] = <span class="built_in">String</span>.fromCharCode((arr[i+<span class="number">1</span>].charCodeAt() - <span class="number">97</span> + <span class="number">23</span>) % <span class="number">26</span> + <span class="number">97</span>)</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					arr[i] = <span class="built_in">String</span>.fromCharCode((arr[i-<span class="number">1</span>].charCodeAt() - <span class="number">97</span> + <span class="number">23</span>) % <span class="number">26</span> + <span class="number">97</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在替换时，实际不需要遍历所有的小写字母，只需要遍历三个互不相同的字母，就能保证一定找到一个与前后字符均不相同的字母，在此我们可以限定三个不同的字母为 (‘a’,’b’,’c’)</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> modifyString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> arr = [...s];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] === <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; arr[i - <span class="number">1</span>] === <span class="built_in">String</span>.fromCharCode(<span class="string">&#x27;a&#x27;</span>.charCodeAt() + j)) || (i &lt; arr.length - <span class="number">1</span> &amp;&amp; arr[i + <span class="number">1</span>] === <span class="built_in">String</span>.fromCharCode(<span class="string">&#x27;a&#x27;</span>.charCodeAt() + j))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i] = <span class="built_in">String</span>.fromCharCode(<span class="string">&#x27;a&#x27;</span>.charCodeAt() + j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1614. 括号的最大嵌套深度</title>
    <url>/135xyq.github.io/2022/01/07/1614.%20%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="1614-括号的最大嵌套深度-栈的应用"><a href="#1614-括号的最大嵌套深度-栈的应用" class="headerlink" title="1614. 括号的最大嵌套深度 栈的应用"></a>1614. 括号的最大嵌套深度 栈的应用</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>寻找括号的最大嵌套深度，左括号和右括号构成一对，正好符号栈的特点（先进后出），可以构成一对。</p>
<ol>
<li>遍历字符串遇到 ‘)’将其push到栈中</li>
<li>遇到’(‘比较当前栈中元素个数和最大值比较，不断更新最大值，并pop出一个元素</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> stack = [];</span><br><span class="line">	<span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) === <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">			stack.push(s.charAt(i))</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) === <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			max = stack.length &gt; max ? stack.length : max;</span><br><span class="line">			stack.pop()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>167. 两数之和 II - 输入有序数组</title>
    <url>/135xyq.github.io/2021/12/30/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="167-两数之和-II-输入有序数组-双重循环暴力求解-amp-二分求解"><a href="#167-两数之和-II-输入有序数组-双重循环暴力求解-amp-二分求解" class="headerlink" title="167. 两数之和 II - 输入有序数组  双重循环暴力求解&amp;二分求解"></a>167. 两数之和 II - 输入有序数组  双重循环暴力求解&amp;二分求解</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两层循环暴力求解</p>
<p>##<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">原题</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = numbers.length;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[j] + numbers[i] === target) &#123;</span><br><span class="line">                result.push(i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分法求解</p>
<ol>
<li>循环数组假设当前下标 i 为其中一个正确的值计算出另一个值，</li>
<li>在 i+1 到 数组长度length-1 的这段距离中二分查找，找到符合条件的直接返回</li>
<li>这种方法比直接双重暴力循环时间复杂度降低，从(N^2)  降为（NlogN）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = numbers.length;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = <span class="number">0</span>; <span class="comment">//左右边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> target1 = target - numbers[i]; <span class="comment">//另个数的大小</span></span><br><span class="line">        right = length - <span class="number">1</span>;</span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target1 &lt; numbers[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target1 &gt; numbers[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> [i + <span class="number">1</span>, mid + <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1629. 按键持续时间最长的键</title>
    <url>/135xyq.github.io/2022/01/10/1629.%20%E6%8C%89%E9%94%AE%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E6%9C%80%E9%95%BF%E7%9A%84%E9%94%AE/</url>
    <content><![CDATA[<h1 id="1629-按键持续时间最长的键-遍历两个数组"><a href="#1629-按键持续时间最长的键-遍历两个数组" class="headerlink" title="1629. 按键持续时间最长的键  遍历两个数组"></a>1629. 按键持续时间最长的键  遍历两个数组</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/slowest-key/">查看原题</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol>
<li>在数组的最前面加上一个0，为了更好求出每个按键的时间<code>releaseTimes[i+1] - releaseTimes[i]</code></li>
<li>用一个变量记录当前的最大持续时间，一个变量记录对应的按键</li>
<li>循环不断判断是否有比当前持续时间长的按键，如果有，则更新最长持续时间和对应的按键</li>
<li>如果和最大持续时间相等，则继续比较按键的大小，如果最新的较大，则更新为对应的按键</li>
<li>循环结束返回存储的按键</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">releaseTimes</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">keysPressed</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;character&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> slowestKey = <span class="function"><span class="keyword">function</span>(<span class="params">releaseTimes, keysPressed</span>) </span>&#123;</span><br><span class="line">	releaseTimes.unshift(<span class="number">0</span>)</span><br><span class="line">	maxNum = <span class="number">0</span>;</span><br><span class="line">	maxKey = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;keysPressed.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(releaseTimes[i+<span class="number">1</span>] - releaseTimes[i] &gt; maxNum)&#123;</span><br><span class="line">			maxNum = releaseTimes[i+<span class="number">1</span>] - releaseTimes[i];</span><br><span class="line">			maxKey = keysPressed.charAt(i);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(releaseTimes[i+<span class="number">1</span>] - releaseTimes[i] === maxNum)&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxKey.charCodeAt() &lt; keysPressed.charCodeAt(i))&#123;</span><br><span class="line">				maxKey = keysPressed.charAt(i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxKey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1716. 计算力扣银行的钱</title>
    <url>/135xyq.github.io/2022/01/16/1716.%20%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/</url>
    <content><![CDATA[<h1 id="1716-计算力扣银行的钱-分别求出整星期个不足星期的钱"><a href="#1716-计算力扣银行的钱-分别求出整星期个不足星期的钱" class="headerlink" title="1716. 计算力扣银行的钱 分别求出整星期个不足星期的钱"></a>1716. 计算力扣银行的钱 分别求出整星期个不足星期的钱</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">查看原题</a></h2><p><img src="https://img-blog.csdnimg.cn/b07b9b31ab154b5b875684bd7e6e46bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先求出有多少个完整的星期和剩下的天数，分别求解。<br>每个星期不加钱的情况下存钱为28元，每个星期比上个星期多7元。</p>
<ol>
<li>求出星期数weeks和剩余天数days</li>
<li>求出整的星期数包含的钱（基本的加上多存的）</li>
<li>求出剩余天数存的钱(星期一的钱数为weeks)</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> totalMoney = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> weeks = <span class="built_in">Math</span>.floor(n / <span class="number">7</span>);</span><br><span class="line">	<span class="keyword">const</span> days = n % <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 整数个星期的钱</span></span><br><span class="line">	result += <span class="number">28</span> * weeks;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span> ;i&lt;weeks;i++)&#123;</span><br><span class="line">		result += <span class="number">7</span> * i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不足一个星期的钱</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span> ;i&lt;=days;i++)&#123;</span><br><span class="line">		result += weeks + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/babecdc85099428da37a143892e591e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1816. 截断句子</title>
    <url>/135xyq.github.io/2021/12/30/1816.%20%E6%88%AA%E6%96%AD%E5%8F%A5%E5%AD%90/</url>
    <content><![CDATA[<h1 id="1816-截断句子-split方法和循环判断"><a href="#1816-截断句子-split方法和循环判断" class="headerlink" title="1816. 截断句子 split方法和循环判断"></a>1816. 截断句子 split方法和循环判断</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/truncate-sentence/">查看原题</a></h2><h2 id="直接调用内置方法"><a href="#直接调用内置方法" class="headerlink" title="直接调用内置方法"></a>直接调用内置方法</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>先将字符串用split转为数组</li>
<li>用slice截取数组的0到k部分再用join连接</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> truncateSentence = <span class="function"><span class="keyword">function</span>(<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串转为数组后截取</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).splice(<span class="number">0</span>,k).join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="循环判断"><a href="#循环判断" class="headerlink" title="循环判断"></a>循环判断</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>新定义一个空字符result，定义count=0用来存储找到了几个空格</li>
<li>循环字符串，判断这一项是不是空格，如果是空格则count++</li>
<li>判断count和k的关系，如果count===k说明单词已经找够，break退出循环，else则将当前项加到result中</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var truncateSentence = function(s, k) &#123;</span><br><span class="line">    const length = s.length;</span><br><span class="line">    let result = &#x27;&#x27;;</span><br><span class="line">    let count = 0;</span><br><span class="line">    for(let i = 0;i&lt;length;i++)&#123;</span><br><span class="line">        if(s.charAt(i)===&#x27; &#x27;)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count === k)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>189. 轮转数组</title>
    <url>/135xyq.github.io/2021/12/30/189.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="189-轮转数组-利用数组内置方法splice和unshift"><a href="#189-轮转数组-利用数组内置方法splice和unshift" class="headerlink" title="189. 轮转数组 利用数组内置方法splice和unshift"></a>189. 轮转数组 利用数组内置方法splice和unshift</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/rotate-array/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>判断出哪些部分是要向右轮转的，用 k % nums.length求出要轮转的长度</li>
<li>找到第一个要轮转开始的地方 数组长度- 要轮转的长度</li>
<li>截取整个部分再用 unshift方法插入到数组的最前面就行<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = nums.length;</span><br><span class="line">    <span class="keyword">let</span> k1 = k % length;</span><br><span class="line">    nums.unshift(...nums.splice(length - k1))</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1995. 统计特殊四元组</title>
    <url>/135xyq.github.io/2021/12/30/1995.%20%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h1 id="1995-统计特殊四元组"><a href="#1995-统计特殊四元组" class="headerlink" title="1995. 统计特殊四元组"></a>1995. 统计特殊四元组</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/count-special-quadruplets/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>四层循环直接判断</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countQuadruplets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> t = j+<span class="number">1</span>;t&lt;nums.length-<span class="number">1</span>;t++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">let</span> l = t+<span class="number">1</span>;l&lt;nums.length;l++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(nums[i] + nums[j] + nums[t] === nums[l])&#123;</span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202. 快乐数</title>
    <url>/135xyq.github.io/2021/12/30/202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<h1 id="202-快乐数-while循环找到结束条件"><a href="#202-快乐数-while循环找到结束条件" class="headerlink" title="202. 快乐数  while循环找到结束条件"></a>202. 快乐数  while循环找到结束条件</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/happy-number/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先要明白一个数不是快乐数，则其中的计算过程会出现循环，要以此为结束条件</p>
<ol>
<li>先将数字的每一项取出来，存到一个数组中，因为会反复用到，所以建议写成一个方法 getEachNumber</li>
<li>根据得到的数字每一项计算平方和，将其存放到一个数组中 temp</li>
<li>先判断结果是否为 1<ul>
<li>为 1 则证明是快乐数，返回 true </li>
<li>不为1 则继续判断temp 是否出现过该数（判断是否出现了循环）<ul>
<li>如果出现了则返回false ，循环结束</li>
<li>没出现过讲 n 值更新为上一次计算的各项平凡和，继续循环</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> temp = []; <span class="comment">//存放每一次计算的结果，如果一个数不是快乐数说明到后面会形成循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> nums = getEachNumber(n); <span class="comment">//将数字每一项放在数组里;</span></span><br><span class="line">        <span class="keyword">let</span> result = nums.map(<span class="function"><span class="params">item</span> =&gt;</span> item ** <span class="number">2</span>); <span class="comment">//将数字每一项平方</span></span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>; <span class="comment">//每一次计算的各项平方和结果</span></span><br><span class="line">        result.forEach(<span class="function"><span class="params">item</span> =&gt;</span> sum += item);</span><br><span class="line">        <span class="keyword">if</span> (sum === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.indexOf(sum) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 结果形成了循环不会再等于 1 了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push(sum);</span><br><span class="line">        n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出数字的每一项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>n 传入要处理的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEachNumber</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nums = [];</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums.push(<span class="built_in">Math</span>.floor(n % <span class="number">10</span>))</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>217. 存在重复元素</title>
    <url>/135xyq.github.io/2021/12/30/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="217-存在重复元素-利用set来和数组长度比较-amp-排序比较"><a href="#217-存在重复元素-利用set来和数组长度比较-amp-排序比较" class="headerlink" title="217. 存在重复元素 利用set来和数组长度比较&amp;排序比较"></a>217. 存在重复元素 利用set来和数组长度比较&amp;排序比较</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用集合set来保证传入的数字元素唯一，再比较set的长度和数组的长度，如果两者长度一样则说明，数组转为集合时没有取出重复元素，也即数组中的元素都是不重复的，返回false，否者返回true</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(nums);</span><br><span class="line">    <span class="keyword">let</span> sum1 = <span class="number">0</span>,</span><br><span class="line">        sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (set.size === nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>可以先讲数组从小到大排序，则重复的数字会相邻。</li>
<li>循环判断数组的当前项是否等于下一项<ul>
<li>等于则直接返回</li>
<li>不等于就继续判断</li>
</ul>
</li>
<li>循环结束return false，到此还没返回说明数组里面不会有重复值</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">//将数组排序</span></span><br><span class="line">    <span class="comment">// 如果数组中存在重复元素，则排序后应该相邻</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2022. 将一维数组转变成二维数组</title>
    <url>/135xyq.github.io/2022/01/01/2022.%20%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8F%98%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="2022-将一维数组转变成二维数组"><a href="#2022-将一维数组转变成二维数组" class="headerlink" title="2022. 将一维数组转变成二维数组"></a>2022. 将一维数组转变成二维数组</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先判断能否转变，再循环一维数组数组转变成二维数组数组。</p>
<ol>
<li>若 original.length !== m * n 说明一位数组的长度过长或过短，直接返回 空数组[] ；</li>
<li>截取数组的n个长度添加到二维数组中。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">original</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> construct2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">original, m, n</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 元素个数不够或多余不能转为</span></span><br><span class="line">	<span class="keyword">if</span>(original.length !== m * n)&#123;</span><br><span class="line">		<span class="keyword">return</span> [];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> result= [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i &lt; m ;i++)&#123;</span><br><span class="line">		result.push(original.splice(<span class="number">0</span>,n))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>219. 存在重复元素 II</title>
    <url>/135xyq.github.io/2022/01/19/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<h1 id="219-存在重复元素-II-双重循环-amp-滑动窗口"><a href="#219-存在重复元素-II-双重循环-amp-滑动窗口" class="headerlink" title="219. 存在重复元素 II 双重循环 &amp; 滑动窗口"></a>219. 存在重复元素 II 双重循环 &amp; 滑动窗口</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">查看原题</a></h2><p><img src="https://img-blog.csdnimg.cn/d32370c0981b440a8ab0119e9a21defb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解题思路-双重循环"><a href="#解题思路-双重循环" class="headerlink" title="解题思路(双重循环)"></a>解题思路(双重循环)</h2><p>外层数组遍历数组，内层循环判断从当前位置开始的后面k个元素是否有和当前元素相同的，如果有直接返回true，找不到则返回false。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;=i+k;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i] === nums[j])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/cdbee3bf9dd94638aa8f77327e4ea876.png" alt="在这里插入图片描述"></p>
<h2 id="解题思路-滑动窗口"><a href="#解题思路-滑动窗口" class="headerlink" title="解题思路(滑动窗口)"></a>解题思路(滑动窗口)</h2><p>新建一个set集合，不断向set集合中添加和删除数据，注意判断条件</p>
<ol>
<li>当i&gt;k时，说明窗口长度到达了可以删除元素的长度，每次删除set集合中的第一个存进去元素(nums[i-k-1])</li>
<li>如果集合set中有当前元素，直接返回true</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">	<span class="keyword">const</span> length = nums.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &gt; k)&#123;</span><br><span class="line">			set.delete(nums[i-k-<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(set.has(nums[i]))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		set.add(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2de8502431b143b198e592d56d54829e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>242. 有效的字母异位词</title>
    <url>/135xyq.github.io/2021/12/30/242.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="242-有效的字母异位词-转为数组排序后比较"><a href="#242-有效的字母异位词-转为数组排序后比较" class="headerlink" title="242. 有效的字母异位词 转为数组排序后比较"></a>242. 有效的字母异位词 转为数组排序后比较</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>先判断两个字符串长度是否一样，不一样则肯定不是有效的字母异位词，直接返回false</li>
<li>执行这这以后说明字符串长度一样则将他们转为数组</li>
<li>可将数组排序，可直接使用sort ，因为sort是按ASCII码排序，所以可以直接使用</li>
<li>循环数组，判断两个数组的每一项是否相等，不相等则说明两个字符串中右的字母个数不一样</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个字符串长度不一样则不可能满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (s.length !== t.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串转为数组</span></span><br><span class="line">    <span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(s);</span><br><span class="line">    <span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from(t);</span><br><span class="line">    arr1.sort();</span><br><span class="line">    arr2.sort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] !== arr2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>258. 各位相加</title>
    <url>/135xyq.github.io/2021/12/30/258.%20%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0%20/</url>
    <content><![CDATA[<h1 id="258-各位相加-双层while循环"><a href="#258-各位相加-双层while循环" class="headerlink" title="258. 各位相加  双层while循环"></a>258. 各位相加  双层while循环</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/add-digits/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两层while循环控制，外层循环控计算结束，里层while控制将数字各项拆开计算求和；<br>每次循环计算求和都更新外层的num 为数字各项计算总和sum。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        num = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>278. 第一个错误的版本</title>
    <url>/135xyq.github.io/2021/12/30/278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="278-第一个错误的版本-二分法，注意判断结束条件"><a href="#278-第一个错误的版本-二分法，注意判断结束条件" class="headerlink" title="278. 第一个错误的版本  二分法，注意判断结束条件"></a>278. 第一个错误的版本  二分法，注意判断结束条件</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/first-bad-version/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分算法判断<br>如果当前项不是错误版本，说明错误版本在后面更新 right = mid + 1<br>如果当前是错误版本，则需要继续判断当前是不是第一个错误版本<br>    - 如果当前是错误版本且第 mid - 1 不是错误版本，则说明mid是第一个错误版本<br>    - 如果当前是错误版本且第 mid - 1 是错误版本，则继续循环</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;integer&#125;</span> </span>version number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>isBadVersion()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;integer&#125;</span> </span>n Total versions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;integer&#125;</span> </span>The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid))&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isBadVersion(mid))&#123;</span><br><span class="line">                <span class="keyword">if</span>(isBadVersion(mid - <span class="number">1</span>))&#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>283. 移动零</title>
    <url>/135xyq.github.io/2021/12/30/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将right赋值为nums.length-1,代表当前连续0开始的位置</li>
<li>lef赋值为 0 表示当前数组扫描的位置</li>
<li>从左到右扫描数组，如果当前项是 0 则将从数组当前项到连续0开始位置之间的数组项都向前移动一位，然后在后面补0，同时更新 right– ,不在更新left，防止有连续的0，再次回到这个位置</li>
<li>如果当前项不是0 则更新left++</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left; <span class="comment">//左指针，开始循环</span></span><br><span class="line">    <span class="keyword">let</span> length = nums.length;</span><br><span class="line">    <span class="keyword">let</span> right = length - <span class="number">1</span>; <span class="comment">//右指针的最开始位置</span></span><br><span class="line">    <span class="keyword">for</span> (left = <span class="number">0</span>; left &lt;= right;) &#123;</span><br><span class="line">        <span class="comment">// 如果当前项是0则将当前项之后的数值向前移一位</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = left + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">                nums[j - <span class="number">1</span>] = nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = <span class="number">0</span>;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>344. 反转字符串</title>
    <url>/135xyq.github.io/2021/12/30/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="344-反转字符串-reverse-amp-双指针-amp-splice"><a href="#344-反转字符串-reverse-amp-双指针-amp-splice" class="headerlink" title="344. 反转字符串 reverse&amp;双指针&amp;splice"></a>344. 反转字符串 reverse&amp;双指针&amp;splice</h1><h1 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/reverse-string/">查看原题</a></h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次将数组最后一个pop再用splice插入到数组中</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = s.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        s.splice(i, <span class="number">0</span>, s.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针，找出交换后的位置进行交换</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = s.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = s[i];</span><br><span class="line">        s[i] = s[len - <span class="number">1</span> - i];</span><br><span class="line">        s[len - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用reverse方法</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>318. 最大单词长度乘积</title>
    <url>/135xyq.github.io/2021/12/30/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="318-最大单词长度乘积-暴力循环"><a href="#318-最大单词长度乘积-暴力循环" class="headerlink" title="318. 最大单词长度乘积 暴力循环"></a>318. 最大单词长度乘积 暴力循环</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接双层循环判断两项是否有字符一样，如果不一样则计算长度的乘积，并与最大值比较，不断更新最大值</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProduct</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i, j;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="number">0</span>; <span class="comment">//表示有无重复</span></span><br><span class="line">            <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(words[i]);</span><br><span class="line">            <span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>(words[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> set1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.has(item)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((words[i].length * words[j].length) &gt; max) &#123;</span><br><span class="line">                    max = words[i].length * words[j].length</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/135xyq.github.io/2021/12/30/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="35-搜索插入位置-二分注意细分判断条件"><a href="#35-搜索插入位置-二分注意细分判断条件" class="headerlink" title="35. 搜索插入位置 二分注意细分判断条件"></a>35. 搜索插入位置 二分注意细分判断条件</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分算法，注意不同的判断条件</p>
<ol>
<li>left 为左边界初始值为 0 ，right 为右边界 初始值为 nums.length - 1</li>
<li>注意while的循环条件为 left&lt;= right ， mid = Math.floor((left + right) / 2);</li>
<li>开始判断nums[mid] 和target的关系<ol>
<li>如果nums[mid] &gt; target <ul>
<li>继续判断mid是否在数组的第一项了<ol>
<li>如果不是第一项则 right = mid - 1;</li>
<li>如果是第一项应该直接结束，说明此时数组中没有target，且小于nums[0],则应该插在第0位</li>
</ol>
</li>
</ul>
</li>
<li>如果nums[mid] &lt; target<ul>
<li>继续判断mid是否在数组的最后一项了<ol>
<li>如果不是最后一项则 left = mid + 1;</li>
<li>如果是最后一项应该直接结束，说明此时数组中没有target，且大于nums[nums.length -1],则直接插在第 nums.length 位</li>
</ol>
</li>
</ul>
</li>
<li>如果nums[mid] === target <ul>
<li>直接返回 mid</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid != <span class="number">0</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid + <span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid != nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums.length;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>383. 赎金信</title>
    <url>/135xyq.github.io/2021/12/30/383.%20%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="383-赎金信-哈希表"><a href="#383-赎金信-哈希表" class="headerlink" title="383. 赎金信 哈希表"></a>383. 赎金信 哈希表</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/ransom-note/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将 magazine字符串映射到map集合中，键为字符的种类，值为字符的个数；</li>
<li>将 ransomNote字符串映射到map1集合中，键为字符的种类，值为字符的个数；</li>
<li>遍历map1，查找map中是否存在对应的键，且值大于等于map1中对应的值。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">ransomNote</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">magazine</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="function"><span class="keyword">function</span>(<span class="params">ransomNote, magazine</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将杂志字符串映射到map集合</span></span><br><span class="line">	<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;magazine.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.has(magazine.charAt(i)))&#123;</span><br><span class="line">			map.set(magazine.charAt(i),map.get(magazine[i])+<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			map.set(magazine[i],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将赎金信映射到map1中</span></span><br><span class="line">	<span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;ransomNote.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map1.has(ransomNote.charAt(i)))&#123;</span><br><span class="line">			map1.set(ransomNote.charAt(i),map1.get(ransomNote[i])+<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			map1.set(ransomNote[i],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> [key,value] <span class="keyword">of</span> map1)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.has(key) &amp;&amp; map.get(key)&gt;=value)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>390. 消除游戏</title>
    <url>/135xyq.github.io/2022/01/01/390.%20%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="390-消除游戏"><a href="#390-消除游戏" class="headerlink" title="390. 消除游戏"></a>390. 消除游戏</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/elimination-game/">查看原题</a></h2><h2 id="解题思路-循环模拟删除过程"><a href="#解题思路-循环模拟删除过程" class="headerlink" title="解题思路(循环模拟删除过程)"></a>解题思路(循环模拟删除过程)</h2><p>很不幸这种方法爆了，超时，但思路就是这样。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastRemaining = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		arr.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (arr.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> length = arr.length;</span><br><span class="line">		<span class="comment">// 从左到右消除</span></span><br><span class="line">		<span class="keyword">if</span>(flag % <span class="number">2</span> === <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;<span class="built_in">Math</span>.ceil(length / <span class="number">2</span>);j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">					arr.splice(j,<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">// 从右往左消除</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> j = length -<span class="number">1</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">					arr.splice(j,<span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		flag++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">## 解题思路(参考别人题解)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f(n) 表示从左到右剩下的数字的结果, f<span class="string">&#x27;(n) 表示从右到左删除的结果</span></span><br><span class="line"><span class="string">对称性: f(n) + f&#x27;</span>(n) = n + <span class="number">1</span></span><br><span class="line">递归性: f(n) = <span class="number">2</span> * f<span class="string">&#x27;(n/2)</span></span><br><span class="line"><span class="string">初始条件: f(1) = f&#x27;</span>(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">根据以上条件可得: f(<span class="number">2</span> * n)/<span class="number">2</span> + f(n) = n + <span class="number">1</span></span><br><span class="line">f(n)/<span class="number">2</span> + f(n/<span class="number">2</span>) = n/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">f(n) = (n/<span class="number">2</span> + <span class="number">1</span> - f(n/<span class="number">2</span>)) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">## 代码</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="string"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">var lastRemaining = function(n) &#123;</span></span><br><span class="line"><span class="string">	return n == 1 ? 1 : 2 * (parseInt(n / 2) + 1 - lastRemaining(parseInt(n / 2)));</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>391. 完美矩形</title>
    <url>/135xyq.github.io/2021/12/30/391.%20%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="391-完美矩形-map哈希"><a href="#391-完美矩形-map哈希" class="headerlink" title="391. 完美矩形 map哈希"></a>391. 完美矩形 map哈希</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/perfect-rectangle/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="只要满足两个条件就是完美矩形："><a href="#只要满足两个条件就是完美矩形：" class="headerlink" title="只要满足两个条件就是完美矩形："></a>只要满足两个条件就是完美矩形：</h3><p>1.所有矩形总面积 == 恰好围住所有矩形的大矩形的面积<br>2.任意两个矩形都没有重叠。这种情况下由于所有矩形是镶嵌的，所以位于大矩形内（除了大矩形的四个角）的任何位置的小矩形顶点数只可能为0,2,4。其他任何情况都代表有重叠。而大矩形四个顶点处的小矩形顶点数量只能为1。</p>
<h3 id="判断矩形总面积是否等于围住所有矩形的大矩形的面积"><a href="#判断矩形总面积是否等于围住所有矩形的大矩形的面积" class="headerlink" title="判断矩形总面积是否等于围住所有矩形的大矩形的面积"></a>判断矩形总面积是否等于围住所有矩形的大矩形的面积</h3><ol>
<li>先将大的数组拆开为四个小数组，每个数组表示左下和右上两个点的横纵坐标</li>
<li>找出大矩形的左下和右上坐标</li>
<li>求出大矩形的面积</li>
<li>求出每个小矩形的面积求和</li>
<li>判断是否相等，不相等直接返回 false 相等则进入下一判断</li>
</ol>
<h3 id="判断是否有重叠"><a href="#判断是否有重叠" class="headerlink" title="判断是否有重叠"></a>判断是否有重叠</h3><ol>
<li>将每个小矩形的坐标存到一个大数组中</li>
<li>循环数组，用map哈希将每个坐标点的重复次数映射</li>
<li>判断每个坐标点的情况（大矩形内（除了大矩形的四个角）的任何位置的小矩形顶点数只可能为0,2,4。其他任何情况都代表有重叠。而大矩形四个顶点处的小矩形顶点数量只能为1。）</li>
<li>最后返回true ，此处返回说明前面的条件都满足</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">rectangles</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  只要满足两个条件就是完美矩形：</span></span><br><span class="line"><span class="comment">// 1.所有矩形总面积 == 恰好围住所有矩形的大矩形的面积</span></span><br><span class="line"><span class="comment">// 2.任意两个矩形都没有重叠。这种情况下由于所有矩形是镶嵌的，所以位于大矩形内（除了大矩形的四个角）的任何位置的小矩形顶点数只可能为0,2,4。其他任何情况都代表有重叠。而大矩形四个顶点处的小矩形顶点数量只能为1。</span></span><br><span class="line"><span class="comment">//  */</span></span><br><span class="line"><span class="keyword">var</span> isRectangleCover = <span class="function"><span class="keyword">function</span>(<span class="params">rectangles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nums1 = [],</span><br><span class="line">        nums2 = [],</span><br><span class="line">        nums3 = [],</span><br><span class="line">        nums4 = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rectangles.length; i++) &#123;</span><br><span class="line">        nums1.push(rectangles[i][<span class="number">0</span>]);</span><br><span class="line">        nums2.push(rectangles[i][<span class="number">1</span>]);</span><br><span class="line">        nums3.push(rectangles[i][<span class="number">2</span>]);</span><br><span class="line">        nums4.push(rectangles[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> minNum1 = <span class="built_in">Math</span>.min(...nums1);</span><br><span class="line">    <span class="keyword">const</span> minNum2 = <span class="built_in">Math</span>.min(...nums2);</span><br><span class="line">    <span class="keyword">const</span> maxNum1 = <span class="built_in">Math</span>.max(...nums3);</span><br><span class="line">    <span class="keyword">const</span> maxNum2 = <span class="built_in">Math</span>.max(...nums4);</span><br><span class="line">    <span class="keyword">const</span> maxArear = (maxNum2 - minNum2) * (maxNum1 - minNum1);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    rectangles.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        sum += ((item[<span class="number">3</span>] - item[<span class="number">1</span>]) * (item[<span class="number">2</span>] - item[<span class="number">0</span>]));</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> a = []; <span class="comment">//存放每个坐标的字符串</span></span><br><span class="line">    <span class="keyword">if</span> (sum === maxArear) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rectangles.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 将四个角的坐标加入</span></span><br><span class="line">            a.push(nums1[i] + <span class="string">&quot;,&quot;</span> + nums2[i]);</span><br><span class="line">            a.push(nums1[i] + <span class="string">&quot;,&quot;</span> + nums4[i]);</span><br><span class="line">            a.push(nums3[i] + <span class="string">&quot;,&quot;</span> + nums4[i]);</span><br><span class="line">            a.push(nums3[i] + <span class="string">&quot;,&quot;</span> + nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.has(a[i])) &#123;</span><br><span class="line">                map.set(a[i], map.get(a[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.set(a[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断四个顶点是否重复一次</span></span><br><span class="line">        <span class="comment">// 四个顶点</span></span><br><span class="line">        <span class="keyword">const</span> leftBottom = minNum1 + <span class="string">&#x27;,&#x27;</span> + minNum2;</span><br><span class="line">        <span class="keyword">const</span> leftTop = minNum1 + <span class="string">&#x27;,&#x27;</span> + maxNum2;</span><br><span class="line">        <span class="keyword">const</span> rightBottom = maxNum1 + <span class="string">&#x27;,&#x27;</span> + minNum2;</span><br><span class="line">        <span class="keyword">const</span> rightTop = maxNum1 + <span class="string">&#x27;,&#x27;</span> + maxNum2;</span><br><span class="line">        <span class="keyword">const</span> four = [leftBottom, leftTop, rightBottom, rightTop];</span><br><span class="line">        <span class="comment">//遍历map对象判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (four.indexOf(key) === -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (four.indexOf(key) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (four.indexOf(key) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>438. 找到字符串中所有字母异位词</title>
    <url>/135xyq.github.io/2021/12/30/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="438-找到字符串中所有字母异位词-滑动窗口"><a href="#438-找到字符串中所有字母异位词-滑动窗口" class="headerlink" title="438. 找到字符串中所有字母异位词 滑动窗口"></a>438. 找到字符串中所有字母异位词 滑动窗口</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是最容易想到的，循环，无用功太多，结果自然是g了<br><strong>超出时间限制</strong></p>
<ol>
<li>先将p转为数组排序后再转为字符串</li>
<li>循环s利用字符串方法slice截取和p等长的字符串，再进行排序最后比较是否相等</li>
<li>如果相等就push到结果数组中</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = [];<span class="comment">//结果</span></span><br><span class="line">	<span class="keyword">const</span> slength = s.length;</span><br><span class="line">	<span class="keyword">const</span> plength = p.length;</span><br><span class="line">	<span class="keyword">const</span> arr = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">	<span class="keyword">const</span> p1 = p.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);<span class="comment">//将p转为数组排序后再转为字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;=slength - plength;i++)&#123;</span><br><span class="line">		<span class="keyword">let</span> temp = arr.slice(i,plength+i)</span><br><span class="line">		<span class="keyword">if</span>(temp.sort().join(<span class="string">&#x27;&#x27;</span>) === p1)</span><br><span class="line">		result.push(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种思路使用了滑动窗口，虽然能解决问题，能通过测试，但效率还是有点低。</p>
<ol>
<li>将字符串p中的字母和字母的个数映射到map集合中</li>
<li>循环字符串s取出和p等长的一段，判断map集合中是否右当前元素，且元素的数量不是0</li>
<li>每次符合条件都要更新temp里面的数据，注意这个temp每次都要新建,通过p映射的那个map集合创建</li>
<li><code>!temp.has(s.charAt(j))||temp.get(s.charAt(j))===0</code>这是判断条件，为true则直接break，为false则更新temp集合<code>temp.set(s.charAt(j),temp.get(s.charAt(j))-1)</code></li>
<li>判断<code>j===i+plength</code>，来说明循环是否正常走完，为false则不是正常走完，说明不符合条件；为true说明正常走完了循环，则将 i push到结果数组中。</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = [];<span class="comment">//结果</span></span><br><span class="line">	<span class="keyword">const</span> slength = s.length;</span><br><span class="line">	<span class="keyword">const</span> plength = p.length;</span><br><span class="line">	<span class="keyword">const</span> pmap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">	<span class="comment">// 将字符串p的单词和个数映射到map对象中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;plength;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pmap.has(p.charAt(i)))&#123;</span><br><span class="line">			pmap.set(p.charAt(i),pmap.get(p.charAt(i))+<span class="number">1</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			pmap.set(p.charAt(i),<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;=slength-plength;i++)&#123;</span><br><span class="line">		<span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="built_in">Map</span>(pmap);</span><br><span class="line">		<span class="keyword">let</span> j;</span><br><span class="line">		<span class="keyword">for</span>( j = i;j&lt;i+plength;j++)&#123;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">if</span>(!temp.has(s.charAt(j))||temp.get(s.charAt(j))===<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				temp.set(s.charAt(j),temp.get(s.charAt(j))-<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j===i+plength)&#123;</span><br><span class="line">			result.push(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种思路效率就比较高了，当然是参考别人的了</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || !p) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> need = &#123;&#125;, <span class="built_in">window</span> = &#123;&#125;, ans = [];</span><br><span class="line">    [...p].forEach(<span class="function"><span class="params">c</span> =&gt;</span> need[c] ? need[c]++ : need[c] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>, nkLen = <span class="built_in">Object</span>.keys(need).length;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> c1 = s[r];</span><br><span class="line">        <span class="keyword">if</span> (need[c1]) &#123;</span><br><span class="line">            <span class="built_in">window</span>[c1] ? <span class="built_in">window</span>[c1]++ : <span class="built_in">window</span>[c1] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>[c1] === need[c1]) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">while</span> (cnt === nkLen) &#123;</span><br><span class="line">            <span class="keyword">let</span> c2 = s[l];</span><br><span class="line">            <span class="keyword">if</span> ((r - l) == p.length) ans.push(l);</span><br><span class="line">            <span class="keyword">if</span> (need[c2]) &#123;</span><br><span class="line">                <span class="built_in">window</span>[c2]--;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">window</span>[c2] &lt; need[c2]) cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 旋转图像</title>
    <url>/135xyq.github.io/2021/12/30/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="48-旋转图像-另开空间和直接旋转"><a href="#48-旋转图像-另开空间和直接旋转" class="headerlink" title="48. 旋转图像 另开空间和直接旋转"></a>48. 旋转图像 另开空间和直接旋转</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/rotate-image/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>新开一个二维数组，存放交换后的数据</li>
<li>遍历原数组，将交换后的值存放到相应位置 <code>temp[j][length-i-1] = matrix[i][j];</code></li>
<li>将新数组的值再次赋给原数组</li>
<li>这种思路，时间复杂度为 O(N^2),空间复杂度为 O(N^2)</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 矩阵的宽度</span></span><br><span class="line">	<span class="keyword">const</span> length =  matrix.length;</span><br><span class="line">	<span class="keyword">const</span> temp = (<span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="number">0</span>)).map(<span class="function"><span class="params">item</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(length));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">			temp[j][length-i-<span class="number">1</span>] = matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">			matrix[i][j] = temp[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>不开辟新数组，找出新矩阵的每一项的对应的原矩阵的位置为<code>matrix[j][length-i-1] = matrix[i][j];</code></li>
<li>但是这样会发现交换之后会把原有位置上的数据覆盖，所以应该先把原有位置上的数据移动到应该的位置。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = matrix[i][j];</span><br><span class="line">matrix[i][j] = matrix[length-<span class="number">1</span>-j][i];</span><br><span class="line">matrix[length-<span class="number">1</span>-j][i] = matrix[length-<span class="number">1</span>-i][length-<span class="number">1</span>-j];</span><br><span class="line">matrix[length-<span class="number">1</span>-i][length-<span class="number">1</span>-j] = matrix[j][length-<span class="number">1</span>-i];</span><br><span class="line">matrix[j][length-<span class="number">1</span>-i] = temp;</span><br></pre></td></tr></table></figure></li>
<li>判断哪些应该交换，当数组的长度length为偶数时：需要交换n^2/4=(n/2)×(n/2) 个位置;当length 为奇数是：需要交换(n^2−1)/4=((n−1)/2)×((n+1)/2)</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 矩阵的宽度</span></span><br><span class="line">	<span class="keyword">const</span> length =  matrix.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="built_in">Math</span>.floor(length/<span class="number">2</span>);i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;<span class="built_in">Math</span>.floor((length+<span class="number">1</span>)/<span class="number">2</span>);j++)&#123;</span><br><span class="line">			<span class="keyword">let</span> temp = matrix[i][j];</span><br><span class="line">			matrix[i][j] = matrix[length-<span class="number">1</span>-j][i];</span><br><span class="line">			matrix[length-<span class="number">1</span>-j][i] = matrix[length-<span class="number">1</span>-i][length-<span class="number">1</span>-j];</span><br><span class="line">			matrix[length-<span class="number">1</span>-i][length-<span class="number">1</span>-j] = matrix[j][length-<span class="number">1</span>-i];</span><br><span class="line">			matrix[j][length-<span class="number">1</span>-i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>414. 第三大的数</title>
    <url>/135xyq.github.io/2021/12/30/414.%20%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="414-第三大的数-利用set数组去重和sort排序"><a href="#414-第三大的数-利用set数组去重和sort排序" class="headerlink" title="414. 第三大的数  利用set数组去重和sort排序"></a>414. 第三大的数  利用set数组去重和sort排序</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/third-maximum-number/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将数组转为set 集合去除重复值，再转为数组</li>
<li>将数组降序排序</li>
<li>判断数组的长度<ul>
<li>长度大于 3 则直接返回数组的第3大的数</li>
<li>长度小于 3 直接返回数组的最大值即最大项</li>
</ul>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> thirdMax = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将数组去重</span></span><br><span class="line">    <span class="keyword">const</span> newNums = [...new <span class="built_in">Set</span>(nums)];</span><br><span class="line">    newNums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    <span class="keyword">if</span> (newNums.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNums[<span class="number">2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newNums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>507. 完美数</title>
    <url>/135xyq.github.io/2021/12/31/507.%20%E5%AE%8C%E7%BE%8E%E6%95%B0/</url>
    <content><![CDATA[<h1 id="507-完美数-直接求解-amp-数学理论"><a href="#507-完美数-直接求解-amp-数学理论" class="headerlink" title="507. 完美数 直接求解&amp;数学理论"></a>507. 完美数 直接求解&amp;数学理论</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/perfect-number/">查看原题</a></h2><h2 id="解题思路（直接求因子）"><a href="#解题思路（直接求因子）" class="headerlink" title="解题思路（直接求因子）"></a>解题思路（直接求因子）</h2><p>直接循环找出每一个正因子相加判断</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> checkPerfectNumber = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num ===<span class="number">1</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> sum  = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sqrt(num));i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(num % i === <span class="number">0</span>)&#123;</span><br><span class="line">			sum += num/i + i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum === num)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解题思路（数学理论）"><a href="#解题思路（数学理论）" class="headerlink" title="解题思路（数学理论）"></a>解题思路（数学理论）</h2><p>根据欧几里得-欧拉定理，每个偶完全数都可以写成</p>
<p>$$2^p-1(2^p -1)$$</p>
<p>的形式，其中 $p$ 为素数且 $2^p-1$也是素数</p>
<p>由于目前奇完全数还未被发现，因此题目范围 [1,10^8][1,10^8] 内的完全数都可以写成上述形式。<br>这一共有如下 5 个：<br>6, 28, 496, 8128, 33550336</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> checkPerfectNumber = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num === <span class="number">6</span> || num === <span class="number">28</span> || num === <span class="number">496</span> || num === <span class="number">8128</span> || num === <span class="number">33550336</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>495.提莫攻击</title>
    <url>/135xyq.github.io/2021/12/30/495.%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495.提莫攻击"></a>495.提莫攻击</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>根据题意肯定是根据不同的情况加上不同的数值，先定义一个存储结果的变量；</li>
<li>循环数组判断当前项是不是数组的最后一项<ul>
<li>如果是最后一项则不需要判断，直接加上中毒持续时间duration即可</li>
</ul>
</li>
<li>如果不是最后则分两种情况判断<ul>
<li>这次中毒结束完还没开始下一次的中毒，则需要加上中毒的持续时间爱duration</li>
<li>这次中毒还没结束下次就开始了，则需要用下次的开始时间减去这次的时间即为本次中毒时间</li>
</ul>
</li>
</ol>
<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">原题</a></h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">timeSeries</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">duration</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findPoisonedDuration = <span class="function"><span class="keyword">function</span>(<span class="params">timeSeries, duration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> length = timeSeries.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i !== length - <span class="number">1</span>) &amp;&amp; ((timeSeries[i] + duration - <span class="number">1</span>) &lt; timeSeries[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            sum += duration;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i !== length - <span class="number">1</span>) &amp;&amp; ((timeSeries[i] + duration - <span class="number">1</span>) &gt;= timeSeries[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            sum += (timeSeries[i + <span class="number">1</span>] - timeSeries[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === length - <span class="number">1</span>) &#123;</span><br><span class="line">            sum += duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>506. 相对名次</title>
    <url>/135xyq.github.io/2021/12/30/506.%20%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1%20/</url>
    <content><![CDATA[<h1 id="506-相对名次-排序后switch"><a href="#506-相对名次-排序后switch" class="headerlink" title="506. 相对名次 排序后switch"></a>506. 相对名次 排序后switch</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/relative-ranks/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>深克隆一个数组temp，将temp降序排序；</li>
<li>遍历原数组，判断每一项，前三名特殊处理；</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">score</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRelativeRanks = <span class="function"><span class="keyword">function</span>(<span class="params">score</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> temp = [...score];<span class="comment">//得到一个为新数组</span></span><br><span class="line">	temp.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a);<span class="comment">//将数组降序排列，得到正确的名次</span></span><br><span class="line">	<span class="keyword">let</span> result = [];</span><br><span class="line">	score.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> index = temp.indexOf(item);<span class="comment">//得到当前元素的排名</span></span><br><span class="line">		<span class="keyword">switch</span> (index)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				result.push(<span class="string">&#x27;Gold Medal&#x27;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				result.push(<span class="string">&#x27;Silver Medal&#x27;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				result.push(<span class="string">&#x27;Bronze Medal&#x27;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				result.push(<span class="string">`<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findRelativeRanks(score = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>520. 检测大写字母</title>
    <url>/135xyq.github.io/2021/12/30/520.%20%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="520-检测大写字母-求出大小写字母的个数"><a href="#520-检测大写字母-求出大小写字母的个数" class="headerlink" title="520. 检测大写字母   求出大小写字母的个数"></a>520. 检测大写字母   求出大小写字母的个数</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>统计出单词中大写字母和小写字母的个数，使用（word.charAt(i) &gt;= ‘A’ &amp;&amp; word.charAt(i) &lt;= ‘Z’）判断是否是大写字母</li>
<li>根据大小写字母的数量判断是否合法<ul>
<li>如果大写字母个数为0 或小写字母个数为0则合法</li>
<li>如果大写字母的个数为1则继续判断单词的第一个字母是不是大写的，如果是则合法，不是就不合法</li>
<li>其他情况均为不合法</li>
</ul>
</li>
</ol>
<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode-cn.com/problems/detect-capital/">原题</a></h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCapitalUse = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = word.length;</span><br><span class="line">    <span class="keyword">let</span> upper = <span class="number">0</span>; <span class="comment">//计算有多少个大写字母</span></span><br><span class="line">    <span class="keyword">let</span> lower = <span class="number">0</span>; <span class="comment">//有多少小写字母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.charAt(i) &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; word.charAt(i) &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            upper++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lower++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lower === <span class="number">0</span> || upper === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (upper === <span class="number">1</span> &amp;&amp; (word.charAt(<span class="number">0</span>) &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; word.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>539. 最小时间差</title>
    <url>/135xyq.github.io/2022/01/18/539.%20%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE/</url>
    <content><![CDATA[<h1 id="539-最小时间差-将时间转为数字进行比较"><a href="#539-最小时间差-将时间转为数字进行比较" class="headerlink" title="539. 最小时间差 将时间转为数字进行比较"></a>539. 最小时间差 将时间转为数字进行比较</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/minimum-time-difference/">查看原题</a></h2><p><img src="https://img-blog.csdnimg.cn/4cf97b6a15c8428da07e5f09c298ec89.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>将时间转为一天中的多少分钟</p>
<ol>
<li>使用split将时间按照’:’分为小时和分钟，再将小时转为分钟存到数组arr中</li>
<li>将arr排序(升序),再遍历求出相邻元素的最小差值min</li>
<li>注意要比较第一个和最后一个元素的差值，判断arr中最后一个元素的值距离00：00还需多少分钟，再加上arr中第一个元素的值，与当前最小的分钟数进行比较。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">timePoints</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinDifference = <span class="function"><span class="keyword">function</span>(<span class="params">timePoints</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;timePoints.length;i++)&#123;</span><br><span class="line">		<span class="comment">// 将时间拆开</span></span><br><span class="line">		<span class="keyword">const</span> temp = timePoints[i].split(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">		arr.push(<span class="built_in">parseInt</span>(temp[<span class="number">0</span>]) * <span class="number">60</span> + <span class="built_in">parseInt</span>(temp[<span class="number">1</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">	<span class="keyword">let</span> min = <span class="number">1440</span> ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(min &gt; arr[i] - arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">			min = arr[i] - arr[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> maxNum = <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">if</span>(maxNum - arr[arr.length - <span class="number">1</span>] + arr[<span class="number">0</span>] &lt; min)&#123;</span><br><span class="line">		min = maxNum - arr[arr.length - <span class="number">1</span>] + arr[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(arr)</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10baaeb750b8414f8d2674bec97a584e.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>557. 反转字符串中的单词</title>
    <url>/135xyq.github.io/2021/12/30/557.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
    <content><![CDATA[<h1 id="557-反转字符串中的单词-III-转为数组逆序在转为字符-amp-循环交换"><a href="#557-反转字符串中的单词-III-转为数组逆序在转为字符-amp-循环交换" class="headerlink" title="557. 反转字符串中的单词 III 转为数组逆序在转为字符&amp;循环交换"></a>557. 反转字符串中的单词 III 转为数组逆序在转为字符&amp;循环交换</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将字符串按空格使用split分割为数组</li>
<li>遍历数组每一项，再用split转为数组，使用reverse逆序，再使用join合并为字符串</li>
<li>将数组使用join(‘ ‘)转为字符串</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = s.split(<span class="string">&#x27; &#x27;</span>); <span class="comment">//将字符串转为数组</span></span><br><span class="line">    <span class="keyword">let</span> result = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>新开一个数组，用来存放结果</li>
<li>遍历原数组，计算每一个单词的长度，方法如下：判断当前项是不是 ‘ ‘<ul>
<li>是，则sum++（sum统计单词的长度）</li>
<li>不是则新定义一个临时数组temp，将根据刚才计算的单词的长度，push到temp中，再将其转为字符串后加入到大数组中，最后判断当前项是不是最后一个单词，如果不是最后一个则需要再给大数组push一个’ ‘ ,<br>最后将大数组转为字符串，返回。</li>
</ul>
</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = s.length;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>; <span class="comment">//一个单词的长度</span></span><br><span class="line">    <span class="comment">// 要多处理一个判断长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果不等于空格则说明是一个单词，统一处理</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] !== <span class="string">&#x27; &#x27;</span> &amp;&amp; i !== length) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将一个单词翻转</span></span><br><span class="line">            <span class="keyword">let</span> temp = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = sum - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                temp.push(s[i - sum + j]);</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            result.push(temp.join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">            <span class="keyword">if</span> (i !== length) &#123;</span><br><span class="line">                result.push(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>563. 二叉树的坡度</title>
    <url>/135xyq.github.io/2021/12/30/563.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="563-二叉树的坡度-树的深度优先搜索"><a href="#563-二叉树的坡度-树的深度优先搜索" class="headerlink" title="563. 二叉树的坡度   树的深度优先搜索"></a>563. 二叉树的坡度   树的深度优先搜索</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>树的深度优先搜索</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findTilt = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> leftNum = dfs(node.left);</span><br><span class="line">        <span class="keyword">const</span> rightNum = dfs(node.right);</span><br><span class="line">        sum += <span class="built_in">Math</span>.abs(leftNum - rightNum);</span><br><span class="line">        <span class="keyword">return</span> leftNum + rightNum + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>567. 字符串的排列</title>
    <url>/135xyq.github.io/2021/12/30/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>先求出s1里面各个字符的个数存储到数组arr1中</li>
<li>再遍历数组s2注意结束条件是 <code>let i = 0;i&lt;=s2.length - s1.length;i++</code>,当个数少于<code>s2.length - s1.length</code>不会再有结果</li>
<li>统计s2中每个s1.length长度区间的各个字符的个数，与s1中的比较，如果元素个数都一样则符合条件返回true</li>
<li>直接返回false，说明前面没有符合条件的</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> checkInclusion = <span class="function"><span class="keyword">function</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s1)&#123;</span><br><span class="line">		arr1[item.charCodeAt() - <span class="number">97</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;=s2.length - s1.length;i++)&#123;</span><br><span class="line">		<span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;s1.length;j++)&#123;</span><br><span class="line">			arr2[s2.charCodeAt(i+j) - <span class="number">97</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(t = <span class="number">0</span>;t&lt;<span class="number">26</span>;t++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr2[t] !== arr1[t])&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t===<span class="number">26</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>704. 二分查找</title>
    <url>/135xyq.github.io/2021/12/30/704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="704-二分查找-二分"><a href="#704-二分查找-二分" class="headerlink" title="704. 二分查找  二分"></a>704. 二分查找  二分</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分算法，</p>
<ol>
<li>求左右边界left 和 right 的中间值mid</li>
<li>判断中心值对应的数组值 nums[mid] 与要比较的值target大小关系<ul>
<li>大，则更新右边界right = mid - 1</li>
<li>小，则更新左边界left = mid +1</li>
<li>相等，直接返回mid</li>
</ul>
</li>
<li>循环判断直到 left&lt;= right</li>
<li>直接返回-1，这里返回说明前面肯定没有返回，说明没找到对应的下标</li>
</ol>
<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode-cn.com/problems/binary-search/">原题</a></h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>594. 最长和谐子序列</title>
    <url>/135xyq.github.io/2021/12/30/594.%20%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="594-最长和谐子序列-Map对象"><a href="#594-最长和谐子序列-Map对象" class="headerlink" title="594. 最长和谐子序列 Map对象"></a>594. 最长和谐子序列 Map对象</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>将数组映射到Map对象中，以数组的值为键，以数组值得个数为Map对象的值</li>
<li>使用forof循环取出对象的每一项</li>
<li><code>const right = map.get(key + 1) ? map.get(key + 1) : 0;</code><br>  <code>const left = map.get(key - 1) ? map.get(key + 1) : 0;</code><br> 将当前项得左右两项做出判断</li>
<li>求出左右项得最大值</li>
<li>判断是否要更新总的最大值（条件是左右两项至少存在一个，且两者之和大于当前的总最大值）</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```javascript<br>/**</p>
<ul>
<li>@param {number[]} nums</li>
<li>@return {number}</li>
<li>/<br>var findLHS = function(nums) {<br>  let result = 0; //返回结果<br>  const map = new Map();<br>  for (const num of nums) {<pre><code>  if (map.has(num)) &#123;
      map.set(num, map.get(num) + 1);
  &#125; else &#123;
      map.set(num, 1)
  &#125;
</code></pre>
  }<br>  for (const [key, value] of map) {<pre><code>  const right = map.get(key + 1) ? map.get(key + 1) : 0;
  const left = map.get(key - 1) ? map.get(key + 1) : 0;
  let max = Math.max(left, right);
  if ((max + value) &gt; result &amp;&amp; max &gt; 0) &#123;
      result = max + value;
  &#125;
</code></pre>
  }<br>  return result;<br>};</li>
</ul>
<p>`<br>``</p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>71. 简化路径</title>
    <url>/135xyq.github.io/2022/01/06/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="71-简化路径-栈的应用"><a href="#71-简化路径-栈的应用" class="headerlink" title="71. 简化路径 栈的应用"></a>71. 简化路径 栈的应用</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/simplify-path/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们首先将给定的字符串 path 根据/分割成一个由若干字符串组成的列表，记为names。根据题目中规定的「规范路径的下述格式」，names 中包含的字符串只能为以下几种：</p>
<ul>
<li><p>空字符串。例如当出现多个连续的 \texttt{/}/，就会分割出空字符串；</p>
</li>
<li><p>一个点 .</p>
</li>
<li><p>两个点 ..</p>
</li>
<li><p>只包含英文字母、数字或 _ 的目录名。</p>
</li>
</ul>
<p>对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。</p>
<p>对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。</p>
<p>这样一来，我们只需要遍历names中的每个字符串并进行上述操作即可。在所有的操作完成后，我们将从栈底到栈顶的字符串用 / 进行连接，再在最前面加上 / 表示根目录，就可以得到简化后的规范路径。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```javascript<br>/**</p>
<ul>
<li>@param {string} path</li>
<li>@return {string}</li>
<li>/</li>
</ul>
<p>// 始终以斜杠 ‘/‘ 开头。<br>// 两个目录名之间必须只有一个斜杠 ‘/‘ 。<br>// 最后一个目录名（如果存在）不能 以 ‘/‘ 结尾。<br>// 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。</p>
<p>var simplifyPath = function(path) {<br>    const names = path.split(“/“);<br>    const stack = [];<br>    for (const name of names) {<br>        if (name === “..”) {<br>            if (stack.length) {<br>                stack.pop();<br>            }<br>        } else if (name.length &amp;&amp; name !== “.”) {<br>            stack.push(name);</p>
<pre><code>    &#125;
&#125;

return &quot;/&quot; + stack.join(&quot;/&quot;);
</code></pre>
<p>};</p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>747. 至少是其他数字两倍的最大数</title>
    <url>/135xyq.github.io/2022/01/13/747.%20%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<h1 id="747-至少是其他数字两倍的最大数-遍历求最大值和次大值"><a href="#747-至少是其他数字两倍的最大数-遍历求最大值和次大值" class="headerlink" title="747. 至少是其他数字两倍的最大数 遍历求最大值和次大值"></a>747. 至少是其他数字两倍的最大数 遍历求最大值和次大值</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/">查看原题</a></h2><p><img src="https://img-blog.csdnimg.cn/e3aa50f29f5a42f69b2657111f38612e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先求出最大值，在求出次大值两者进行比较看是否满足大于等于2倍的关系。</p>
<ol>
<li>先使用Math.max方法求出最大值，用indexOf()求出下标</li>
<li>将数组中的最大值删除</li>
<li>再次使用Math.max()求出最大值，此时是原数组的次大值</li>
<li>再比较两次求出的最大值，判断返回内容</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dominantIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">	<span class="keyword">const</span> index = nums.indexOf(max);</span><br><span class="line">	nums.splice(index,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">const</span> secondMax = <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">	<span class="keyword">if</span>(max &gt;= <span class="number">2</span> * secondMax)&#123;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/f3ac8efa77ec4077962c20bdb4e0d8e2.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>748. 最短补全词</title>
    <url>/135xyq.github.io/2021/12/30/748.%20%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="748-最短补全词-循环遍历每一个单词，比较是否符合"><a href="#748-最短补全词-循环遍历每一个单词，比较是否符合" class="headerlink" title="748. 最短补全词 循环遍历每一个单词，比较是否符合"></a>748. 最短补全词 循环遍历每一个单词，比较是否符合</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/shortest-completing-word/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用了map集合来判断</p>
<ol>
<li>先将licensePlate的大写字母转为小写字母，再统计里面每一个小写单词的个数</li>
<li>遍历words分别对每一个元素做出判断，该元素是否是补全词，该元素是补全词的话是否比前面的补全词更短</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">licensePlate</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">words</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> shortestCompletingWord = <span class="function"><span class="keyword">function</span>(<span class="params">licensePlate, words</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将字符串全转为小写字母</span></span><br><span class="line">	<span class="keyword">const</span> temp = licensePlate.toLowerCase();</span><br><span class="line">	<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();<span class="comment">//统计各个单词的个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> temp)&#123;</span><br><span class="line">		<span class="comment">// 将小写字母过滤</span></span><br><span class="line">		<span class="keyword">if</span>(item&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; item&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(map.has(item))&#123;</span><br><span class="line">				map.set(item,map.get(item) + <span class="number">1</span>)</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				map.set(item,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> index = <span class="literal">null</span>;<span class="comment">//最短词的下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt;words.length;i++)&#123;</span><br><span class="line">		<span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="built_in">Map</span>(map);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> word <span class="keyword">of</span> words[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.has(word))&#123;</span><br><span class="line">				temp.set(word,temp.get(word) - <span class="number">1</span> );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">let</span> flag = <span class="literal">true</span>;<span class="comment">//为true说明该单词是补全词</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> [key,value] <span class="keyword">of</span> temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(value &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进入此if说明是补全词，接下来判断是否要更新最短的补全词</span></span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			<span class="keyword">if</span>(index===<span class="literal">null</span> || words[i].length &lt; words[index].length)&#123;</span><br><span class="line">				index = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> words[index];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>771. 宝石与石头</title>
    <url>/135xyq.github.io/2022/01/17/771.%20%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="771-宝石与石头-遍历一遍求解"><a href="#771-宝石与石头-遍历一遍求解" class="headerlink" title="771. 宝石与石头 遍历一遍求解"></a>771. 宝石与石头 遍历一遍求解</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/jewels-and-stones/">查看原题</a></h2><p><img src="https://img-blog.csdnimg.cn/f0906751799f498dad87fac7c75dbc33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历一遍stones，判断是否是宝石。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">jewels</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">stones</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">jewels, stones</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> sum =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt;stones.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(jewels.indexOf(stones[i]) != -<span class="number">1</span>)&#123;</span><br><span class="line">			sum++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/74bfbe4173244470b151a8e069e4c930.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>794. 有效的井字游戏</title>
    <url>/135xyq.github.io/2021/12/30/794.%20%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="794-有效的井字游戏-找出判断条件"><a href="#794-有效的井字游戏-找出判断条件" class="headerlink" title="794. 有效的井字游戏  找出判断条件"></a>794. 有效的井字游戏  找出判断条件</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="棋盘可能达到的状态是："><a href="#棋盘可能达到的状态是：" class="headerlink" title="棋盘可能达到的状态是："></a>棋盘可能达到的状态是：</h3><ol>
<li>玩家一下的 ‘X’个数 等于玩家二下的 ‘’O’ 的个数或 ‘O’的个数加一</li>
<li>只能有一个玩家赢</li>
<li>当玩家一赢的时候，棋局上 ‘X’的个数等于’O’的个数加一</li>
<li>当玩家二赢的时候，棋局上’O’的个数等于’X’的个数</li>
</ol>
<h3 id="关键步骤："><a href="#关键步骤：" class="headerlink" title="关键步骤："></a>关键步骤：</h3><ol>
<li>求出棋盘上’X’和’O’的个数</li>
<li>判断是否符合条件一</li>
<li>若符合条件一继续执行，不符合则直接<code>return false</code></li>
<li>接下来判断是否有玩家获胜</li>
<li>当两个玩家都获胜则不符合条件</li>
<li>当只有玩家一获胜，判断棋局上 ‘X’的个数是否等于’O’的个数加一</li>
<li>当只有玩家二获胜，判断棋局上’O’的个数是否等于’X’的个数</li>
</ol>
<h3 id="玩家获胜的情况"><a href="#玩家获胜的情况" class="headerlink" title="玩家获胜的情况"></a>玩家获胜的情况</h3><ol>
<li>水平的三个字符都一样： <code>board[i][0] === board[i][1] &amp;&amp; board[i][1] === board[i][2]</code></li>
<li>垂直的三个字符都一样：<code>board[0][i] === board[1][i] &amp;&amp; board[1][i] === board[2][i]</code></li>
<li>正对角线的三个字符一样：<code>board[0][0] === board[1][1] &amp;&amp; board[1][1]=== board[2][2]</code></li>
<li>反对角线的三个字符都一样:<code>board[0][2] === board[1][1] &amp;&amp; board[1][1]=== board[2][0] </code></li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">board</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validTicTacToe = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> XNumber = <span class="number">0</span>;<span class="comment">//X的个数</span></span><br><span class="line">	<span class="keyword">let</span> ONumber = <span class="number">0</span>;<span class="comment">//O的个数</span></span><br><span class="line">	<span class="keyword">let</span> player1Win = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">let</span> player2Win = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计X和O的个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(board[i].charAt(j) === <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">				XNumber++;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i].charAt(j) === <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">				ONumber++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(XNumber === ONumber+<span class="number">1</span> || XNumber === ONumber)&#123;</span><br><span class="line">		<span class="comment">// 判读是否有玩家获胜</span></span><br><span class="line">		<span class="comment">//判断一行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(board[i][<span class="number">0</span>] === board[i][<span class="number">1</span>] &amp;&amp; board[i][<span class="number">1</span>] === board[i][<span class="number">2</span>])&#123;</span><br><span class="line">				<span class="keyword">if</span>(board[i][<span class="number">0</span>] === <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">					player1Win = <span class="literal">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][<span class="number">0</span>] === <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">					player2Win = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断一列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(board[<span class="number">0</span>][i] === board[<span class="number">1</span>][i] &amp;&amp; board[<span class="number">1</span>][i] === board[<span class="number">2</span>][i])&#123;</span><br><span class="line">				<span class="keyword">if</span>(board[<span class="number">0</span>][i] === <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">					player1Win = <span class="literal">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[<span class="number">0</span>][i] === <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">					player2Win = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断对角线</span></span><br><span class="line">		<span class="keyword">if</span>(board[<span class="number">0</span>][<span class="number">0</span>] === board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>]=== board[<span class="number">2</span>][<span class="number">2</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(board[<span class="number">0</span>][<span class="number">0</span>] === <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">				player1Win = <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[<span class="number">0</span>][<span class="number">0</span>] === <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">				player2Win = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(board[<span class="number">0</span>][<span class="number">2</span>] === board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>]=== board[<span class="number">2</span>][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(board[<span class="number">0</span>][<span class="number">2</span>] === <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">				player1Win = <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[<span class="number">0</span>][<span class="number">2</span>] === <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">				player2Win = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 玩家一玩家二都赢</span></span><br><span class="line">		<span class="keyword">if</span>(player1Win &amp;&amp; player2Win)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 玩家一赢，玩家二不赢</span></span><br><span class="line">		<span class="keyword">if</span>(player1Win &amp;&amp; !player2Win)&#123;</span><br><span class="line">			<span class="keyword">if</span>(XNumber === ONumber + <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 玩家二赢，玩家一不赢</span></span><br><span class="line">		<span class="keyword">if</span>(!player1Win &amp;&amp; player2Win)&#123;</span><br><span class="line">			<span class="keyword">if</span>(XNumber === ONumber)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 都不赢</span></span><br><span class="line">		<span class="keyword">if</span>(!player1Win &amp;&amp; !player2Win)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间结点</title>
    <url>/135xyq.github.io/2021/12/30/876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="876-链表的中间结点-先找到链表的长度，再返回对应一半的值"><a href="#876-链表的中间结点-先找到链表的长度，再返回对应一半的值" class="headerlink" title="876. 链表的中间结点 先找到链表的长度，再返回对应一半的值"></a>876. 链表的中间结点 先找到链表的长度，再返回对应一半的值</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>遍历列表进行链表长度的统计</li>
<li>返回链表的一半长度后面的数据</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> middleNode = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">//链表的长度</span></span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> n = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = count % <span class="number">2</span> ? <span class="built_in">Math</span>.floor(count / <span class="number">2</span>) : <span class="built_in">Math</span>.ceil(count / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (mid--) &#123;</span><br><span class="line">        n = n.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>859. 亲密字符串</title>
    <url>/135xyq.github.io/2021/12/30/859.%20%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="859-亲密字符串-遍历比较"><a href="#859-亲密字符串-遍历比较" class="headerlink" title="859. 亲密字符串 遍历比较"></a>859. 亲密字符串 遍历比较</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/buddy-strings/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>先判断两个字符串长度是否相等或者长度都为1，如果不相等或者长度为1，则肯定不满足，直接返回false</li>
<li>遍历字符串求出每一项的差值存到数组temp中</li>
<li>先判断一下交换的数据是否相等</li>
<li>过滤出temp中值为0的项</li>
<li>判断比较temp的长度<ul>
<li>temp的长度为2，则比较temp[0] + temp[1] === 0</li>
<li>temp的长度为0，则判断字符串的长度是否为一串一样的数字，且长度大于1</li>
<li>以上情况返回true</li>
</ul>
</li>
<li>其他情况返回false<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">goal</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> buddyStrings = <span class="function"><span class="keyword">function</span>(<span class="params">s, goal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个字符串长度不相等或者其中一个长度为1，则肯定不是亲密字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.length !== goal.length || s.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = []; <span class="comment">//用来存放两个字符串的每一项的差值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        temp.push(s.charCodeAt(i) - goal.charCodeAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> a = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp[i] !== <span class="number">0</span> &amp;&amp; a === -<span class="number">1</span>) &#123;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] !== <span class="number">0</span> &amp;&amp; a !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (goal.charAt(a) !== s.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = temp.filter(<span class="function"><span class="params">item</span> =&gt;</span> item);</span><br><span class="line">    <span class="keyword">if</span> (((temp.length === <span class="number">2</span>) &amp;&amp; (temp[<span class="number">0</span>] + temp[<span class="number">1</span>] === <span class="number">0</span>)) || (temp.length === <span class="number">0</span> &amp;&amp; ((<span class="keyword">new</span> <span class="built_in">Set</span>(s.split(<span class="string">&#x27;&#x27;</span>)).size === <span class="number">1</span>) || (<span class="keyword">new</span> <span class="built_in">Set</span>(s.split(<span class="string">&#x27;&#x27;</span>)).size !== s.length)))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>88. 合并两个有序数组</title>
    <url>/135xyq.github.io/2021/12/30/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="88-合并两个有序数组-循环替换后排序"><a href="#88-合并两个有序数组-循环替换后排序" class="headerlink" title="88. 合并两个有序数组 循环替换后排序"></a>88. 合并两个有序数组 循环替换后排序</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>注意不能改变num1的长度，不能能用pop<br>将nums2先插入到nums1的末尾，再用sort排序</p>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">原题</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = m; i &lt; m + n; i++) &#123;</span><br><span class="line">        nums1[i] = nums2[i - m]</span><br><span class="line">    &#125;</span><br><span class="line">    nums1 = nums1.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b &#125;);</span><br><span class="line">    <span class="comment">// console.log(nums1)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BOMdemo1</title>
    <url>/135xyq.github.io/2021/12/31/BOMdemo1/</url>
    <content><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><hr>
<p>BOM是browser object model的缩写，简称浏览器对象模型</p>
<p>主要处理浏览器窗口（window）和框架（iframe），<br>描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。扩展如下：</p>
<ol>
<li>弹出新的浏览器窗口</li>
</ol>
<ol start="2">
<li><p>移动、关闭浏览器窗口以及调整窗口大小</p>
</li>
<li><p>提供 Web 浏览器详细信息的定位对象</p>
</li>
<li><p>提供用户屏幕分辨率详细信息的屏幕对象</p>
</li>
</ol>
<ol start="5">
<li>对 cookie 的支持</li>
</ol>
<ol start="6">
<li>IE 扩展了BOM，加入了ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象</li>
</ol>
<h3 id="归纳："><a href="#归纳：" class="headerlink" title="归纳："></a>归纳：</h3><p>Window JavaScript 层级中的顶层对象表示浏览器窗口</p>
<p>包含客户端浏览器的信息</p>
<p>History 包含了浏览器窗口访问过的 URL</p>
<p>Location 包含了当前 URL 的信息</p>
<p>Screen 包含客户端显示屏的信息</p>
<p><a href="https://duyiedu.yuque.com/docs/share/17c3a868-d15a-448f-ad3c-93a7cb554f4f#qvTfj">BOM.pdf</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>BOM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>bom</tag>
      </tags>
  </entry>
  <entry>
    <title>997. 找到小镇的法官</title>
    <url>/135xyq.github.io/2021/12/30/997.%20%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98/</url>
    <content><![CDATA[<h1 id="997-找到小镇的法官-图的入度出度和普通方法运算"><a href="#997-找到小镇的法官-图的入度出度和普通方法运算" class="headerlink" title="997. 找到小镇的法官 图的入度出度和普通方法运算"></a>997. 找到小镇的法官 图的入度出度和普通方法运算</h1><h2 id="查看原题"><a href="#查看原题" class="headerlink" title="查看原题"></a><a href="https://leetcode-cn.com/problems/find-the-town-judge/">查看原题</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种方法是先判断哪些可能是法官（不相信任何人），再判断这些可能法官中是否存在除自己外所有人都相信的真正法官。</p>
<ol>
<li>利用map集合筛选出可能是法官的那些人</li>
<li>遍历这些可能是法官的的那批人，在判断他们是否有n-1个人相信，如果有说明他是真正的法官</li>
<li>循环完毕返回-1，说明此时没有真正的法官</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">trust</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findJudge = <span class="function"><span class="keyword">function</span>(<span class="params">n, trust</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		map.set(i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;trust.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.has(trust[i][<span class="number">0</span>]))&#123;</span><br><span class="line">			map.delete(trust[i][<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(map.size === <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">			<span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">			trust.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(item[<span class="number">1</span>] === key)&#123;</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="built_in">console</span>.log(count)</span><br><span class="line">			<span class="keyword">if</span>(count === n-<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> key;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用图论里面的出度和入度</p>
<ol>
<li>循环trust 将每个人相信的个人的入度加一，自己的出度加一</li>
<li>循环判断一个人的出度=0，且入度=n-1，则这个人就是法官</li>
<li>返回-1，说明没有法官</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">trust</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findJudge = <span class="function"><span class="keyword">function</span>(<span class="params">n, trust</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> input = <span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">let</span> output= <span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;trust.length;i++)&#123;</span><br><span class="line">		input[trust[i][<span class="number">1</span>]]++;</span><br><span class="line">		output[trust[i][<span class="number">0</span>]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(input[i] === n-<span class="number">1</span> &amp;&amp; output[i] === <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS</title>
    <url>/135xyq.github.io/2021/12/31/CommonJS/</url>
    <content><![CDATA[<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><blockquote>
<p>标准类型：社区规范</p>
<p>支持环境：node</p>
<p>依赖类型：动态依赖</p>
</blockquote>
<h2 id="如何导出"><a href="#如何导出" class="headerlink" title="如何导出"></a>如何导出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = 导出的值</span><br></pre></td></tr></table></figure>

<h2 id="如何导入"><a href="#如何导入" class="headerlink" title="如何导入"></a>如何导入</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;模块路径&quot;</span>) <span class="comment">// 函数返回模块导出的值</span></span><br></pre></td></tr></table></figure>

<h1 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h1><blockquote>
<p>标准类型：官方标准</p>
<p>支持环境：node，浏览器</p>
<p>依赖类型：静态依赖，动态依赖</p>
</blockquote>
<h2 id="如何导出-1"><a href="#如何导出-1" class="headerlink" title="如何导出"></a>如何导出</h2><p><strong>ES Module</strong>的导出</p>
<p>ES Module分为两种导出方式：</p>
<ul>
<li>具名导出（普通导出），可以导出多个</li>
<li>默认导出，只能导出一个</li>
</ul>
<p>一个模块可以同时存在两种导出方式，最终会合并为一个「对象」导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">// 具名，常用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 具名，常用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="function">() =&gt;</span> &#123;&#125;  <span class="comment">// 具名，常用</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; d &#125; <span class="comment">// 具名</span></span><br><span class="line"><span class="keyword">const</span> k = <span class="number">10</span></span><br><span class="line"><span class="keyword">export</span> &#123; k <span class="keyword">as</span> temp &#125; <span class="comment">// 具名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export default 3 // 默认，常用</span></span><br><span class="line"><span class="comment">// export default function() &#123;&#125; // 默认，常用</span></span><br><span class="line"><span class="comment">// const e = 4;</span></span><br><span class="line"><span class="comment">// export &#123; e as default &#125; // 默认</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="number">4</span>, g = <span class="number">5</span>, h = <span class="number">6</span></span><br><span class="line"><span class="keyword">export</span> &#123; f, g, h <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="comment">// 基本 + 默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码将导出下面的对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	a: 1,</span></span><br><span class="line"><span class="comment">	b: fn,</span></span><br><span class="line"><span class="comment">	c: fn,</span></span><br><span class="line"><span class="comment">	d: 2,</span></span><br><span class="line"><span class="comment">	temp: 10,</span></span><br><span class="line"><span class="comment">	f: 4,</span></span><br><span class="line"><span class="comment">	g: 5,</span></span><br><span class="line"><span class="comment">	default: 6</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：导出代码必须为顶级代码，即不可放到代码块中</strong></p>
<h2 id="如何导入-1"><a href="#如何导入-1" class="headerlink" title="如何导入"></a>如何导入</h2><p>针对具名导出和默认导出，有不同的导入语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅运行一次该模块，不导入任何内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;模块路径&quot;</span></span><br><span class="line"><span class="comment">// 常用，导入属性 a、b，放到变量a、b中。a-&gt;a, b-&gt;b</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span>   </span><br><span class="line"><span class="comment">// 常用，导入属性 default，放入变量c中。default-&gt;c</span></span><br><span class="line"><span class="keyword">import</span> c <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span>  </span><br><span class="line"><span class="comment">// 常用，default-&gt;c，a-&gt;a, b-&gt;b</span></span><br><span class="line"><span class="keyword">import</span> c, &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">// 常用，将模块对象放入到变量obj中</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入属性a、b，放到变量temp1、temp2 中</span></span><br><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> temp1, b <span class="keyword">as</span> temp2&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">// 导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> a&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">//导入属性default、b，放入变量a、b中</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> a, b&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">// 以上均为静态导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;模块路径&quot;</span>) <span class="comment">// 动态导入，返回一个Promise，完成时的数据为模块对象</span></span><br><span class="line">	/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的面向对象和面向过程的比较</title>
    <url>/135xyq.github.io/2022/01/20/ES6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>面向过程</strong>                                                                                                                                                                                                                                                                                                                </p>
<p><img src="/images/ES6Images/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.jpg" alt="image-20210928104401662"></p>
<blockquote>
<p><strong>面向过程，就是按照我们分析好了的步骤，按部就班的依次执行就行了！</strong>所以当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举</p>
</blockquote>
<p><strong>面向对象</strong></p>
<p>实现步骤：</p>
<ol>
<li>分析哪些动作是由哪些实体发出的；（学生提出报名，学生缴费，机构收费，教师分配教室，班级增加学生信息）</li>
<li>定义这些实体，为其增加相应的属性和功能；（学生、机构、教师、班级）</li>
<li>让实体去执行相应的功能或动作。（学生提出报名、学生缴费、学校收费、教师分配教室、班级增加学生信息）</li>
</ol>
<p>​<img src="/images/ES6Images/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.jpg" alt="img"></p>
<h4 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h4><blockquote>
<p><strong>面向过程主要是针对功能，而面向对象主要是针对能够实现该功能的背后的实体。</strong>面向对象实质上就是面向实体，所以当我们使用面向对象进行编程时，一定要建立这样一个观念：万物皆对象！</p>
</blockquote>
<ul>
<li>都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！</li>
<li>面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑</li>
<li>从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！</li>
<li>简单的从运行速度讲，面向对象与面向过程的运行速度区别不大，基本上面向对象的耗时操作在创建实例化对象的过程当中；</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux期末知识点总结</title>
    <url>/135xyq.github.io/2021/12/30/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Linux知识点总结"><a href="#Linux知识点总结" class="headerlink" title="Linux知识点总结"></a>Linux知识点总结</h1><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><h3 id="Linux系统的优缺点"><a href="#Linux系统的优缺点" class="headerlink" title="Linux系统的优缺点"></a>Linux系统的优缺点</h3><ol>
<li>优点：Linux系统主打网络服务，专业性强，免费开源，主要用于搭建服务器，性能稳定，长时间开机不出现卡顿，漏洞少，更安全；</li>
<li>缺点：Linux式子专业系统，对业余人员不友好，操作难度较高。</li>
</ol>
<h3 id="Linux系统的特点"><a href="#Linux系统的特点" class="headerlink" title="Linux系统的特点"></a>Linux系统的特点</h3><ol>
<li>一切皆文件</li>
<li>完全兼容可移植操作系统接口POSIX1.0标准</li>
<li>多用户、多任务</li>
<li>完全免费</li>
</ol>
<h3 id="Linux的含义"><a href="#Linux的含义" class="headerlink" title="Linux的含义"></a>Linux的含义</h3><p>Linux是指在GPL协议下发行的遵循可移植性操作系统POSIX标准的操作系统内核。<br>通常说的Linux是指基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。<br>Linux是类UNIX操作系统。</p>
<h3 id="Linux的诞生、发展和成长过程依赖五个重要支柱"><a href="#Linux的诞生、发展和成长过程依赖五个重要支柱" class="headerlink" title="Linux的诞生、发展和成长过程依赖五个重要支柱"></a>Linux的诞生、发展和成长过程依赖五个重要支柱</h3><ol>
<li>UXIX操作系统</li>
<li>MINIX操作系统</li>
<li>GNU计划</li>
<li>POSIX标准</li>
<li>Internet</li>
</ol>
<h3 id="Linux内核的组成"><a href="#Linux内核的组成" class="headerlink" title="Linux内核的组成"></a>Linux内核的组成</h3><ol>
<li>内存管理器：对内存资源的访问控制。</li>
<li>进程管理器：对CPU的访问控制。</li>
<li>设备驱动程序：实际控制操作系统和硬件设备之间的交互，并且提供一组操作系统可理解的抽象接口，完成和操作系统之间的交互，与硬件相关的具体操作细节也由设备驱动程序完成。</li>
<li>虚拟文件系统：VFS隐藏各种文件系统的具体细节，为文件系统提供统一的接口。</li>
<li>网络管理：管理各种网络设备，并实现各种网络协议栈，最终通过网络连接其他系统。</li>
</ol>
<h3 id="shell-分为"><a href="#shell-分为" class="headerlink" title="shell 分为"></a>shell 分为</h3><ol>
<li>GLI命令行界面</li>
<li>GUI图用户界面</li>
</ol>
<h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p>Linux一切皆文件；<br>文件系统是指文件存放在磁盘等存储设备上的组织方法。</p>
<h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><strong>命令格式</strong>： command [options] [arguments]  ，命令名：[选项]：[参数]</p>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man [option] filename</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--help |more</span><br></pre></td></tr></table></figure>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>Linux 日志文件存放在 /var/log目录下</p>
<p>日志记录了程序的运行状态，包括各种错误信息、警告信息和其他的提示信息。</p>
<h2 id="文件系统和文件管理"><a href="#文件系统和文件管理" class="headerlink" title="文件系统和文件管理"></a>文件系统和文件管理</h2><h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h3><ol>
<li>普通文件</li>
<li>目录文件</li>
<li>链接文件</li>
<li>设备文件</li>
<li>管道文件</li>
</ol>
<h4 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h4><ul>
<li>普通文件是指以<strong>字节</strong>为单位的<strong>数据流</strong>类型文件，其特点是不包含文件系统的结构信息。</li>
<li>通常用户接触到的文件，如图形文件、数据文件、文档文件、声音文件等都属于普通文件。</li>
<li>按其内部结构分为文本文件和二进制文件。</li>
</ul>
<h4 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h4><ul>
<li>目录文件不存放常规数据，它是用来<strong>组织</strong>、<strong>访问</strong>其他文件的，是内核组织文件系统的基本节点。</li>
<li>目录文件可以包含下一级目录文件或普通文件。</li>
<li>目录文件是一种文件，是Linux文件中的一种</li>
</ul>
<h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><ul>
<li>链接文件是一种特殊的文件，是指向一个真实存在的文件链接(类似于Windows的快捷方式)。</li>
<li>根据链接文件的不同，分为<strong>硬链接</strong>（Hard Link）文件和<strong>符号链接</strong>（Symbolic Link，又称为软链接）文件</li>
</ul>
<h4 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h4><ul>
<li>设备文件是Linux中最特殊的文件，可以方便地访问外部设备。</li>
<li>Linux为外部设备提供一种标准接口，将外部设备视为一种特殊的文件。用户可以像访问普通文件一样访问任何外部设备，使Linux系统可以很方便地适应不断变化的外部设备。</li>
<li>设备文件放在/dev目录下，设备文件使用设备的主设备号和次设备号来指定某外部设备。</li>
<li>根据访问数据方式的不同，设备文件分为：块设备和字符设备文件。</li>
</ul>
<h4 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h4><ul>
<li>管道文件是一种很特殊的文件，主要用于不同进程的信息传递。</li>
<li>当两个进程间需要传递数据或信息时，可以使用管道文件。一个进程将需传递的数据或信息写入管道的一端，另一进程则从管道另一端取得所需的数据或信息。</li>
</ul>
<h3 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file [option] filename</span><br></pre></td></tr></table></figure>

<h3 id="查看文件的详细属性"><a href="#查看文件的详细属性" class="headerlink" title="查看文件的详细属性"></a>查看文件的详细属性</h3><p>使用stat命令，例如，文件的名称、大小、权限、atime、ctime、mtime等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">state [option] filename</span><br></pre></td></tr></table></figure>


<h3 id="显示当前工作目录"><a href="#显示当前工作目录" class="headerlink" title="显示当前工作目录"></a>显示当前工作目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li>绝对路径是以根目录“/”开始，递归每级目录直到目标路径。</li>
<li>相对路径是以当前目录为起点，到达目标的路径。</li>
</ul>
<h3 id="显示目录下的文件结构"><a href="#显示目录下的文件结构" class="headerlink" title="显示目录下的文件结构"></a>显示目录下的文件结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree filename</span><br></pre></td></tr></table></figure>
<h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [directory]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>- ```表示返回到上次目录。</span></figcaption><table><tr><td class="code"><pre><span class="line">```cd ..```表示返回到上一级目录</span><br><span class="line"></span><br><span class="line">### ls命令</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">ls [option] [names]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>显示所有隐藏文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure></li>
<li>显示所有以a开头的文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls a*</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录的创建和删除"><a href="#目录的创建和删除" class="headerlink" title="目录的创建和删除"></a>目录的创建和删除</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [option] [dirname]</span><br></pre></td></tr></table></figure>
<p>dirname : 目录名称<br>参数：-p :创建多层目录，-v：显示创建过程信息</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>rmdir命令只能用来删除空目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [option] [dirname]</span><br></pre></td></tr></table></figure>
<p>dirname : 目录名称</p>
<h3 id="文件的创建、查看、复制、移动、删除、排序"><a href="#文件的创建、查看、复制、移动、删除、排序" class="headerlink" title="文件的创建、查看、复制、移动、删除、排序"></a>文件的创建、查看、复制、移动、删除、排序</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch [option] filename</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [option] filename</span><br></pre></td></tr></table></figure>
<ul>
<li>用来显示文件内容， 依次读取其后所指文件的内容并将其输出到标准输出设备上。</li>
<li>能够用来连接两个或者多个文件，形成新文件。</li>
</ul>
<p>more命令以逐页的方式显示文件的内容.<br>less命令也是对文件或其他输出进行分页显示。<br>head命令可以查看文件的前几行的内容。<br>tail命令查看文件的后几行的内容</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [option] source  dest</span><br></pre></td></tr></table></figure>
<p>source表示需要复制的文件，dest 表示需要复制到的目录。</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [option] source dest</span><br></pre></td></tr></table></figure>
<p>为文件或目录改名或者将文件由一个目录移动到另一个目录中</p>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [option] filename</span><br></pre></td></tr></table></figure>
<ul>
<li>删除一个目录中的一个或者多个文件。</li>
<li>将某个目录及其下的所有文件及子目录均删除。</li>
<li>对于链接文件，只是删除了链接，原有文件均保持不变</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>对文件中的各行进行排序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort [option] filename</span><br></pre></td></tr></table></figure>

<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p>以指定的查找模式搜索文件，通知用户在什么文件中搜索到与指定模式匹配的字符串，并且打印出所有包含该字符的文本行，该文本行的最前面是该行所在的文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]</span><br></pre></td></tr></table></figure>


<p>find:从指定的目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对其采取相关的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [pathname] [option] filename</span><br></pre></td></tr></table></figure>


<h3 id="linux-文件链接"><a href="#linux-文件链接" class="headerlink" title="linux 文件链接"></a>linux 文件链接</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul>
<li>默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。</li>
<li>创建一个硬链接时，也为这个文件创建了一个额外的目录条目。</li>
</ul>
<h5 id="硬链接的局限性"><a href="#硬链接的局限性" class="headerlink" title="硬链接的局限性"></a>硬链接的局限性</h5><p>（1）硬链接不能引用自身文件系统之外的文件，即不能引用不在同一磁盘分区的文件。<br>（2）硬链接无法引用目录。</p>
<p>当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在，除非该文件的所有链接都被删除了</p>
<h4 id="符号链接（软链接）"><a href="#符号链接（软链接）" class="headerlink" title="符号链接（软链接）"></a>符号链接（软链接）</h4><p>符号链接指向的文件与符号链接自身几乎没有区别。</p>
<h3 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h3><p>在Linux系统中，文件是没有创建时间的，如果新创建一个文件，它的三个时间都是与创建的时间相同。</p>
<h4 id="1-访问时间（Access-time）"><a href="#1-访问时间（Access-time）" class="headerlink" title="1.访问时间（Access time）"></a>1.访问时间（Access time）</h4><p>对文件内容进行一次读操作时间。</p>
<h4 id="2-修改时间（Change-time）"><a href="#2-修改时间（Change-time）" class="headerlink" title="2.修改时间（Change time）"></a>2.修改时间（Change time）</h4><p>文件内容被最后一次修改的时间。</p>
<p>ls -l 命令显示出来的文件时间就是这个时间</p>
<h4 id="3-状态时间（Modify-time）"><a href="#3-状态时间（Modify-time）" class="headerlink" title="3.状态时间（Modify time）"></a>3.状态时间（Modify time）</h4><p>当文件的状态被改变时，状态时间就会改变</p>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><p>超级用户可以对普通用户进行跟踪，并限制它们的访问权限，以保证系统安全。</p>
<p>Linux系统并不能识别用户账号名称信息，所以每个用户都有一个唯一的系统可识别的UID</p>
<p>id命令可以查看当前用户登录信息。</p>
<ul>
<li>UID(User Identification)为用户的ID。</li>
<li>GID(Group Identification)为用户所属组的ID。</li>
<li>groups为用户属于的所有组的ID。</li>
</ul>
<p>ps aux | less命令查看进程</p>
<h3 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h3><ol>
<li>root用户：拥有最高权限，ID为0。</li>
<li>普通用户：可以登录，由管理员创建，使用权限有限。</li>
<li>系统用户：不具有登录的能力，但是系统运行不可或缺的。</li>
</ol>
<h3 id="管理用户组"><a href="#管理用户组" class="headerlink" title="管理用户组"></a>管理用户组</h3><ul>
<li>useradd用来添加用户。</li>
<li>passwd修改用户口令。</li>
<li>usermod修改用户信息。</li>
<li>userdel删除用户。</li>
</ul>
<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>添加用户就是在系统中创建一个新账号，并为新账号分配用户ID、用户组、主目录和登录Shell等资源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd [option] username</span><br></pre></td></tr></table></figure>
<p>username表示新账号的登录名</p>
<h4 id="修改用户口令"><a href="#修改用户口令" class="headerlink" title="修改用户口令"></a>修改用户口令</h4><p>用户账号刚创建时没有口令，无法使用，必须为其指定口令后才可以使用，即使是空口令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd [option] [username]</span><br></pre></td></tr></table></figure>

<ul>
<li>username参数没有指定时，表示修改当前用户的口令。</li>
<li>如果指定了该参数，则表示修改指定用户的口令，只有root用户才有修改指定用户口令的权限</li>
</ul>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>删除用户就是删除与用户有关的系统配置文件中的记录（如/etc/passwd）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel [option] username</span><br></pre></td></tr></table></figure>

<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><p>修改用户信息就是更改用户的属性，如用户 ID、主目录、用户所在组、登录Shell等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod [option] username</span><br></pre></td></tr></table></figure>

<p>gpasswd命令–从用户组中移出一个用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpasswd [-a user][-d user][-A user,...][-M user,...][-r][-R]groupname</span><br></pre></td></tr></table></figure>



<h3 id="管理用户组-1"><a href="#管理用户组-1" class="headerlink" title="管理用户组"></a>管理用户组</h3><p>用户组是具有相同特征用户的集合，每个用户都有一个用户组，方便系统集中管理一个用户组中的所有用户</p>
<h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd [option] group_name</span><br></pre></td></tr></table></figure>


<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupdel group_name</span><br></pre></td></tr></table></figure>

<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmod [option] group_name</span><br></pre></td></tr></table></figure>

<h4 id="查看用户的分组"><a href="#查看用户的分组" class="headerlink" title="查看用户的分组"></a>查看用户的分组</h4><ol>
<li>groups命令查看。命令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groups</span><br><span class="line">groups user1 user2</span><br></pre></td></tr></table></figure></li>
<li>查看文件/etc/group法，通过grep命令查询某个用户所在的用户组。</li>
<li>id命令法，只执行id命令就可以查看。命令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">id user2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="和用户相关的一些系统文件"><a href="#和用户相关的一些系统文件" class="headerlink" title="和用户相关的一些系统文件"></a>和用户相关的一些系统文件</h3><ol>
<li>/etc/passwd文件保存用户信息。</li>
<li>/etc/shadow文件保存加密的用户密码。</li>
<li>/etc/group文件保存用户组信息。</li>
<li>/etc/login.defs配置文件。</li>
</ol>
<p><strong>su root</strong>可以返回root </p>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>权限的意义在于允许某一个用户或某个用户组以规定的方式去访问某个文件。</p>
<h3 id="U-G-O"><a href="#U-G-O" class="headerlink" title="U G O"></a>U G O</h3><p>U: owner为属主，文件所有者。<br>G：group为属组，同组用户。<br>O：other为其他用户。</p>
<h3 id="UGO方式每组的3个字符具体意义如下："><a href="#UGO方式每组的3个字符具体意义如下：" class="headerlink" title="UGO方式每组的3个字符具体意义如下："></a>UGO方式每组的3个字符具体意义如下：</h3><p>r:read，数字设定值为4<br>w:write,数字设定值为2<br>x:execute,数字设定值为1</p>
<h3 id="设置文件属性和权限"><a href="#设置文件属性和权限" class="headerlink" title="设置文件属性和权限"></a>设置文件属性和权限</h3><h4 id="改变文件所属用户命令chown"><a href="#改变文件所属用户命令chown" class="headerlink" title="改变文件所属用户命令chown"></a>改变文件所属用户命令chown</h4><p>文件所有者修改为指定的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">option</th>
<th align="center">explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="center">显示更改的部分的信息</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">忽略错误信息</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">修复符号链接</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示详细的处理信息</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">处理指定目录以及其子目录下的所有文件</td>
</tr>
<tr>
<td align="center">–help</td>
<td align="center">显示辅助说明</td>
</tr>
<tr>
<td align="center">–version</td>
<td align="center">显示版本</td>
</tr>
</tbody></table>
<h4 id="改变文件所在组命令chgrp"><a href="#改变文件所在组命令chgrp" class="headerlink" title="改变文件所在组命令chgrp"></a>改变文件所在组命令chgrp</h4><p>变更目录和文件的所属组，只有超级用户才拥有此权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chgrp [option] group file</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">option</th>
<th align="center">explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c或–changes</td>
<td align="center">效果类似”-v”参数，但仅回报更改部分。</td>
</tr>
<tr>
<td align="center">-f或–quiet或–silent</td>
<td align="center">不显示错误信息。</td>
</tr>
<tr>
<td align="center">-h或–no-dereference</td>
<td align="center">只对符号连接的文件作修改，而不更动其他任何相关文件。</td>
</tr>
<tr>
<td align="center">-R或–recursive</td>
<td align="center">递归处理，将指定目录下的所有文件及子目录一并处理。</td>
</tr>
<tr>
<td align="center">-v或–verbose</td>
<td align="center">显示指令执行过程。</td>
</tr>
<tr>
<td align="center">–reference=&amp;lt</td>
<td align="center">参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</td>
</tr>
</tbody></table>
<h4 id="修改文件或目录的权限chmod"><a href="#修改文件或目录的权限chmod" class="headerlink" title="修改文件或目录的权限chmod"></a>修改文件或目录的权限chmod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure>
<p>u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。<br>+表示增加权限、-表示取消权限、=表示唯一设定权限。<br>r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</p>
<h5 id="修改文件权限的方法有2种"><a href="#修改文件权限的方法有2种" class="headerlink" title="修改文件权限的方法有2种"></a>修改文件权限的方法有2种</h5><ol>
<li>符号法（表达式法）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [who] [operator] [mode] file</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>who指定用户身份，若此参数省略，则表示对所有用户进行操作。</li>
<li>operator表示添加或取消某个权限，取值为“+”或“-”。</li>
<li>mode指定读、写、执行权限，取值为 r、 w、 x 的任意组合。</li>
</ul>
<ol start="2">
<li>数字法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 数字 file</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。"><a href="#存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。" class="headerlink" title="存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。"></a>存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。</h3><h3 id="基础权限ACL"><a href="#基础权限ACL" class="headerlink" title="基础权限ACL"></a>基础权限ACL</h3><p>主要提供传统的UGO的r、w、x权限之外的具体权限设置，对单一用户，单一文件或目录进行权限设置。</p>
<h4 id="getfacl命令"><a href="#getfacl命令" class="headerlink" title="getfacl命令"></a>getfacl命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getfacl [-aceEsRLPtpndvh] file ...</span><br></pre></td></tr></table></figure>

<h4 id="setfacl命令可以设置ACL权限"><a href="#setfacl命令可以设置ACL权限" class="headerlink" title="setfacl命令可以设置ACL权限"></a>setfacl命令可以设置ACL权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setfacl [-bkndRLP] &#123; -m|-M|-x|-X ... &#125; file ...</span><br></pre></td></tr></table></figure>

<h2 id="linux编程基础"><a href="#linux编程基础" class="headerlink" title="linux编程基础"></a>linux编程基础</h2><p>make可以获知所管理项目中源文件的修改情况，根据程序员设定的规则，自动编译被修改过的部分，</p>
<p>make通过makefile文件描述的内容自动维护编译工作。</p>
<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><p>Shell脚本是一个包含一系列命令的文件。<br>Shell自动读取这个文件，并执行这些命令，与直接输入命令行得到结果一样。</p>
<h3 id="用Shell脚本的原因："><a href="#用Shell脚本的原因：" class="headerlink" title="用Shell脚本的原因："></a>用Shell脚本的原因：</h3><ol>
<li>效率高：如果让Shell记住这些命令并自动完成输入将会大大提升效率。 </li>
<li>简单性： 通过Shell高级语言，可以简洁地表达复杂的操作。</li>
<li>可移植性：使用POSIX定义的功能，可以做到脚本无须修改就可在不同系统上执行。</li>
<li>开发容易：可以在短时间内完成一个功能强大又好用的脚本。</li>
</ol>
<h3 id="Shell分类："><a href="#Shell分类：" class="headerlink" title="Shell分类："></a>Shell分类：</h3><ol>
<li>用于用户交互接口的Shell称为交互式Shell。</li>
<li>作为命令解析器的Shell称为非交互式Shell。</li>
</ol>
<h3 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#!/bin/bash"></a><code>#!/bin/bash</code></h3><p>脚本第一行开头的“#!”是一个约定的标记，称为shebang，用来告知操作系统需要用什么解析器来执行此脚本，</p>
<p>Shell的注释以“#”开头，注释的内容不会执行。</p>
<p>给文件helloxiangtian.sh增加可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chomd +x helloxiangtan.sh</span><br></pre></td></tr></table></figure>

<h3 id="Shell变量命名规则："><a href="#Shell变量命名规则：" class="headerlink" title="Shell变量命名规则："></a>Shell变量命名规则：</h3><p>变量名必须由大写字母（A～Z）、小写字母（a～z）、数字（0～9）或下画线构成；变量名的第一个字符不能是数字。 </p>
<h3 id="shell变量分类"><a href="#shell变量分类" class="headerlink" title="shell变量分类"></a>shell变量分类</h3><p>Shell变量分为自定义变量、环境变量、位置变量和预定义变量。</p>
<p>根据工作要求临时定义的变量称为自定义变量。<br>环境变量一般是指用export内置命令导出的变量，用于定义Shell的运行环境，保证Shell命令的正确执行，如$0、$1、$#。<br>从命令行、函数或脚本执行等处传递参数时，$0、$1称为特殊位置变量。<br>预定义变量是在bash（默认Shell）中已有的变量，可以直接使用，如$@、$*等。</p>
<p>Shell变量只有字符串一种类型，即无论给 Shell变量赋予什么值，在存储时都会转换为字符串。</p>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义自定义变量</td>
<td align="center">变量名=变量值，变量名必须以字母和下划线开头，如ipl=192.197.1.1。</td>
</tr>
<tr>
<td align="center">使用自定义变量</td>
<td align="center">$变量名</td>
</tr>
<tr>
<td align="center">查看自定义变量</td>
<td align="center">echo $变量名 set（所有变量：自定义变量和环境变量）</td>
</tr>
<tr>
<td align="center">取消自定义变量</td>
<td align="center">unset 变量名</td>
</tr>
<tr>
<td align="center">自定义变量作用范围</td>
<td align="center">仅在当前shell中有效</td>
</tr>
</tbody></table>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>在各种编程语言中会提及全局变量概念。<br>全局变量可以在程序的任何地方使用。<br>在Shell编程中该功能由环境变量实现。<br>系统中的所有进程都可以使用环境变量。<br>环境变量与全局变量区别：<br>子进程对环境变量的修改不会传递到父进程中。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义环境变量</td>
<td align="center">使用export命令声明。例如，export back_dir=/home/user例如，export ipl 将自定义变量转换为环境变量。</td>
</tr>
<tr>
<td align="center">使用环境变量</td>
<td align="center">$变量名或$｛变量名｝</td>
</tr>
<tr>
<td align="center">查看环境变量</td>
<td align="center">echo $变量名 或env，如env</td>
</tr>
<tr>
<td align="center">取消环境变量</td>
<td align="center">unset 变量名</td>
</tr>
<tr>
<td align="center">环境变量作用范围</td>
<td align="center">仅在当前shell和子shell中有效</td>
</tr>
</tbody></table>
<h4 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h4><p>位置变量用于在命令行、函数或脚本中传递参数，其变量名不用自己定义，其作用也是固定的。<br>执行脚本时，通过在脚本后面给出具体的参数（多个参数用空格隔开）对相应的位置变量进行赋值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">0代表命令本身，<span class="variable">$1</span>-<span class="variable">$9</span>代表接收的第1~9个参数，<span class="variable">$10</span>以上需要用&#123;&#125;括起来，如<span class="variable">$&#123;20&#125;</span>代表接收的第20个参数。</span></span><br></pre></td></tr></table></figure>

<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量在Shell中可以直接使用，位置变量也是预定义变量的一种。</p>
<table>
<thead>
<tr>
<th align="center">预定义变量</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td align="left">脚本名</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="left">所有的参数</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="left">所有的参数</td>
</tr>
<tr>
<td align="center">$#</td>
<td align="left">参数的个数</td>
</tr>
<tr>
<td align="center">$$</td>
<td align="left">当前进程的PID</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="left">上一个后台进程的PID</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="left">上一个命令的返回值，0表示成功。</td>
</tr>
</tbody></table>
<h3 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h3><p>变量创建只需要指定变量名称和变量值，它们之间用等号（=）连接，等号两边不能有空格。</p>
<p>变量创建好后，可以用$变量名的方式获取变量的值。</p>
<p>可以使用$符号获取变量的值。</p>
<p>用户可以通过export命令将Shell变量导出为环境变量，但没有办法将环境变量再恢复成Shell变量。</p>
<h4 id="变量的删除"><a href="#变量的删除" class="headerlink" title="变量的删除"></a>变量的删除</h4><table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${变量名#关键字符}</td>
<td align="center">变量内容从头开始的数据符合“关键字符”，则将符合的最短数据删除。</td>
</tr>
<tr>
<td align="center">${变量名##关键字符}</td>
<td align="center">变量内容从头开始的数据符合“关键字符”，则将符合的最长数据删除。</td>
</tr>
<tr>
<td align="center">${变量名%关键字符}</td>
<td align="center">变量内容从尾开始的数据符合“关键字符”，则将符合的最短数据删除。</td>
</tr>
<tr>
<td align="center">${变量名%%关键字符}</td>
<td align="center">变量内容从尾开始的数据符合“关键字符”，则将符合的最长数据删除。</td>
</tr>
</tbody></table>
<h4 id="变量的替换"><a href="#变量的替换" class="headerlink" title="变量的替换"></a>变量的替换</h4><p>|格式  |说明|<br>|:—:|：—：|<br>|${变量名/旧字符串/新字符串}|  若变量内容符合“旧字符串”，则第1个“旧字符串”会被“新字符串”替换。|<br>|${变量名//旧字符串/新字符串} |  若变量内容符合“旧字符串”，则全部“旧字符串”会被“新字符串”替换。|</p>
<h4 id="变量的替代"><a href="#变量的替代" class="headerlink" title="变量的替代"></a>变量的替代</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;变量名-新的变量名&#125;</span></span><br></pre></td></tr></table></figure>


<p>在Shell中，变量值的类型默认是字符串，不直接进行运算。</p>
<p>用于整数运算的方法有expr、(())和$[]。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr expression</span><br><span class="line">例：</span><br><span class="line">n1 + n2</span><br><span class="line">expr $n1 + $n2</span><br></pre></td></tr></table></figure>
<p>运算符及用于计算的数字两边必须有空格，否则会执行失败。<br>用expr进行乘法运算时，必须在<em>前用反斜线转义（Shell可能误解为</em>号）。</p>
<p>“（（））”或“[ ]”数值运算命令<br>双小括号 “(())” 的作用是进行整数运算和数值比较，其效率很高，用法也非常灵活，是企业中常见的运算操作符<br>格式：<br>“ ((expression))”，或“ [expression]”<br>括号内部两侧可以有空格，也可省空格。<br>需要直接输出运算表达式的运算结果时，可以在“ ((表达式))”前加$符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n1+n2</span><br><span class="line"><span class="meta">$</span><span class="bash">((<span class="variable">$n1</span>+<span class="variable">$n2</span>))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">[<span class="variable">$n1</span>+<span class="variable">$n2</span>]</span></span><br></pre></td></tr></table></figure>

<p>let数值运算命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let expression</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">let sum = n1+n2;</span><br></pre></td></tr></table></figure>

<p>let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量</p>
<h3 id="shell中的特殊符号"><a href="#shell中的特殊符号" class="headerlink" title="shell中的特殊符号"></a>shell中的特殊符号</h3><h4 id="1-“-”表示注释。"><a href="#1-“-”表示注释。" class="headerlink" title="1. “#”表示注释。"></a>1. “#”表示注释。</h4><ul>
<li>行首为#（#!是个例外）表示此行是注释。</li>
<li>注释也可以放在本行命令的后面，需要注意的是#两边有空格。</li>
<li>释也可以放在本行行首空白的后面。</li>
</ul>
<h4 id="2-“-“"><a href="#2-“-“" class="headerlink" title="2. “ ; “"></a>2. “ ; “</h4><ul>
<li>“;”在同一行中分隔两个或者两个以上的命令。</li>
<li>“;”也适用于循环语句</li>
</ul>
<h4 id="3-“-”"><a href="#3-“-”" class="headerlink" title="3. “;;”"></a>3. “;;”</h4><ul>
<li>用于终止case语句</li>
</ul>
<h4 id="4-“-”"><a href="#4-“-”" class="headerlink" title="4. “:”"></a>4. “:”</h4><ul>
<li>空命令“:”和true命令作用相同。</li>
<li>在while死循环和if/then中也可使用这个命令。</li>
</ul>
<h4 id="5-“-”"><a href="#5-“-”" class="headerlink" title="5. “.”"></a>5. “.”</h4><ul>
<li>“.”等价于source命令，是bash中的一个内建命令。</li>
<li>“.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”。ls命令将不会正常显示出这个文件。</li>
<li>当点作为目录名时，一个单独的点代表当前工作目录，而两个点表示上一级目录。</li>
</ul>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><h5 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h5><p>echo命令是最常用的，其功能是将字符串输出到屏幕</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo [-ne] [string]</span><br></pre></td></tr></table></figure>
<p>其中，string表示要输出的字符串。选项n表示输出不换行。选项e表示处理特殊字符</p>
<h5 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h5><p>输出命令printf的功能是格式化输出数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf format [arguments...]</span><br></pre></td></tr></table></figure>

<p>format为输出格式，用单引号或双引号包围都可以。“%s”为格式符，表示输出的格式为字符串，还有“%d”、“%c”、“%f”等，代表的格式与 C 语言中的相同。<br>arguments为要输出的数据。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><h5 id="1-直接给变量赋值"><a href="#1-直接给变量赋值" class="headerlink" title="1. 直接给变量赋值"></a>1. 直接给变量赋值</h5><p>例如，name=liming</p>
<h5 id="2-从键盘读入赋值"><a href="#2-从键盘读入赋值" class="headerlink" title="2. 从键盘读入赋值"></a>2. 从键盘读入赋值</h5><ul>
<li>read命令可以通过从标准输入设备（键盘）读取一行数据赋值给变量。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read  [options] [variable…]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-使用命令行参数赋值"><a href="#3-使用命令行参数赋值" class="headerlink" title="3. 使用命令行参数赋值"></a>3. 使用命令行参数赋值</h5><p>使用命令行参数赋值是直接在命令后面跟参数，系统用$1来调用第一个参数，用$2调用第二个参数……，这种赋值方法适用于参数经常变化且不需要交互的情况。</p>
<h5 id="4-利用命令的输出结果赋值"><a href="#4-利用命令的输出结果赋值" class="headerlink" title="4. 利用命令的输出结果赋值"></a>4. 利用命令的输出结果赋值</h5><ul>
<li>在Shell程序中，可以将一个命令的输出结果当作变量的值（需要在赋值语句中使用反向单引号）。</li>
<li>把命令的结果作为变量的内容进行赋值的方法，在脚本开发时很常见，如按天打包网站的站点目录程序，生成不同文件名</li>
</ul>
<h5 id="5-从文件中读入数据赋值"><a href="#5-从文件中读入数据赋值" class="headerlink" title="5. 从文件中读入数据赋值"></a>5. 从文件中读入数据赋值</h5><p>这种方式就适合处理大批量的数据，直接把相应的数据写入文件中，通过脚本中的命令把文件中的数据读取到脚本程序中以便使用。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 转义字符：用于引用任意的单个字符。</span><br><span class="line">2. 单引号引用（强引用），不管引号里面是否有变量或者其他的表达式，都是原样输出。</span><br><span class="line">3. 双引号引用（弱引用），用于引用包含的字符串，但保留$、 \和`的特殊含义，即引号里面的变量或者函数会先解析再输出内容。</span><br></pre></td></tr></table></figure>

<h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><ol>
<li>test<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">“test  &lt;expression&gt;”</span><br></pre></td></tr></table></figure></li>
<li>“&lt;测试表达式&gt;”</li>
</ol>
<p>也可以使用“&lt;测试表达式&gt;”，就是使用中括号。<br>语法格式：<br>“ [  <expression> ]”<br>注意：[]与expression之间必须有空格。<br>通过[]进行条件测试的方法，与test命令用法相同，推荐使用此方法。</p>
<h4 id="整数测试"><a href="#整数测试" class="headerlink" title="整数测试"></a>整数测试</h4><p>整数测试通常用于数值之间的运算。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">       [ 整数1 操作符 整数2 ]</span><br><span class="line">或   test 整数1 操作符 整数2。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">操作符1</th>
<th align="center">操作符2(部分能用)  意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-eq ==</td>
<td align="center">等于（Equal）</td>
</tr>
<tr>
<td align="center">-ge &gt;=</td>
<td align="center">大于等于（Greater or Equal）</td>
</tr>
<tr>
<td align="center">-gt &gt;</td>
<td align="center">大于（Greater Than-le）</td>
</tr>
<tr>
<td align="center">-le &lt;=</td>
<td align="center">小于等于（Lesser or Equal）</td>
</tr>
<tr>
<td align="center">-lt</td>
<td align="center">&lt;   小于（Lesser Than）</td>
</tr>
<tr>
<td align="center">-ne !=</td>
<td align="center">不等于（Not Equal）</td>
</tr>
</tbody></table>
<h4 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h4><p>字符串测试操作包括比较字符串是否相同、测试字符串的长度是否为0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 字符串1 = 字符串2 ]</span><br><span class="line">[ 字符串1 ！= 字符串2 ]或[ -z 字符串 ]</span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ expression1 op expression2 ]</span><br><span class="line">or       command1 op commnad2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Operator</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">! expr</td>
<td align="center">如果表达式评估为假，则为真</td>
</tr>
<tr>
<td align="center">expr1 -a expr2</td>
<td align="center">如果 expr1 和 expr2 都为真，则结果为真，&amp;&amp;</td>
</tr>
<tr>
<td align="center">expr1 -o expr2</td>
<td align="center">如果 expr1 或 expr2 为真，则结果为真，</td>
</tr>
</tbody></table>
<h3 id="if语句格式"><a href="#if语句格式" class="headerlink" title="if语句格式"></a>if语句格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语句格式：</span><br><span class="line">if [ expression ];then  code</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ expression ]  </span><br><span class="line">then code</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ expression ];then  code1</span><br><span class="line">else code2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ expression ]  </span><br><span class="line">then   code1</span><br><span class="line">else  code2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if expression; then</span><br><span class="line"> command…</span><br><span class="line">[elif expression; then</span><br><span class="line"> command…]</span><br><span class="line">[else</span><br><span class="line"> command…]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case value in</span><br><span class="line">    [ expression1) code1</span><br><span class="line">    ;;</span><br><span class="line">    expression2) code2</span><br><span class="line">    ;;</span><br><span class="line">    …</span><br><span class="line">    *）code</span><br><span class="line">    ]</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while-命令"><a href="#while-命令" class="headerlink" title="while 命令"></a>while 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while expression; do</span><br><span class="line">       command…</span><br><span class="line">done   </span><br></pre></td></tr></table></figure>
<h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until expression; do</span><br><span class="line">     command…</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for  variable in [in sequence]</span><br><span class="line">do</span><br><span class="line">    code</span><br><span class="line">done </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for  变量名 in 取值列表；do     循环体 done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for variable [in sequence]; do</span><br><span class="line">          command…</span><br><span class="line">     done</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((expression1; expression2; expression3;));do</span><br><span class="line">           command…</span><br><span class="line">     done</span><br></pre></td></tr></table></figure>


<p>在循环后面加个 &amp; 符号表示在后台执行</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组分为普通数组和关联数组。"><a href="#数组分为普通数组和关联数组。" class="headerlink" title="数组分为普通数组和关联数组。"></a>数组分为普通数组和关联数组。</h4><p>普通数组中的索引（下标）都是整数。<br>关联数组的数组索引可以用任意的文本。</p>
<p>两者最大区别：</p>
<ul>
<li>关联数组使用之前需要声明。</li>
<li>关联数组是由特定格式的键值对组成</li>
</ul>
<h4 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h4><p>定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arrayname=（value_table）</span><br></pre></td></tr></table></figure>

<p>value_table中值之间用空格隔开。</p>
<h4 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h4><p>定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arrayname=（[indexe1]=value1 [indexe2]=value2 ...... [indexen]=valuen)</span><br></pre></td></tr></table></figure>
<p>其中：<br>indexei可以用标识符表示。</p>
<p>声明普通数组方法：<br>#declare -a arrayname<br>声明关联数组方法：<br>#declare -A arrayname</p>
<h4 id="数组定义方法"><a href="#数组定义方法" class="headerlink" title="数组定义方法"></a>数组定义方法</h4><ul>
<li><p>直接定义数组</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arrayname=(value1 value2 value3 ... valuen)</span><br></pre></td></tr></table></figure></li>
<li><p>下标定义数组</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=([index1]=value1 [index2]=value2 ...)</span><br></pre></td></tr></table></figure></li>
<li><p>间接定义数组</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array[0]=value1;array[1]=value2;....</span><br></pre></td></tr></table></figure>

<ul>
<li>从文件中读入定义数组。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=($(command))</span><br><span class="line">array_name=($(`variable`))</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">array_name=(`command`)</span><br><span class="line">array_name=(`variable`)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="访问数组表达式"><a href="#访问数组表达式" class="headerlink" title="访问数组表达式"></a>访问数组表达式</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>echo ${!array[*]}</td>
<td>访问数组所有索引</td>
</tr>
<tr>
<td>echo ${!array[@]}</td>
<td>访问数组所有索引</td>
</tr>
<tr>
<td>echo ${array[*]}</td>
<td>访问数组所有值</td>
</tr>
<tr>
<td>echo ${array[@]}</td>
<td>访问数组所有值</td>
</tr>
<tr>
<td>echo $</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle期末知识点总结</title>
    <url>/135xyq.github.io/2021/12/30/Oracle%E6%9C%9F%E6%9C%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Oracle知识点总结"><a href="#Oracle知识点总结" class="headerlink" title="Oracle知识点总结"></a>Oracle知识点总结</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><a href="https://www.cnblogs.com/wishyouhappy/p/3681771.html">索引</a></h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE] | [BITMAP] INDEX index_name  --unique表示唯一索引</span><br><span class="line">ON table_name([column1 [ASC|DESC],column2    --bitmap，创建位图索引</span><br><span class="line">[ASC|DESC],…] | [express])</span><br><span class="line">[TABLESPACE tablespace_name]</span><br><span class="line">[PCTFREE n1]                                 --指定索引在数据块中空闲空间</span><br><span class="line">[STORAGE (INITIAL n2)]</span><br><span class="line">[NOLOGGING]                                  --表示创建和重建索引时允许对表做DML操作，默认情况下不应该使用</span><br><span class="line">[NOLINE]</span><br><span class="line">[NOSORT];                                    --表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为student1表的“注册日期”创建索引，并以降序排列，索引名为“DX1_02”。</span><br><span class="line">create index DX1_02 on student1(注册日期 desc);</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_sno;</span><br></pre></td></tr></table></figure>
<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select index_name,index-type, tablespace_name, uniqueness from all_indexes where table_name =&#x27;tablename&#x27;;</span><br><span class="line"></span><br><span class="line"> -- eg:    </span><br><span class="line">create index index_sno on student(&#x27;name&#x27;);</span><br><span class="line">select * from all_indexes where table_name=&#x27;student&#x27;;</span><br></pre></td></tr></table></figure>


<h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a><a href="https://www.cnblogs.com/moonsoft/p/12364941.html">同义词</a></h2><p>Oracle的同义词（synonyms）从字面上理解就是别名的意思，和视图的功能类似</p>
<h3 id="创建公共同义词"><a href="#创建公共同义词" class="headerlink" title="创建公共同义词"></a>创建公共同义词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create public synonym synonym_name for table_name;</span><br></pre></td></tr></table></figure>

<h3 id="创建普通的同义词"><a href="#创建普通的同义词" class="headerlink" title="创建普通的同义词"></a>创建普通的同义词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create  synonym synonym_name for table_name;</span><br></pre></td></tr></table></figure>

<h3 id="删除同义词"><a href="#删除同义词" class="headerlink" title="删除同义词"></a>删除同义词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop synonym synonym_name;</span><br></pre></td></tr></table></figure>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a><a href="https://www.cnblogs.com/CandiceW/p/10062413.html">序列</a></h2><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。不占用磁盘空间，占用内存。其主要用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。</p>
<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>创建序列需要CREATE SEQUENCE系统权限。序列的创建语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　CREATE SEQUENCE 序列名</span><br><span class="line">　　[INCREMENT BY n]</span><br><span class="line">　　[START WITH n]</span><br><span class="line">　　[&#123;MAXVALUE/ MINVALUE n| NOMAXVALUE&#125;]</span><br><span class="line">　　[&#123;CYCLE|NOCYCLE&#125;]</span><br><span class="line">　　[&#123;CACHE n| NOCACHE&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><blockquote>
<p>INCREMENT BY用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表Oracle序列的值是按照此步长递减的。</p>
</blockquote>
</li>
<li><blockquote>
<p>START WITH 定义序列的初始值(即产生的第一个值)，默认为1。</p>
</blockquote>
</li>
<li><blockquote>
<p>MAXVALUE 定义序列生成器能产生的最大值。选项NOMAXVALUE是默认选项，代表没有最大值定义，这时对于递增Oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。</p>
</blockquote>
</li>
<li><blockquote>
<p>MINVALUE定义序列生成器能产生的最小值。选项NOMAXVALUE是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。</p>
</blockquote>
</li>
<li><blockquote>
<p>CYCLE和NOCYCLE 表示当序列生成器的值达到限制值后是否循环。CYCLE代表循环，NOCYCLE代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。</p>
</blockquote>
</li>
<li><blockquote>
<p>CACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。</p>
</blockquote>
</li>
<li><blockquote>
<p>NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用。</p>
</blockquote>
</li>
<li><blockquote>
<p>CURRVAL 中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</p>
</blockquote>
</li>
</ol>
<p> 创建序列，该序列起始值50，步长为10，不缓冲，序列名为“DX1_06”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create sequence DX1_06 increment by 10 start with 50 nocache;</span><br></pre></td></tr></table></figure>

<p>创建序列，该序列起始值为1000，步长为2，最大值为10000，不可循环，序列名为“seq_1”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create sequence seq_1 increment by 2 start with 1000  maxvalue 10000 nocycle;</span><br></pre></td></tr></table></figure>

<h3 id="修改序列"><a href="#修改序列" class="headerlink" title="修改序列"></a>修改序列</h3><p> <strong>alter</strong></p>
<p>修改序列“DX1_06”，将该序列最大值设为“82000”，最小值设为“10”，步长设为“5”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter sequence DX1_06 maxvalue 82000 minvalue 10 increment by 5;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">### 删除序列</span><br><span class="line">**drop**</span><br><span class="line"></span><br><span class="line">删除序列seq_1。</span><br><span class="line">```plsql</span><br><span class="line">drop sequence seq_1;</span><br></pre></td></tr></table></figure>

<h3 id="一些常用函数"><a href="#一些常用函数" class="headerlink" title="一些常用函数"></a>一些常用函数</h3><h4 id="查询一张表，而且要按照业务排序"><a href="#查询一张表，而且要按照业务排序" class="headerlink" title="查询一张表，而且要按照业务排序"></a><a href="https://www.cnblogs.com/mycoding/archive/2010/05/29/1747065.html">查询一张表，而且要按照业务排序</a></h4><p>  <code>rank() over(partition)</code></p>
<h3 id="从右边对字符串使用指定的字符进行填充"><a href="#从右边对字符串使用指定的字符进行填充" class="headerlink" title="从右边对字符串使用指定的字符进行填充 "></a><a href="https://www.cnblogs.com/BetterWF/archive/2012/07/18/2597472.html">从右边对字符串使用指定的字符进行填充 </a></h3><p><code>rpad(string,padded_length,[pad_string]) 　</code></p>
<ul>
<li> string 表示：被填充的字符串 　　</li>
<li> padded_length 表示：字符的长度，是返回的字符串的数量，如果这个数量比原字符串的长度要短，rpad函数将会把字符串截取成从左到右的n个字符; 　　</li>
<li>pad_string 是个可选参数，这个字符串是要粘贴到string的右边，如果这个参数未写，lpad函数将会在string的右边粘贴空格。 　</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><a href="https://blog.csdn.net/qq_39443053/article/details/104044530">存储过程</a></h2><h3 id="存储过程的定义"><a href="#存储过程的定义" class="headerlink" title="存储过程的定义"></a>存储过程的定义</h3><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace procedure 存储过程名</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">  ----------------------------</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace procedure myDemo02(name in varchar,age in int)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">  dbms_output.put_line(&#x27;name=&#x27;||name||&#x27;, age=&#x27;||age);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>主键的创建有三种方法</li>
<li>视图上不能完成的操作：在视图上定义新的基本表</li>
<li>在sql中子查询是嵌入到另一个查询语句之中的查询语句</li>
<li>减少外键能实现实体的完整性</li>
<li>在全文的搜索的函数中，用于指定被搜索的列是match()</li>
<li>中间连接不属于连接种类</li>
<li>连接种类有：外连接、内连接、交叉连接</li>
<li>union可以组合多条SQL查询语句，形成组合查询</li>
<li>分组：grouped by     ？？？</li>
<li>delete语句的使用DELETE FROM Person WHERE LastName = ‘Wilson’ </li>
<li>返回当前日期的函数：curdate()</li>
<li>数据模型：网状模型、层次模型、网络模型</li>
<li>交叉连接又可以看成笛卡尔连接</li>
<li>为数据表创建索引的目的是提高查询的检索性能</li>
<li>SQL语言中的视图view是数据库的外模式</li>
<li>查看数据库中的所有表：show tables</li>
<li>start transaction 表示一个新的事物处理快的开始</li>
<li>格式化日期的函数：DATE_FORMAT()</li>
<li>SQL语言是非过程化语言</li>
<li>在正则表达式中匹配任意一个字符的符号是’ . ‘</li>
<li>DML语句就是数据库操作语句。包括update、 delete、select</li>
<li>DDL数据库定义语言。包括create、alter、drop、truncate</li>
<li>declimal是可变精度浮点值</li>
<li>逻辑运算符优先级：not / and / or</li>
<li><a href="https://www.yiibai.com/sql/sql-limit.html">limit</a></li>
</ol>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="单索引"><a href="#单索引" class="headerlink" title="单索引"></a>单索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  bitmap  index   索引名  <span class="keyword">on</span> 表名( 变量名 <span class="keyword">desc</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> 表示降序排序。  bitmap 为 位图索引 正常可不加</span><br></pre></td></tr></table></figure>

<h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><pre><code>           <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>);              </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="查看索引-1"><a href="#查看索引-1" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_indexes<span class="operator">/</span>user_ind_columns ;</span><br></pre></td></tr></table></figure>



<h3 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名;</span><br></pre></td></tr></table></figure>

<h2 id="同义词-1"><a href="#同义词-1" class="headerlink" title="同义词"></a>同义词</h2><h3 id="创建同义词"><a href="#创建同义词" class="headerlink" title="创建同义词"></a>创建同义词</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> synonym 同义词 <span class="keyword">for</span> 目标</span><br></pre></td></tr></table></figure>

<h3 id="查看同义词"><a href="#查看同义词" class="headerlink" title="查看同义词"></a>查看同义词</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_synonyms;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_synonyms;</span><br></pre></td></tr></table></figure>

<h3 id="删除同义词-1"><a href="#删除同义词-1" class="headerlink" title="删除同义词"></a>删除同义词</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> synonym 同义词;</span><br></pre></td></tr></table></figure>

<h2 id="序列-1"><a href="#序列-1" class="headerlink" title="序列"></a>序列</h2><h3 id="创建序列-1"><a href="#创建序列-1" class="headerlink" title="创建序列"></a>创建序列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence 序列名称</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> 开始数字</span><br><span class="line"></span><br><span class="line">increment <span class="keyword">by</span> 增长数字</span><br><span class="line"></span><br><span class="line">minvalue 最小值</span><br><span class="line"></span><br><span class="line">maxvalue 最大值</span><br><span class="line"></span><br><span class="line"><span class="keyword">cycle</span></span><br><span class="line"></span><br><span class="line">nocache</span><br></pre></td></tr></table></figure>

<p><strong>详细说明：</strong></p>
<p>start with 开始数字à从几开始</p>
<p>increment by 增长à步长，每次增长几个数</p>
<p>minvalue 最小值</p>
<p>maxvalue 最大值à可以不设置，不设置应写为nomaxvalue，也就是无穷大</p>
<p>cycle 循环，也就是说当长增长到最大值后，再从最小值开始重新增长</p>
<p>nocache 不设缓存</p>
<h3 id="查看序列"><a href="#查看序列" class="headerlink" title="查看序列"></a>查看序列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> user_SEQUENCES、all_SEQUENCES;</span><br></pre></td></tr></table></figure>



<h3 id="引用序列"><a href="#引用序列" class="headerlink" title="引用序列"></a>引用序列</h3><p>   xx.nextval      /  xx.curval </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xx表 <span class="keyword">values</span> (  )  ,</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept <span class="keyword">values</span>( DX1_06.nextval,<span class="string">&#x27;ss&#x27;</span>,<span class="string">&#x27;CN&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span> );</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="修改序列-1"><a href="#修改序列-1" class="headerlink" title="修改序列"></a>修改序列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> sequence student_id <span class="comment">-- 序列名 也可以更改</span></span><br><span class="line">minvalue <span class="number">1</span>   </span><br><span class="line">maxvalue <span class="number">99999</span>  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>   </span><br><span class="line">increment <span class="keyword">by</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">cycle</span>    <span class="comment">-- 到99999后，从头开始</span></span><br><span class="line">nocache；  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> 用户名 identified <span class="keyword">by</span> 密码;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  (c##)<span class="keyword">user</span> username identified <span class="keyword">by</span> password;    <span class="operator">/</span><span class="operator">/</span> 创建普通用户 需要添加 c##</span><br></pre></td></tr></table></figure>





<h3 id="锁定用户"><a href="#锁定用户" class="headerlink" title="锁定用户"></a>锁定用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> username ACCOUNT LOCK; 锁定</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> username ACCOUNT UNLOCK; 解锁</span><br></pre></td></tr></table></figure>



<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> username ;</span><br></pre></td></tr></table></figure>



<h2 id="新技能学习-如排序等"><a href="#新技能学习-如排序等" class="headerlink" title="新技能学习 如排序等"></a>新技能学习 如排序等</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(DENSE_)<span class="built_in">RANK</span>( ) <span class="keyword">OVER</span> ([ query_partition_clause ] order_by_clause)</span><br><span class="line"><span class="built_in">rank</span>():跳跃式，两个第<span class="number">1</span>，下一个就是第<span class="number">3</span></span><br><span class="line"><span class="built_in">dense_rank</span>():非跳跃式,两个第<span class="number">1</span>,下一个是第<span class="number">2</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分为：（1）连续或不连续：dense_rank,rank</span><br><span class="line"></span><br><span class="line">     （2）分区或不分区：使用partition，不使用partition</span><br></pre></td></tr></table></figure>



<h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><h2 id="和-的差别"><a href="#和-的差别" class="headerlink" title=".和/ 的差别"></a>.和/ 的差别</h2><p><strong>在SQL*Plus中键入如下PL/SQL块，以点号（.）结束。如果想运行缓冲区的内容，那么可以使用“RUN”命令或者“ / ”命令。</strong><br>1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在SQL*Plus中键入如下PL/SQL块，以点号（.）结束。如果想运行缓冲区的内容，那么可以使用“RUN”命令或者“ / ”命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set serveroutput on 命令是打开COMMAND命令窗口中的输出流。</span><br><span class="line"></span><br><span class="line">不搞的话没输出 非常恐怖！！！！！！！！！！！！！！！！！！！</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>分隔符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code>,<code>-</code>, <code>*</code>, <code>/</code></td>
<td>加法，减法/负，乘法，除法</td>
</tr>
<tr>
<td><code>%</code></td>
<td>属性绑定</td>
</tr>
<tr>
<td><code>&#39;</code></td>
<td>字符串分隔符</td>
</tr>
<tr>
<td><code>.</code></td>
<td>组件选择符</td>
</tr>
<tr>
<td><code>(,)</code></td>
<td>表达式或列表分隔符</td>
</tr>
<tr>
<td><code>:</code></td>
<td>主机变量指示符</td>
</tr>
<tr>
<td><code>,</code></td>
<td>项目分隔符</td>
</tr>
<tr>
<td><code>&quot;</code></td>
<td>引用标识符分隔符</td>
</tr>
<tr>
<td><code>=</code></td>
<td>关系运算符</td>
</tr>
<tr>
<td><code>@</code></td>
<td>远程访问指示符</td>
</tr>
<tr>
<td><code>;</code></td>
<td>声明或语句终止符</td>
</tr>
<tr>
<td><code>:=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>=&gt;</code></td>
<td>关联运算符</td>
</tr>
<tr>
<td>ΙΙ</td>
<td>连接运算符</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数运算符</td>
</tr>
<tr>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td>标签分隔符(开始和结束)</td>
</tr>
<tr>
<td><code>/*</code>, <code>*/</code></td>
<td>多行注释分隔符(开始和结束)</td>
</tr>
<tr>
<td><code>--</code></td>
<td>单行注释指示符</td>
</tr>
<tr>
<td><code>..</code></td>
<td>范围运算符</td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>关系运算符</td>
</tr>
<tr>
<td><code>&lt;&gt;</code>, <code>&#39;=</code>, <code>~=</code>, <code>^=</code></td>
<td>不同版本的”不等于”运算符</td>
</tr>
</tbody></table>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>3、put：将内容写到内存，<strong>等到put_line时一起输出</strong><br>4、put_line：不用多说了，输出字符</p>
<h3 id="输出-语句"><a href="#输出-语句" class="headerlink" title="输出 语句"></a>输出 语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbms_output.put_line(  );   //  line 为换行</span><br><span class="line"></span><br><span class="line">dbms_output.put()  正常输出</span><br></pre></td></tr></table></figure>



<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">PROCEDURE</span> procedure_name </span><br><span class="line">[(parameter_name [<span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">IN</span> <span class="keyword">OUT</span>] type [, ...])] </span><br><span class="line">&#123;<span class="keyword">IS</span> <span class="operator">|</span> <span class="keyword">AS</span>&#125; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">  <span class="operator">&lt;</span> procedure_body <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">END</span> procedure_name;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>



<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul>
<li>使用EXECUTE关键字</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> 过程名;</span><br></pre></td></tr></table></figure>



<ul>
<li>从PL/SQL块调用过程的名称</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"> 过程名;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">FUNCTION</span> function_name </span><br><span class="line">[(parameter_name [<span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">IN</span> <span class="keyword">OUT</span>] type [, ...])] </span><br><span class="line"><span class="keyword">RETURN</span> return_datatype </span><br><span class="line">&#123;<span class="keyword">IS</span> <span class="operator">|</span> <span class="keyword">AS</span>&#125; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="operator">&lt;</span> function_body <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">END</span> [function_name];</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p><strong>其中，</strong></p>
<ul>
<li><strong>function-name是指定要创建的函数的名称。</strong></li>
<li><strong>[OR REPLACE]选项指示是否允许修改现有的函数。</strong></li>
<li><strong>可选参数列表包含参数的名称，模式和类型。 IN表示将从外部传递的值，OUT表示将用于返回过程外的值的参数。</strong></li>
<li><strong>函数必须包含一个返回(RETURN)语句。</strong></li>
<li><strong>RETURN子句指定要从函数返回的数据类型。</strong></li>
<li><strong>function-body包含可执行部分。</strong></li>
<li><strong>使用AS关键字代替IS关键字，用来创建独立的函数。</strong></li>
</ul>
<h3 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h3><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 游标是什么？</span><br><span class="line">   用来存储多条查询数据的一种数据结构（<span class="string">&#x27;结果集&#x27;</span>），</span><br><span class="line">   它有一个 <span class="string">&#x27;指针&#x27;</span>，从上往下移动（<span class="string">&#x27;fetch&#x27;</span>），从而能够 <span class="string">&#x27;遍历每条记录&#x27;</span></span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span> 优缺点</span><br><span class="line">   (<span class="number">1</span>) 提高 <span class="keyword">sql</span> <span class="string">&#x27;执行效率&#x27;</span></span><br><span class="line">   (<span class="number">2</span>) 牺牲 <span class="string">&#x27;内存&#x27;</span></span><br></pre></td></tr></table></figure>







<h3 id="隐式游标"><a href="#隐式游标" class="headerlink" title="隐式游标"></a>隐式游标</h3><h3 id="显示游标"><a href="#显示游标" class="headerlink" title="显示游标"></a>显示游标</h3><p>使用显式游标包括以下步骤 -</p>
<ul>
<li>声明游标初始化内存</li>
<li>打开游标分配内存</li>
<li>从游标获取数据</li>
<li>关闭游标以释放分配的内存</li>
</ul>
<p>声明游标</p>
<p>声明游标使用名称和相关的SELECT语句来定义游标。 例如 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CURSOR</span> c_customers <span class="keyword">IS</span> </span><br><span class="line">   <span class="keyword">SELECT</span> id, name, address <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p>打开游标</p>
<p>打开游标将为游标分配内存，并使其准备好将SQL语句返回的行记录数据提取到其中。例如，打开上面定义的游标，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> c_customers;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p>获取游标获取游标一次仅访问一行。 例如，从上面打开的游标中获取行，如下所示代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> c_customers <span class="keyword">INTO</span> c_id, c_name, c_addr;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p>关闭游标</p>
<p>关闭游标意味着释放分配的内存。例如，关闭上面打开的游标，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> c_customers;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>





<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><table>
<thead>
<tr>
<th>异常</th>
<th>Oracle错误代码</th>
<th>SQLCODE</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ACCESS_INTO_NULL</code></td>
<td>06530</td>
<td><code>-6530</code></td>
<td>当一个空对象被自动分配一个值时会引发它。</td>
</tr>
<tr>
<td><code>CASE_NOT_FOUND</code></td>
<td>06592</td>
<td><code>-6592</code></td>
<td>当没有选择<code>CASE</code>语句的<code>WHEN</code>子句中的任何选项时，会引发这个错误，并且没有<code>ELSE</code>子句。</td>
</tr>
<tr>
<td><code>COLLECTION_IS_NULL</code></td>
<td>06531</td>
<td><code>-6531</code></td>
<td>当程序尝试将<code>EXISTS</code>以外的集合方法应用于未初始化的嵌套表或<code>varray</code>时，或程序尝试将值分配给未初始化的嵌套表或<code>varray</code>的元素时，会引发此问题。</td>
</tr>
<tr>
<td><code>DUP_VAL_ON_INDEX</code></td>
<td>00001</td>
<td><code>-1</code></td>
<td>当尝试将重复值存储在具有唯一索引的列中时引发此错误。</td>
</tr>
<tr>
<td><code>INVALID_CURSOR</code></td>
<td>01001</td>
<td><code>-1001</code></td>
<td>当尝试进行不允许的游标操作(例如关闭未打开的游标)时会引发此错误。</td>
</tr>
<tr>
<td><code>INVALID_NUMBER</code></td>
<td>01722</td>
<td><code>-1722</code></td>
<td>当字符串转换为数字时失败，因为字符串不代表有效的数字。</td>
</tr>
<tr>
<td><code>LOGIN_DENIED</code></td>
<td>01017</td>
<td><code>-1017</code></td>
<td>当程序尝试使用无效的用户名或密码登录到数据库时引发。</td>
</tr>
<tr>
<td><code>NO_DATA_FOUND</code></td>
<td>01403</td>
<td><code>+100</code></td>
<td>当<code>SELECT INTO</code>语句不返回任何行时会引发它。</td>
</tr>
<tr>
<td><code>NOT_LOGGED_ON</code></td>
<td>01012</td>
<td><code>-1012</code></td>
<td>当数据库调用没有连接到数据库时引发。</td>
</tr>
<tr>
<td><code>PROGRAM_ERROR</code></td>
<td>06501</td>
<td><code>-6501</code></td>
<td>当PL/SQL遇到内部问题时会引发。</td>
</tr>
<tr>
<td><code>ROWTYPE_MISMATCH</code></td>
<td>06504</td>
<td><code>-6504</code></td>
<td>当游标在具有不兼容数据类型的变量中获取值时引发。</td>
</tr>
<tr>
<td><code>SELF_IS_NULL</code></td>
<td>30625</td>
<td><code>-30625</code></td>
<td>当调用成员方法时引发，但对象类型的实例未初始化。</td>
</tr>
<tr>
<td><code>STORAGE_ERROR</code></td>
<td>06500</td>
<td><code>-6500</code></td>
<td>当PL/SQL用尽内存或内存已损坏时引发。</td>
</tr>
<tr>
<td><code>TOO_MANY_ROWS</code></td>
<td>01422</td>
<td><code>-1422</code></td>
<td>当<code>SELECT INTO</code>语句返回多行时引发。</td>
</tr>
<tr>
<td><code>VALUE_ERROR</code></td>
<td>06502</td>
<td><code>-6502</code></td>
<td>当发生算术，转换，截断或者<code>sizeconstraint</code>错误时引发。</td>
</tr>
<tr>
<td><code>ZERO_DIVIDE</code></td>
<td>01476</td>
<td><code>1476</code></td>
<td>当尝试将数字除以零时引发。</td>
</tr>
</tbody></table>
<h2 id="异常处理的语法"><a href="#异常处理的语法" class="headerlink" title="异常处理的语法"></a>异常处理的语法</h2><p>异常处理的一般语法如下。在这里，可以列举尽可能多的异常并且指定处理方式。默认的异常将使用WHEN…THEN处理，如下语法所示 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">   <span class="operator">&lt;</span>declarations section<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="operator">&lt;</span>executable command(s)<span class="operator">&gt;</span> </span><br><span class="line">EXCEPTION </span><br><span class="line">   <span class="operator">&lt;</span>exception handling goes here <span class="operator">&gt;</span> </span><br><span class="line">   <span class="keyword">WHEN</span> exception1 <span class="keyword">THEN</span>  </span><br><span class="line">      exception1<span class="operator">-</span>handling<span class="operator">-</span>statements  </span><br><span class="line">   <span class="keyword">WHEN</span> exception2  <span class="keyword">THEN</span>  </span><br><span class="line">      exception2<span class="operator">-</span>handling<span class="operator">-</span>statements  </span><br><span class="line">   <span class="keyword">WHEN</span> exception3 <span class="keyword">THEN</span>  </span><br><span class="line">      exception3<span class="operator">-</span>handling<span class="operator">-</span>statements </span><br><span class="line">   ........ </span><br><span class="line">   <span class="keyword">WHEN</span> others <span class="keyword">THEN</span> </span><br><span class="line">      exception3<span class="operator">-</span>handling<span class="operator">-</span>statements </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SERVEROUTPUT <span class="keyword">ON</span> SIZE <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">   c_id customers.id<span class="operator">%</span>type :<span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line">   c_name  customerS.name<span class="operator">%</span>type; </span><br><span class="line">   c_addr customers.address<span class="operator">%</span>type; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="keyword">SELECT</span>  name, address <span class="keyword">INTO</span>  c_name, c_addr </span><br><span class="line">   <span class="keyword">FROM</span> customers </span><br><span class="line">   <span class="keyword">WHERE</span> id <span class="operator">=</span> c_id;  </span><br><span class="line">   DBMS_OUTPUT.PUT_LINE (<span class="string">&#x27;姓名: &#x27;</span><span class="operator">||</span>  c_name); </span><br><span class="line">   DBMS_OUTPUT.PUT_LINE (<span class="string">&#x27;地址: &#x27;</span> <span class="operator">||</span> c_addr); </span><br><span class="line"></span><br><span class="line">EXCEPTION </span><br><span class="line">   <span class="keyword">WHEN</span> no_data_found <span class="keyword">THEN</span> </span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;没有找到符合条件的客户信息!&#x27;</span>); </span><br><span class="line">   <span class="keyword">WHEN</span> others <span class="keyword">THEN</span> </span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;Error!&#x27;</span>); </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>







<h2 id="填充默认值。"><a href="#填充默认值。" class="headerlink" title="填充默认值。"></a>填充默认值。</h2><p>NVL( xx  ,  0 )  默认为0      zero</p>
<p><strong>语法</strong></p>
<p><strong>NVL(eExpression1, eExpression2)</strong></p>
<p><strong>参数</strong><br><strong>eExpression1, eExpression2</strong></p>
<p><strong>如果 eExpression1 的计算结果为 null 值，则 NVL( ) 返回 eExpression2。如果 eExpression1 的计算结果不是 null 值，则返回 eExpression1。eExpression1 和 eExpression2 可以是任意一种数据类型。如果 eExpression1 与 eExpression2 的结果皆为 null 值，则 NVL( ) 返回 .NULL.。</strong></p>
<h2 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除 delete"></a>删除 delete</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> xx  <span class="keyword">where</span> </span><br></pre></td></tr></table></figure>

<h2 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入 insert"></a>插入 insert</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，......);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列<span class="number">1</span>，列<span class="number">2</span>，......)<span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，......);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名<span class="number">2</span>(列<span class="number">1</span>，列<span class="number">2</span>，......)<span class="keyword">select</span> 值<span class="number">1</span>，值<span class="number">2</span>，...... <span class="keyword">from</span> 表名<span class="number">1</span>;  （表<span class="number">2</span>必须存在，列<span class="number">1</span>，列<span class="number">2</span>，......必须存在）</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表<span class="number">2</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 值<span class="number">1</span>，值<span class="number">2</span>，...... <span class="keyword">into</span> 表名<span class="number">2</span> <span class="keyword">from</span> 表名<span class="number">1</span>; （表<span class="number">2</span>不存在，插入时会自动创建表名<span class="number">2</span>）</span><br></pre></td></tr></table></figure>



<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="old-new"><a href="#old-new" class="headerlink" title="old / new"></a>old / new</h2><p>1.当使用insert语句的时候，如果原表中没有数据的话，那么对于插入数据后表来说新插入的那条数据就是new，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/495456/201608/495456-20160804111235809-1841558199.png" alt="img"></p>
<p>2.当使用delete语句的时候，删除的那一条数据相对于删除数据后表的数据来说就是od，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/495456/201608/495456-20160804111249215-346800140.png" alt="img"></p>
<p>3.当使用update语句的时候，当修改原表数据的时候相对于修改数据后表的数据来说原表中修改的那条数据就是old，而修改数据后表被修改的那条数据就是new，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/495456/201608/495456-20160804111301528-856490776.png" alt="img"></p>
<h2 id="RAISE-APPLICATION-ERROR"><a href="#RAISE-APPLICATION-ERROR" class="headerlink" title="RAISE_APPLICATION_ERROR"></a>RAISE_APPLICATION_ERROR</h2><p>可能不是很多人知道 RAISE_APPLICATION_ERROR 的用途是什么，虽然从字面上已经猜到这个函数是干什么用的。平时用来测试的异常处理<br>我们都是通过dbms_output.put_line来输出异常信息，但是在实际的应用中，需要把异常信息返回给调用的客户端。<br>其实 RAISE_APPLICATION_ERROR 是将应用程序专有的错误从服务器端转达到客户端应用程序(其他机器上的SQLPLUS或者其他前台开发语言)</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>document常用方法</title>
    <url>/135xyq.github.io/2021/12/31/documen%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="document里面的方法"><a href="#document里面的方法" class="headerlink" title="document里面的方法"></a>document里面的方法</h1><hr>
<p>document：整个页面</p>
<p>querySelector(‘选择器’)：可以按CSS的选择器选择方式（选出一个）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> strong = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div &gt; span strong&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">可以选择出有123的strong标签         </span><br></pre></td></tr></table></figure>

<p>querySelectorAll(‘选择器’):可以按CSS的选择器选择方式（选出一组）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> strong = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div &gt; span strong&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">可以选择出有123的一组strong标签   </span><br></pre></td></tr></table></figure>

<p>querySeclect 和querySelectAll是静态的，选择后不再更新（选出来的是副本）</p>
<h3 id="遍历节点树：（包含所有节点）"><a href="#遍历节点树：（包含所有节点）" class="headerlink" title="遍历节点树：（包含所有节点）"></a>遍历节点树：（包含所有节点）</h3><ul>
<li>parentNode:父节点</li>
<li>childNodes：子节点集合</li>
<li>firstChild：第一个子节点</li>
<li>lastChild：最后一个子节点</li>
<li>nextSibling：后一个兄弟节点</li>
<li>previousSibling：前一个兄弟节点</li>
</ul>
<h3 id="遍历元素节点树：（只有元素节点）"><a href="#遍历元素节点树：（只有元素节点）" class="headerlink" title="遍历元素节点树：（只有元素节点）"></a>遍历元素节点树：（只有元素节点）</h3><ul>
<li>parentElement：返回当前元素的父元素节点</li>
<li>children：只返回当前元素的元素子节点</li>
<li>node.childElementCount === node.children.length：当前元素节点的子元素个数</li>
<li>firstElementChild：第一个元素节点</li>
<li>lastElementChild：最后一个元素节点</li>
<li>nextElementSibling：后一个兄弟元素节点</li>
<li>previousElementSibling：前一个兄弟元素节点</li>
</ul>
<h3 id="节点的四个属性"><a href="#节点的四个属性" class="headerlink" title="节点的四个属性"></a>节点的四个属性</h3><ul>
<li>nodeName：元素的标签名，以大些形式表示，只读</li>
<li>nodeValue：Text节点或Comment节点的文本内容，可读写</li>
<li>nodeType：该节点的类型，只读</li>
<li>attributes：Element节点的属性集合</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li><p>getElementById方法定义在Document.prototype上，即Element节点上不能使用。</p>
</li>
<li><p>getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)</p>
</li>
<li><p>getElementsByTagName方法定义在Document.prototype 和 Element.prototype上</p>
</li>
<li><p>HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head>标签。</p>
</li>
<li><p>Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素</p>
</li>
<li><p>getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义</p>
</li>
</ol>
<h3 id="dom的基本操作"><a href="#dom的基本操作" class="headerlink" title="dom的基本操作"></a>dom的基本操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement();增加元素节点</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.createTextNode();增加文本节点</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.createComment();</span><br><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">&quot;This is a Comment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.createDocumentFragment();文档碎片节点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="插"><a href="#插" class="headerlink" title="插"></a>插</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PARENTNODE.appendChild();插入节点（剪切操作）</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这里在div中插入一个文本节点&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        div.appendChild(text);</span><br><span class="line">        div.appendChild(span);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PARENTNODE.insertBefore(a, b);在父集中将a插在b前面</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        div.insertBefore(span, strong);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;在strong前面插入一个文本节点&quot;</span>);</span><br><span class="line">        div.insertBefore(text, strong);</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.removeChild();父节点调用方法删除子节点（剪切）</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.removeChild(strong);</span><br><span class="line">        删除div下面的strong标签</span><br><span class="line">parent.remove();子节点自己调用方法删除自己（销毁）</span><br><span class="line">        <span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        strong.remove()</span><br><span class="line">        删除div下面的strong标签</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.replaceChild(<span class="keyword">new</span>, origin);（剪切）</span><br><span class="line">         <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;将strong标签替换成为一个文本&quot;</span>);</span><br><span class="line">         div.replaceChild(text, strong);</span><br><span class="line">Element节点的一些属性</span><br><span class="line"></span><br><span class="line">innerHTML（取写HTML）</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.innerHTML;</span><br><span class="line">        将div里面的东西查找出来</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.innerHTML = <span class="string">&quot;将div原来的东西覆盖掉&quot;</span>;</span><br><span class="line">        将div里面的东西替换</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.innerHTML = <span class="string">&quot;将div原来的东西覆盖掉&quot;</span>;</span><br><span class="line">        div.innerHTML += <span class="string">&quot;再加一点东西！&quot;</span>;</span><br><span class="line">        在原来的div后面再添加一点东西</span><br><span class="line">innerText（取写文本，老版本火狐不支持（提供TextContent一样））</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.innerText;</span><br><span class="line">        将div里面的文本取出来</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.innerText = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        将div里面的所有东西替换成<span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="Element节点的一些方法"><a href="#Element节点的一些方法" class="headerlink" title="Element节点的一些方法"></a>Element节点的一些方法</h3><h4 id="ele-setAttribute-设置属性"><a href="#ele-setAttribute-设置属性" class="headerlink" title="ele.setAttribute() ;设置属性"></a>ele.setAttribute() ;设置属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;class1&#x27;</span>);</span><br><span class="line">给div添加名为class1 的 <span class="class"><span class="keyword">class</span>属性</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">div</span> </span>= <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;only&#x27;</span>);</span><br><span class="line">给div添加一个名为only的 id属性</span><br></pre></td></tr></table></figure>

<h4 id="ele-getAttribute-获取属性"><a href="#ele-getAttribute-获取属性" class="headerlink" title="ele.getAttribute() ;获取属性"></a>ele.getAttribute() ;获取属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.getAttribute(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">获取div的id</span><br></pre></td></tr></table></figure>
<p>document.getElementsByTagName(*);可以把所有标签取出来</p>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>日期对象是系统提供好的。</p>
<p><code>var date = new Date();</code></p>
<p>setInterval(函数，时间间隔);循环执行（每隔一段时间执行函数），都会返回一个数字唯一标识</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">每隔<span class="number">1000</span>毫秒执行一次<span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>

<p>setTimeout(函数，时间间隔);推迟一段时间在执行，仅执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;推迟1000毫秒执行，仅执行一次。&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(数字);停止执行</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        可以停止<span class="built_in">setInterval</span>的执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>();</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;隔1000毫秒执行，仅执行一次。&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        清除<span class="built_in">setTimeout</span>的执行</span><br></pre></td></tr></table></figure>
<p>全局对象window上的方法，内部函数this指向window</p>
<h4 id="注意-："><a href="#注意-：" class="headerlink" title="注意 ："></a>注意 ：</h4><p>setInterval(“字符串”,1000);会每隔一段时间执行字符串里面的代码（当成js代码）</p>
<h4 id="查看滚动条的滚动距离："><a href="#查看滚动条的滚动距离：" class="headerlink" title="查看滚动条的滚动距离："></a>查看滚动条的滚动距离：</h4><p>window.pageXOffset/pageYOffset<br>IE8及IE8以下不兼容</p>
<p><code>document.body.scrollLeft/scrollTop</code><br><code>document.documentElement.scrollLeft/scrollTop</code></p>
<p>兼容性比较混乱，用时取两个值相加，因为不可能存在两个同时有值。</p>
<h3 id="查看视口的尺寸："><a href="#查看视口的尺寸：" class="headerlink" title="查看视口的尺寸："></a>查看视口的尺寸：</h3><p><code>window.innerWidth/innerHeight</code><br>IE8及IE8以下不兼容</p>
<p><code>document.documentElement.clientWidth/clientHeight</code></p>
<p>标准模式下，任意浏览器都兼容</p>
<p><code>document.body.clientWidth/clientHeight</code></p>
<p>适用于怪异模式下的浏览器</p>
<h3 id="浏览器的渲染模式："><a href="#浏览器的渲染模式：" class="headerlink" title="浏览器的渲染模式："></a>浏览器的渲染模式：</h3><ol>
<li>标准模式：</li>
<li>怪异模式（混扎模式）：可支持老版本，启动方法（删除<!DOCTYPE html>）</li>
</ol>
<h4 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸:"></a>查看元素的几何尺寸:</h4><p><code>domEle.getBoundingClientRect();</code></p>
<p>兼容性很好。</p>
<p>该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标<br>height和width属性。<br>老版本IE并未实现。</p>
<p>返回的结果并不是“实时的”。</p>
<h4 id="查看元素的尺寸："><a href="#查看元素的尺寸：" class="headerlink" title="查看元素的尺寸："></a>查看元素的尺寸：</h4><p><code>dom.offsetWidth，dom.offsetHeight</code></p>
<h4 id="查看元素的位置："><a href="#查看元素的位置：" class="headerlink" title="查看元素的位置："></a>查看元素的位置：</h4><p><code>dom.offsetLeft, dom.offsetTop</code></p>
<p>对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。</p>
<p><code>dom.offsetParent</code></p>
<p>返回最近的有定位的父级，如无，返回body, body.offsetParent 返回null</p>
<h3 id="让滚动条滚动："><a href="#让滚动条滚动：" class="headerlink" title="让滚动条滚动："></a>让滚动条滚动：</h3><p>window上有三个方法</p>
<ul>
<li>scroll(),</li>
<li>scrollTo(),</li>
<li>scrollBy();</li>
</ul>
<p>三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。</p>
<p>区别：scrollBy()会在之前的数据基础之上做累加。</p>
<h3 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h3><p><code>dom.style.prop（获取的是行间样式表）</code></p>
<p>可读写行间样式，没有兼容性问题，碰到float这样的关键字属性，前面应加css</p>
<p><code>eg:float — &gt; cssFloat</code></p>
<p>复合属性必须拆解，组合单词变成小驼峰式写法</p>
<p>写入的值必须是字符串格式</p>
<p>查询计算样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(ele,<span class="literal">null</span>);（展示的值和默认值）</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">window</span>.getComputedStyle(div,<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算样式只读</p>
<p>返回的计算样式的值都是绝对值，没有相对单位 </p>
<p>IE8 及 IE8以下不兼容<br>可以用getComputedStyle（ele,伪元素名）来获取伪元素的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">window</span>.getComputedStyle(div, <span class="string">&quot;after&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="查询样式"><a href="#查询样式" class="headerlink" title="查询样式"></a>查询样式</h4><p>ele.currentStyle</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.currentStyle.width;</span><br></pre></td></tr></table></figure>

<p>计算样式只读</p>
<p>返回的计算样式的值不是经过转换的绝对值</p>
<p>IE独有的属性</p>
<p>元素名.className = “class名”;可以改元素的class</p>
<h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3><h4 id="绑定事件："><a href="#绑定事件：" class="headerlink" title="绑定事件："></a>绑定事件：</h4><ol>
<li><code>ele.onxxx = function (event) &#123;&#125;</code><br>兼容性很好，但是一个元素只能绑定一个处理程序</li>
</ol>
<p>基本等同于写在HTML行间上。（在行间不用写function直接写执行语句就行）<br>程序this指向是dom元素本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">            函数体</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>obj.addEventListener(事件类型, 处理函数, false);</code></li>
</ol>
<p>IE9以下不兼容，可以为一个事件绑定多个处理程序。<br>程序this指向是dom元素本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> i = <span class="number">0</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                lis[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                    <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                &#125;, <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;(i))</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//点击每个li展示其序号（注意闭包的应用）</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>obj.attachEvent(‘on’ + type, fn);</code></li>
</ol>
<p>IE独有，一个事件同样可以绑定多个处理程序,IE 独有<br>程序this指向是window</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="解除事件处理函数"><a href="#解除事件处理函数" class="headerlink" title="解除事件处理函数"></a>解除事件处理函数</h3><p><strong>注:若绑定匿名函数，则无法解除</strong></p>
<ol>
<li><p><code>ele.onclick = false/‘’/null;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        div.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ele.removeEventListener(type, fn, false)</code>;</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;click&#x27;</span>, f, <span class="literal">false</span>);</span><br><span class="line">        div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, f, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">若为</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">则无法解除事件绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>ele.detachEvent(‘on’ + type, fn);</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, f);</span><br><span class="line">        div.detachEvent(<span class="string">&#x27;onclick&#x27;</span>, f);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="事件处理模-事件冒泡、捕获"><a href="#事件处理模-事件冒泡、捕获" class="headerlink" title="事件处理模: 事件冒泡、捕获"></a>事件处理模: 事件冒泡、捕获</h3><p>一个事件只能执行一个事件模型</p>
<h4 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h4><p>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）（从子元素到父元素）</p>
<h4 id="事件捕获："><a href="#事件捕获：" class="headerlink" title="事件捕获："></a>事件捕获：</h4><p>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向上）  </p>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式:"></a>触发方式:</h5><p>elem.addEventListeren(‘type’,function(){} ,true);<br>IE没有捕获事件</p>
<p>触发顺序，先捕获，后冒泡</p>
<p>focus，blur，change，submit，reset，select 等事件不冒泡</p>
<p>取消冒泡和阻止默认事件：</p>
<h4 id="取消冒泡："><a href="#取消冒泡：" class="headerlink" title="取消冒泡："></a>取消冒泡：</h4><p>W3C标准 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.stopPropagation();</span><br><span class="line">        <span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;你正在点击整个文档！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">//可以加一个参数，代表当前事件的监听，是一个对象</span></span><br><span class="line">            e.stopPropagation();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;点击div时不再冒泡！&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>但不支持ie9以下版本</p>
<p>IE独有 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;你正在点击整个文档！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// e.stopPropagation();</span></span><br><span class="line">            e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;点击div时不再冒泡！&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件:"></a>阻止默认事件:</h4><p>默认事件 — 表单提交，a标签跳转，右键菜单等</p>
<ol>
<li><p><code>return false;</code>  以对象属性的方式注册的事件才生效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> 可以阻止右键出菜单</span><br><span class="line"> </span><br><span class="line">       &lt;a href=<span class="string">&quot;javascript:void(false)&quot;</span>&gt;demo&lt;/a&gt;</span><br><span class="line">可以阻止a标签的跳转</span><br></pre></td></tr></table></figure></li>
<li><p><code>event.preventDefault();</code> W3C标注，IE9以下不兼容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>event.returnValue = false;</code> 兼容IE</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h4><p>event || window.event 用于IE<br>事件<br>源对象:<br><code>event.target</code>火狐独有的</p>
</li>
</ol>
<p><code>event.srcElement</code> IE独有的</p>
<p>这俩chrome都有</p>
<h4 id="事件委托："><a href="#事件委托：" class="headerlink" title="事件委托："></a>事件委托：</h4><p>利用事件冒泡，和事件源对象进行处理</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol>
<li><p>性能 不需要循环所有的元素一个个绑定事件</p>
</li>
<li><p>灵活 当有新的子元素时不需要重新绑定事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">     &lt;ul&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event; <span class="comment">//考虑事件的兼容性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">var</span> target = event.target || event.srcElement;<span class="comment">//考虑源事件的兼容性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">console</span>.log(target.innerText);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">可以为所有的li添加事件，将li的事件委托给ul</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="鼠标事件："><a href="#鼠标事件：" class="headerlink" title="鼠标事件："></a>鼠标事件：</h4><ul>
<li>click、鼠标点击（包括按下和弹起）</li>
<li>mousedown、鼠标按下</li>
<li>mousemove、鼠标移动</li>
<li>mouseup、鼠标弹起</li>
<li>contextmenu、鼠标右键产生菜单</li>
<li>mouseover == mouseenter、鼠标进入区域</li>
<li>mouseout == mouseleave、鼠标移出区域</li>
</ul>
<p>只有mouseup和mousedown能区分鼠标左右键<br>用button来区分鼠标的按键，0/1/2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.button == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;按下的是鼠标右键！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.button == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;按下的是鼠标左键!&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;按下的是中间滚动轮!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DOM3标准规定:click事件只能监听左键,只能通过mousedown 和 mouseup来判断鼠标键</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul>
<li>keydown 按下</li>
<li>keyup 弹开</li>
<li>keypress</li>
</ul>
<p>触发顺序：keydown &gt; keypress &gt; keyup</p>
<h5 id="keydown和keypress的区别"><a href="#keydown和keypress的区别" class="headerlink" title="keydown和keypress的区别"></a>keydown和keypress的区别</h5><p>keydown 可以响应任意键盘按键(charcode始终为0),     keypress只可以响应字符类键盘按键(charcode对应ACICC码)</p>
<p>keypress返回ASCII码，可以转换成相应字符<br>操作型按键用keydown（可以使用which属性）<br>字符型按键用keypress</p>
<h4 id="文本操作事件："><a href="#文本操作事件：" class="headerlink" title="文本操作事件："></a>文本操作事件：</h4><ul>
<li>input,只要文本有变化就触发</li>
<li>focus,聚焦时触发</li>
<li>blur,失去焦点触发</li>
<li>change，失去焦点比较前后两个状态，如果内容改变则触发，内容不变则不触发</li>
</ul>
<h4 id="窗体操作类-window上的事件"><a href="#窗体操作类-window上的事件" class="headerlink" title="窗体操作类(window上的事件)"></a>窗体操作类(window上的事件)</h4><ul>
<li>scroll滚动条滚动<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>.pageXOffset + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.pageYOffset);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
load,整个页面加载完才能触发    </li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas属性</title>
    <url>/135xyq.github.io/2021/12/31/canvas%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="CANVAS属性，方法"><a href="#CANVAS属性，方法" class="headerlink" title="CANVAS属性，方法"></a><a href="https://www.cnblogs.com/xinyouhunran/p/10968096.html">CANVAS属性，方法</a></h1><p><strong>基于：</strong><br>var canvas = document.getElementById(‘id’);<br>var ctx = canvas.getContext(‘2d’);</p>
<p><strong>1.样式：</strong><br>ctx.fillStyle = ‘color’-填充色<br>ctx.strokeStyle = ‘color’-线色<br>ctx.lineWidth = ‘length’-线宽<br>lineCap = type-设置线条末端的外观。<br>lineJoin = type-设置线条相交的“角落”的外观。<br>miterLimit = value-当两条线以锐角连接时，建立一个斜接限制，以控制结的厚度。<br>getLineDash()-返回包含偶数个非负数的当前行虚线模式数组。<br>setLineDash(segments)-设置当前行虚线模式。<br>lineDashOffset = value-指定在一行上启动破折号数组的位置。</p>
<p><strong>2.画矩形：</strong><br>ctx.fillRect(x, y, width, height)-填充矩形<br>ctx.strokeRect(x, y, width, height)-非填充矩形，只有边框<br>ctx.clearRect(x, y, width, height)-清除范围</p>
<p><strong>3.画路径</strong><br>ctx.beginPath()-开始画<br>ctx.moveTo(x,y)-算是定义起点吧<br>ctx.lineTo(x,y)-连线到某点<br>ctx.fill()-会自动闭合<br>ctx.stroke()-不会闭合<br>ctx.closePath()-关闭绘画</p>
<p><strong>4.画圆</strong><br>ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)-radius代表半径，anticlockwise代表顺时针，逆时针(boolean)</p>
<p><strong>5.曲线</strong><br>quadraticCurveTo(cp1x, cp1y, x, y)-xy偏离一致的曲线<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)-想怎么偏怎么偏</p>
<p><strong>6.new Path2D()</strong>:创建一个2d路径对象，对此对象进行操作，最后成为stroke()或fill()的参数。</p>
<p><strong>7.渐变</strong><br>createLinearGradient(x1, y1, x2, y2)<br>createRadialGradient(x1, y1, r1, x2, y2, r2)<br>gradient.addColorStop(position, color)（0~1，color）</p>
<p><strong>8.模式</strong><br>createPattern(image, type)-创建并返回一个新的画布模式对象<br>image是一个Canvasimgource,type是一个表示如何使用图像的字符串(如平铺)</p>
<p><strong>9.阴影</strong><br>shadowOffsetX = float<br>指示阴影应从对象延伸的水平距离。该值不受变换矩阵的影响。默认值为0。<br>shadowOffsetY = float<br>指示阴影应从对象延伸的垂直距离。该值不受变换矩阵的影响。默认值为0。<br>shadowBlur = float<br>表示模糊效果的大小; 该值不对应于多个像素，并且不受当前变换矩阵的影响。默认值为0。<br>shadowColor = color<br>标准CSS颜色值，表示阴影效果的颜色; 默认情况下，它是完全透明的黑色。</p>
<p><strong>10.绘文字</strong><br>fillText(text, x, y [, maxWidth])<br>在给定（x，y）位置填充给定文本。可选择绘制最大宽度。<br>strokeText(text, x, y [, maxWidth])<br>在给定（x，y）位置描边给定文本。可选择绘制最大宽度。<br>font = value<br>绘制文本时使用的当前文本样式。此字符串使用与CSS font属性相同的语法。默认字体是10px sans-serif。<br>textAlign = value<br>文本对齐设置。可能的值：start，end，left，right或center。默认值为start。<br>textBaseline = value<br>基线对齐设置。可能的值：top，hanging，middle，alphabetic，ideographic，bottom。默认值为alphabetic。<br>direction = value<br>方向性。可能的值：ltr，rtl，inherit。默认值为inherit。<br>measureText()<br>返回一个TextMetrics对象，该对象包含以当前文本样式绘制时指定文本的宽度</p>
<p><strong>11.图像</strong><br>drawImage(image, x, y,width,height)<br>绘制坐标（x，y）处Canvasimgource的image参数指定的值。<br>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)-切片<br>给定一个image，该功能只通过其左上角是矩形指定的源图像的区域（sx，sy其宽度和高度是），并sWidth与sHeight和它绘制到画布，<br>在将其放置在画布上（dx，dy）和缩放它由指定的大小dWidth和dHeight。</p>
<p><strong>12.保存和恢复状态</strong><br>save()<br>保存画布的整个状态。<br>restore()<br>恢复最近保存的画布状态。<br>画布状态存储在堆栈中。每次save()调用该方法时，当前绘图状态都会被压入堆栈。<br>您可以save()根据需要多次调用该方法。每次restore()调用该方法时，最后保存的状态将从堆栈中弹出，并恢复所有保存的设置。</p>
<p><strong>13.动画</strong><br>translate(x, y)<br>rotate(angle)<br>scale(x, y)<br>transform(a, b, c, d, e, f)//矩阵<br>setTransform(a, b, c, d, e, f)<br>将当前变换重置为单位矩阵，然后transform()使用相同的参数调用该方法。这基本上撤消了当前的转换，然后在一个步骤中设置指定的转换。<br>resetTransform()<br>将当前变换重置为单位矩阵。<br>使用动画，使用window.requestAnimationFrame()而不是window.setInterval()<br>window.cancelAnimationFrame();取消帧动画</p>
<p><strong>14.合成</strong><br>globalCompositeOperation = type<br>这将设置在绘制新形状时应用的合成操作的类型，其中type是一个字符串，用于标识要使用的十二个合成操作中的哪一个。</p>
<p>**15.clip()**剪切路径</p>
<p><strong>16.获取上下文的像素数据</strong><br>ctx.getImageData(left, top, width, height);<br>此方法返回一个ImageData对象，该对象表示画布区域的像素数据，其角点由点（left，top），（left+width，top），（left，top+height）和（left+width，top+height）表示。坐标以画布坐标空间单位指定。</p>
<p><strong>17.将像素数据绘制到上下文中</strong><br>ctx.putImageData(myImageData, dx, dy);<br>该dx和dy参数显示在其中进行绘制要绘制的像素数据的左上角的范围内的设备坐标。</p>
<p><strong>18.保存图像</strong><br>canvas.toDataURL(‘image/png’)<br>默认设置。创建PNG图像。<br>canvas.toDataURL(‘image/jpeg’, quality)<br>创建JPG图像。或者，您可以提供0到1范围内的质量，其中一个是最好的质量，0几乎不可识别但文件大小很小。<br>canvas.toBlob(callback, type, encoderOptions)<br>创建Blob表示画布中包含的图像的对象。</p>
<p><strong>19.命中区域</strong><br>CanvasRenderingContext2D.addHitRegion()<br>在画布中添加命中区域。<br>CanvasRenderingContext2D.removeHitRegion()<br>使用id画布中指定的内容删除命中区域。<br>CanvasRenderingContext2D.clearHitRegions()<br>从画布中删除所有命中区域。<br>检查MouseEvent.region属性以测试鼠标是否正在击中您的区域</p>
<p><strong>20.聚焦环</strong><br>CanvasRenderingContext2D.drawFocusIfNeeded()<br>如果给定元素被聚焦，则此方法围绕当前路径绘制聚焦环。<br>CanvasRenderingContext2D.scrollPathIntoView()<br>将当前路径或给定路径滚动到视图中。</p>
<p><strong>21.基于canvas封装的代码片段</strong>（<a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Canvas%EF%BC%89">https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Canvas）</a><br>获取画布中某种颜色的像素数<br>获取画布中像素的颜色<br>链接方法<br>将画布图像保存到文件<br>将远程页面加载到画布元素上<br>将图像文件转换为base64字符串</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的git操作</title>
    <url>/135xyq.github.io/2021/12/31/git%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="git-常用命令。"><a href="#git-常用命令。" class="headerlink" title="git 常用命令。"></a>git 常用命令。</h1><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><blockquote>
<p>创建SSH key</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试SSH key配对成功</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@gitee.com</span></span><br></pre></td></tr></table></figure>
<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span>             </span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><blockquote>
<p>在当前目录新建一个Git代码库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个目录，将其初始化为Git代码库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下载一个项目和它的整个代码历史</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure>
<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><blockquote>
<p>添加指定文件到暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加指定目录到暂存区，包括子目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加当前目录的所有文件到暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加每个变化前，都会要求确认<br>对于同一个文件的多处变化，可以实现分次提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除工作区文件，并且将这次删除放入暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>停止追踪指定文件，但该文件会保留在工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>改名文件，并且将这个改名放入暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><blockquote>
<p>提交暂存区到仓库区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交工作区自上次commit之后的变化，直接到仓库区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交时显示所有diff信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用一次新的commit，替代上一次提交<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重做上一次commit，并包括指定文件的新变化</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><blockquote>
<p>显示有变更的文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示当前分支的版本历史</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示commit历史，以及每次commit发生变更的文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索提交历史，根据关键词</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个commit之后的所有变动，每个commit占据一行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个文件的版本历史，包括文件改名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示指定文件相关的每一次diff</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示过去5次提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示所有提交过的用户，按提交次数排序</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示指定文件是什么人在什么时间修改过</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示暂存区和工作区的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示暂存区和上一个commit的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示工作区与当前分支最新commit之间的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示两次提交之间的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示今天你写了多少行代码</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某次提交的元数据和内容变化</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某次提交发生变化的文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某次提交时，某个文件的内容</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示当前分支的最近几次提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote>
<p>列出所有本地分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有远程分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有本地分支和远程分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，但依然停留在当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，并切换到该分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，指向指定commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，与指定的远程分支建立追踪关系</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换到指定分支，并更新工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换到上一个分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并指定分支到当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>选择一个commit，合并进当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除远程分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><blockquote>
<p>列出所有tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个tag在当前commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个tag在指定commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除本地tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除远程tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看tag信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交指定tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交所有tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，指向某个tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><blockquote>
<p>下载远程仓库的所有变动</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示所有远程仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个远程仓库的信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>增加一个新的远程仓库，并命名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>取回远程仓库的变化，并与本地分支合并</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>允许不相关历史提交,并强制合并</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master --allow-unrelated-histories</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传本地指定分支到远程仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin 分支名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强行推送当前分支到远程仓库，即使有冲突</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推送所有分支到远程仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><blockquote>
<p>恢复暂存区的指定文件到工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>恢复某个commit的指定文件到暂存区和工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>恢复暂存区的所有文件到工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置暂存区与工作区，与上一次commit保持一致</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>暂时将未提交的变化移除，稍后再移入</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>

<h2 id="忽略文件配置（-gitignore"><a href="#忽略文件配置（-gitignore" class="headerlink" title="忽略文件配置（.gitignore)"></a>忽略文件配置（.gitignore)</h2><p>1、配置语法:</p>
<blockquote>
<p>以斜杠“/”开头表示目录；</p>
<p>以星号“*”通配多个字符；</p>
<p>以问号“?”通配单个字符</p>
<p>以方括号“[]”包含单个字符的匹配列表；</p>
<p>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>
</blockquote>
<p>此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>
<p>2、示例：</p>
<p>　　（1）规则：fd1/*<br>　　　　  说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</p>
<p>　　（2）规则：/fd1/*<br>　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；</p>
<p>　　（3）规则：</p>
<p>/*<br>!.gitignore<br>!/fw/bin/<br>!/fw/sf/</p>
<p>说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Fetch Api</title>
    <url>/135xyq.github.io/2021/12/31/fetchAPI%20/</url>
    <content><![CDATA[<h1 id="Fetch-Api"><a href="#Fetch-Api" class="headerlink" title="Fetch Api"></a>Fetch Api</h1><hr>
<h2 id="Fetch-Api-1"><a href="#Fetch-Api-1" class="headerlink" title="Fetch Api"></a>Fetch Api</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p> <strong>请求测试地址：<a href="http://101.132.72.36:5100/api/local">http://101.132.72.36:5100/api/local</a></strong></p>
<p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>该函数有两个参数：</p>
<ol>
<li>必填，字符串，请求地址</li>
<li>选填，对象，请求配置</li>
</ol>
<h3 id="请求配置对象"><a href="#请求配置对象" class="headerlink" title="请求配置对象"></a><strong>请求配置对象</strong></h3><ul>
<li>method：字符串，请求方法，默认值GET</li>
<li>headers：对象，请求头信息</li>
<li>body: 请求体的内容，必须匹配请求头中的 Content-Type</li>
<li>mode：字符串，请求模式<ul>
<li>cors：默认值，配置为该值，会在请求头中加入 origin 和 referer</li>
<li>no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题</li>
<li>same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错</li>
</ul>
</li>
<li>credentials: 如何携带凭据（cookie）<ul>
<li>omit：默认值，不携带cookie</li>
<li>same-origin：请求同源地址时携带cookie</li>
<li>include：请求任何地址都携带cookie</li>
</ul>
</li>
<li>cache：配置缓存模式<ul>
<li>default: 表示fetch请求之前将检查下http的缓存.</li>
<li>no-store: 表示fetch请求将完全忽略http缓存的存在. 这意味着请求之前将不再检查下http的缓存, 拿到响应后, 它也不会更新http缓存.</li>
<li>no-cache: 如果存在缓存, 那么fetch将发送一个条件查询request和一个正常的request, 拿到响应后, 它会更新http缓存.</li>
<li>reload: 表示fetch请求之前将忽略http缓存的存在, 但是请求拿到响应后, 它将主动更新http缓存.</li>
<li>force-cache: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request.</li>
<li>only-if-cached: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”same-origin”时有效).</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>fetch 函数返回一个 Promise 对象</p>
<ul>
<li>当收到服务器的返回结果后，Promise 进入resolved状态，状态数据为 Response 对象</li>
<li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li>
</ul>
<h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a><strong>Response对象</strong></h3><ul>
<li>ok：boolean，当响应消息码在200~299之间时为true，其他为false</li>
<li>status：number，响应的状态码</li>
<li>text()：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 string 对象的 Promise。</li>
<li>blob()：用于处理二进制文件格式（比如图片或者电子表格）的 Ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise。</li>
<li>json()：用于处理 JSON 格式的 Ajax 的响应。它将 JSON 数据流转换为一个被解决为 JavaScript 对象的promise。</li>
<li>redirect()：可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应。</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery的基本语法</title>
    <url>/135xyq.github.io/2022/01/20/jquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><h2 id="jquery代码书写位置的三种"><a href="#jquery代码书写位置的三种" class="headerlink" title="jquery代码书写位置的三种"></a>jquery代码书写位置的三种</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$().ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>dom元素加载完就会触发ready</p>
<h3 id="jquery的特点："><a href="#jquery的特点：" class="headerlink" title="jquery的特点："></a>jquery的特点：</h3><ol>
<li>强大的选择器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> $h1 = $(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log($h1);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>链式操作</p>
<p>原生js取到的dom对象和jquery取到的不一样。<br>原生js取到的对象不能使用jquery里面的方法。<br>jquery取到的对象也不能使用使用原生的js方法。</p>
</li>
</ol>
<h3 id="原生js和jquery元素之间可以相互转化："><a href="#原生js和jquery元素之间可以相互转化：" class="headerlink" title="原生js和jquery元素之间可以相互转化："></a>原生js和jquery元素之间可以相互转化：</h3><p>原生js转jquery： $(dom对象);<br>jquery转原生js： $jquery对象[0];</p>
<p>jquery取到的永远是一个数组</p>
<h2 id="jquery选择器"><a href="#jquery选择器" class="headerlink" title="jquery选择器"></a><a href="https://www.jquery123.com/category/selectors/">jquery选择器</a></h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span>&gt;不错&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;className&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    $(<span class="string">&#x27;*&#x27;</span>).css(<span class="string">&#x27;border&#x27;</span>, <span class="string">&#x27;2px solid black&#x27;</span>); <span class="comment">//通配符选择器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    $(<span class="string">&#x27;#box&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="comment">//ID选择器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    $(<span class="string">&#x27;.className&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;green&#x27;</span>); <span class="comment">//class选择器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    $(<span class="string">&#x27;p&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>); <span class="comment">//标签选择器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="层级选择器：可参考CSS3选择器"><a href="#层级选择器：可参考CSS3选择器" class="headerlink" title="层级选择器：可参考CSS3选择器"></a>层级选择器：可参考CSS3选择器</h3><pre><code>&lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;啊这&lt;/div&gt;
    &lt;p&gt;不错&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    $(&#39;.wrapper p&#39;).css(&#39;color&#39;, &#39;green&#39;);
&lt;/script&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 属性选择器：</span><br><span class="line">```javascript</span><br><span class="line">    &lt;div name=&quot;t&quot;&gt;不错&lt;/div&gt;</span><br><span class="line">    &lt;div title=&quot;j&quot;&gt;就这&lt;/div&gt;</span><br><span class="line">    &lt;div title=&quot;j-t&quot;&gt;啊这&lt;/div&gt;</span><br><span class="line">    &lt;div title=&quot;jr&quot;&gt;棒&lt;/div&gt;</span><br><span class="line">    &lt;div title=&quot;ttj&quot;&gt;强&lt;/div&gt;</span><br><span class="line">    &lt;div title=&quot;qgrp&quot;&gt;加油&lt;/div&gt;</span><br><span class="line">    &lt;div title=&quot;qgp&quot;&gt;冲&lt;/div&gt;</span><br><span class="line">    &lt;p id=&quot;xyq&quot;&gt;很好&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(&#x27;[name]&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;); //选择所有带name属性的元素</span><br><span class="line">        $(&#x27;[title=j]&#x27;).css(&#x27;background&#x27;, &#x27;green&#x27;); //选择title属性值为j的元素</span><br><span class="line">        $(&#x27;div[title!=j]&#x27;).css(&#x27;background&#x27;, &#x27;blue&#x27;); //选择有title属性值不为j的元素   </span><br><span class="line">        $(&#x27;div[title|=j]&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;); //选择有title属性值以j前缀开始（- 隔开的）的元素   j-</span><br><span class="line">        $(&#x27;div[title^=j]&#x27;).css(&#x27;background&#x27;, &#x27;yellow&#x27;); //选择有title属性值以j开始的元素</span><br><span class="line">        $(&#x27;div[title$=j]&#x27;).css(&#x27;background&#x27;, &#x27;hotpink&#x27;); //选择有title属性值以j结束的元素</span><br><span class="line">        $(&#x27;div[title*=gr]&#x27;).css(&#x27;background&#x27;, &#x27;purple&#x27;); //选择有title属性值包含gr字符串的元素</span><br><span class="line">        $(&#x27;div[title~=gr]&#x27;).css(&#x27;background&#x27;, &#x27;purple&#x27;); //选择有title属性值包含gr单词（单词之间用空格隔开）的元素</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="基础过滤选择器"><a href="#基础过滤选择器" class="headerlink" title="基础过滤选择器"></a><a href="https://www.jquery123.com/category/selectors/basic-filter-selectors/">基础过滤选择器</a></h3><h3 id="DOM操作："><a href="#DOM操作：" class="headerlink" title="DOM操作："></a><a href="https://www.jquery123.com/category/manipulation/">DOM操作</a>：</h3><p>腾讯云<br>对象存储</p>
<h2 id="自定义插件："><a href="#自定义插件：" class="headerlink" title="自定义插件："></a>自定义插件：</h2><h3 id="1-给jquery对象本身扩展方法"><a href="#1-给jquery对象本身扩展方法" class="headerlink" title="1 .给jquery对象本身扩展方法"></a>1 .给jquery对象本身扩展方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.extend( &#123;</span><br><span class="line">    函数名：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        函数体    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用：$.函数名();</p>
<h3 id="2-给jquery-DOM对象扩展方法"><a href="#2-给jquery-DOM对象扩展方法" class="headerlink" title="2. 给jquery DOM对象扩展方法"></a>2. 给jquery DOM对象扩展方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.extend( &#123;</span><br><span class="line">    函数名：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//$(this)指向调用该方法的对象</span></span><br><span class="line">        $(<span class="built_in">this</span>).jquery方法;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> $(<span class="built_in">this</span>);<span class="comment">//满足链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 或者：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.函数名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">//$(this)指向调用该方法的对象</span></span><br><span class="line">       $(<span class="built_in">this</span>).jquery方法;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> $(<span class="built_in">this</span>);<span class="comment">//满足链式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用：<br> $(dom对象).函数名();</p>
<p>attr 方法和 prop 方法都是用来设置属性值的，区别在于 attr 方法用于设置一般属性，而 prop 用来设置特殊属性。如果是自定义属性，使用 attr 方法来进行设置。当然，设置自定义属性，还可以使用 jquery 中提供的 data 方法。</p>
<p>hide（）方法可以隐藏元素<br>show() 方法可以展示元素<br>hover() 方法可以设置hover 需传递两个参数，是两个函数，第一个函数处理·移入，第二个函数处理移出</p>
<p>user-select:none；禁止选中 CSS</p>
<p>$(dom).load(html页面) ：可以在一个页面中加载其他页面</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5新增</title>
    <url>/135xyq.github.io/2021/12/31/h5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="HTML5-基础"><a href="#HTML5-基础" class="headerlink" title="HTML5 基础"></a>HTML5 基础</h1><hr>
<h2 id="input："><a href="#input：" class="headerlink" title="input："></a>input：</h2><p>placeholder：输入框提示</p>
<h3 id="type里面新增加的类型：（有兼容性问题，不推荐使用）"><a href="#type里面新增加的类型：（有兼容性问题，不推荐使用）" class="headerlink" title="type里面新增加的类型：（有兼容性问题，不推荐使用）"></a>type里面新增加的类型：（有兼容性问题，不推荐使用）</h3><ul>
<li>date:可以选择日期（兼容性不好）;</li>
<li>time:时间；week：星期；</li>
<li>datetime-local:可以选择日期时间；</li>
<li>number：只能填写数字 color：填颜色。</li>
</ul>
<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p><code>contenteditable=&quot;true&quot;</code> ：可修改元素的内容（可以继承）（没有兼容性问题）</p>
<p><code>draggable = &quot;true&quot;</code> :元素可拖拽（大部分元素默认为false，其中a标签img标签默认为true） （只有Chrome和Safari支持）</p>
<h3 id="拖拽周期：推拽开始，拖拽进行时，拖拽结束"><a href="#拖拽周期：推拽开始，拖拽进行时，拖拽结束" class="headerlink" title="拖拽周期：推拽开始，拖拽进行时，拖拽结束"></a>拖拽周期：推拽开始，拖拽进行时，拖拽结束</h3><h4 id="涉及事件："><a href="#涉及事件：" class="headerlink" title="涉及事件："></a>涉及事件：</h4><ul>
<li>拖拽开始（dragstart）,按下物体的瞬间不会触发事件，必须移动</li>
<li>拖拽移动事件（drag）,移动的时候触发</li>
<li>拖拽结束时间（dragend），结束时间<h4 id="拖拽目标事件："><a href="#拖拽目标事件：" class="headerlink" title="拖拽目标事件："></a>拖拽目标事件：</h4></li>
<li>dragenter：当拖拽进入目标区域时，不是元素图形进入触发，而是拖拽的鼠标进入才会触发</li>
<li>dragover：在拖拽目标的范围内移动触发(想要阻止元素回到默认位置，必须在这设置阻止默认事件)</li>
<li>dragleave：离开拖拽目标触发</li>
<li>dragdrop: 必须在dragover事件下阻止默认事件才会触发（e.preventDefault()）</li>
</ul>
<p>拖拽的时候元素会脱离文档结构，放回去的时候在恢复。</p>
<p><code>dataTransfer.effectAllowed</code>:可以改变拖拽时指针的样式（必须写在draggstart里，兼容性不行)</p>
<p><code>e.dataTransfer.effectAllowed = 样式</code></p>
<p><code>dataTransfer.dropEffect</code>:可以改变拖拽松手时指针的样式（必须写在drop里，兼容性不行）</p>
<p><code>e.dataTransfer.dropEffect = 样式</code></p>
<h2 id="canvas："><a href="#canvas：" class="headerlink" title="canvas："></a><a href="https://www.runoob.com/w3cnote/html5-canvas-intro.html">canvas</a>：</h2><p>canvas要在js中开始操作画图。<br>canvas设置画板的大小需要在行间设置</p>
<h3 id="canvas中画笔方法："><a href="#canvas中画笔方法：" class="headerlink" title="canvas中画笔方法："></a>canvas中画笔方法：</h3><p><code>画板.getContext(&quot;2d&quot;) : 生成一个画笔</code><br>moveTo（x,y）:画笔开始的的位置<br>lineTo（x,y）：下一笔要到的地方<br>lineWidth：设置画笔画出来线条的宽度（每个画笔画出来的图形苦读一样）<br>beginPath ：开启一个新的路径<br>closePath ：自动闭合所画的图形（闭合当前这一个路径）<br>stroke ： 将画笔的轨迹写到画板上（即展示画的图形）<br>fill : 将图形的内容区填满（会自动闭合图形）<br>clearRect（起始X，起始Y，矩形的宽，矩形的高）:清除这个矩形框的内容（相当于橡皮擦）</p>
<h3 id="canvas画矩形："><a href="#canvas画矩形：" class="headerlink" title="canvas画矩形："></a>canvas画矩形：</h3><ol>
<li>一笔一笔的画</li>
<li>rect（起始X，起始Y，矩形的宽，矩形的高）:一个矩形</li>
<li>strokeRect(起始X，起始Y，矩形的宽，矩形的高):一个只有边框的矩形</li>
<li>fillRect（起始X，起始Y，矩形的宽，矩形的高）：有填充内容的矩形</li>
</ol>
<h3 id="canvas画圆形，圆弧："><a href="#canvas画圆形，圆弧：" class="headerlink" title="canvas画圆形，圆弧："></a>canvas画圆形，圆弧：</h3><p>参数：圆心（x,y），半径(r)，弧度（开始弧度start，结束弧度end，必须以π（Math.PI）为单位 例 Math.PI* 2 : 360度），方向（顺时针，逆时针，顺时针写为0，逆时针为1）</p>
<p>arc（x,y,r,开始弧度,结束弧度,方向）：方法</p>
<h3 id="canvas画圆角矩形："><a href="#canvas画圆角矩形：" class="headerlink" title="canvas画圆角矩形："></a>canvas画圆角矩形：</h3><h4 id="画一条带弧的线："><a href="#画一条带弧的线：" class="headerlink" title="画一条带弧的线："></a>画一条带弧的线：</h4><p>参数：线直线部分的结束坐标（x,y），线的结束部分弧的方向（需填写一个坐标表示延伸方向，只提供方向参考），圆弧的大小</p>
<p>arcTo（x,y，弧所延伸方向的坐标，圆弧的大小）：画出一条线</p>
<p><strong>注意</strong>：四条线就可画出圆角矩形，画笔的起始位置应该为矩形的弧形大小预留出一定的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//画一个弧度为10px 起始位置位（100 100），宽高为100的圆角矩形</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">110</span>);</span><br><span class="line">        ctx.arcTo(<span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">10</span>);</span><br><span class="line">        ctx.arcTo(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">        ctx.arcTo(<span class="number">200</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">        ctx.arcTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">10</span>);</span><br><span class="line">        ctx.stroke();</span><br></pre></td></tr></table></figure>
<h3 id="贝塞尔曲线："><a href="#贝塞尔曲线：" class="headerlink" title="贝塞尔曲线："></a>贝塞尔曲线：</h3><p>二次贝塞尔曲线需提供三个点，做出两条辅助线<br>三次需要四个点，三条辅助线，<br>其他类推（第一个点为画笔的起始点） </p>
<p>quadraticCurveTo（第二个点横坐标，第二个点纵坐标，第三个点横坐标，第三个点纵坐标）：二次贝塞尔曲线</p>
<p>bezierCurveTo(第二个点横坐标，第二个点纵坐标，第三个点横坐标，第三个点纵坐标,第四个点横坐标，第四个点纵坐标)：三次贝塞尔曲线</p>
<h3 id="变换："><a href="#变换：" class="headerlink" title="变换："></a>变换：</h3><p>translate（x,y）:画布的坐标系原点（对全局都有作用）<br>rotate(角度):所画图形的旋转角度（必须以π为单位），旋转中心为坐标系原点（对全局都有作用。<br>scale（x轴方向，y轴方向）：缩放图形，图形的每一个坐标点都乘以了相应的系数（对全局都有作用）<br>解决消除对全局的影响：再开始时调用save方法（），在对某一部分调用完rotate和translate方法后再次调用restore方法就可以将后面部分恢复为默认的。</p>
<h3 id="canvas改变样式："><a href="#canvas改变样式：" class="headerlink" title="canvas改变样式："></a>canvas改变样式：</h3><p>fillstyle：改变填充的颜色，<br>可以添加图片（图片从坐标原点开始渲染）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        img.src = <span class="string">&quot;../images/1.jpeg&quot;</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            <span class="keyword">var</span> bg = ctx.createPattern(img, <span class="string">&#x27;no-repeat&#x27;</span>)</span><br><span class="line">            ctx.fillStyle = bg;</span><br><span class="line">            ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加渐变-参考"><a href="#添加渐变-参考" class="headerlink" title="添加渐变  参考"></a>添加渐变  <a href="https://www.runoob.com/html/html5-canvas.html">参考</a></h3><h4 id="阴影：（默认是边框的里外都有）"><a href="#阴影：（默认是边框的里外都有）" class="headerlink" title="阴影：（默认是边框的里外都有）"></a>阴影：（默认是边框的里外都有）</h4><ul>
<li>shadowColor:添加阴影颜色</li>
<li>shadowBlur：添加阴影的大小</li>
<li>shadowOffsetX：阴影水平方向平移</li>
<li>shadowOffsetY：阴影垂直方向平移</li>
</ul>
<h4 id="线段样式（在线的两端添加样式）："><a href="#线段样式（在线的两端添加样式）：" class="headerlink" title="线段样式（在线的两端添加样式）："></a>线段样式（在线的两端添加样式）：</h4><ul>
<li>lineCap属性：在两端加一个图形，为扩大线段的长度（值为round表示加一个半圆，）</li>
<li>lineJoin属性：两个线相交时的样式</li>
</ul>
<h4 id="canvas绘制文字："><a href="#canvas绘制文字：" class="headerlink" title="canvas绘制文字："></a>canvas绘制文字：</h4><p>strokeText（文字，开始横坐标，开始纵坐标）：文字描边（空心字体）</p>
<p>fillText（文字，开始横坐标，开始纵坐标）：文字填充，（实心字体）可以用fillstyle改变字体颜色</p>
<h2 id="svg"><a href="#svg" class="headerlink" title="svg:"></a><a href="https://www.runoob.com/svg/svg-tutorial.html">svg</a>:</h2><p>svg适合矢量图，放大不会失真，适合大面积的贴图，通常动画较简单（标签和CSS绘画）<br>canvas适合用于小面积的绘图，适合动画（JS去画）</p>
<h3 id="画直线："><a href="#画直线：" class="headerlink" title="画直线："></a>画直线：</h3><p>在SVG标签里使用line标签有四个属性x1,y1,x2,y2分别代表开始位置坐标和结束位置坐标，画完之后要在css中为他们设置stroke属性</p>
<h3 id="画矩形："><a href="#画矩形：" class="headerlink" title="画矩形："></a>画矩形：</h3><p>在SVG里用标签rect标签，属性width，height，x,y,rx,ry,分别表示矩形的宽，高，起始位置的横纵坐标，圆角的宽高</p>
<h4 id="画圆："><a href="#画圆：" class="headerlink" title="画圆："></a>画圆：</h4><p>在SVG里用标签circle</p>
<h4 id="画椭圆："><a href="#画椭圆：" class="headerlink" title="画椭圆："></a>画椭圆：</h4><p>在SVG里用ellipse标签</p>
<h4 id="画折线："><a href="#画折线：" class="headerlink" title="画折线："></a>画折线：</h4><p>在SVG里用polyline标签，默认闭合<br>解决默认填充的可以在css中将fill值改为transparent</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>lodash的基本语法</title>
    <url>/135xyq.github.io/2022/01/20/js%E5%B7%A5%E5%85%B7%E5%BA%93-lodash%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a><a href="https://javasoho.com/lodash/docs/4.16.1.html">lodash</a></h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">//chunk()   把数组拆分成一个二维数组，拆分后的第1个数组的长度为第二个参数的值</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.chunk([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], <span class="number">2</span>));  <span class="comment">//[[&quot;a&quot;, &quot;b&quot;],[&quot;c&quot;, &quot;d&quot;]]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//compact() 过滤掉原数组里的非真（转布尔值后为false）数据</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">undefined</span>]));  <span class="comment">//[1, 2, 3]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//concat()  合并数组，与Array对象的方法一样</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//difference()  在第一个数组中把第二个数组里的数据都排除掉</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.difference([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">3</span>, <span class="number">7</span>])); <span class="comment">// [1, 5, 9]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//differenceBy  与上面的方法一样，只不过它可以再接收一个迭代器的函数做为参数</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.differenceBy([<span class="number">3.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>], [<span class="number">4.4</span>, <span class="number">2.5</span>], <span class="built_in">Math</span>.floor));   <span class="comment">//[3.1, 1.3]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//differenceWith()  与上面的方法一样，只不过它可以接收一个比较器的函数做为参数，对每个数据都要比较一下</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span> &#125;, &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">1</span> &#125;];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.differenceWith(objects, [&#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span> &#125;], _.isEqual));    <span class="comment">//[&#123; &#x27;x&#x27;: 2, &#x27;y&#x27;: 1 &#125;]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//drop()    切掉数组的前n（第二个参数，默认为1）位</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.drop([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="number">2</span>));  <span class="comment">//[&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//dropRight()   切割数组，切掉数组的后n位</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//dropWhile()   去掉数组中，从起点到第二个方法返回假的数据。与Array对象身上的filter()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//dropRightWhile()  与上面一样，不过它是从右边开始查，查到返回假的那个数据都去除</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//take()    提取数组的前n（第二个参数，默认为1）位。与drop方法相反</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.take([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line"><span class="comment">//takeRight()/takeWhile()/takeRightWhile()  与上面的一样</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//fill()    填充数组，与Array对象身上的fill()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//findIndex()   查找到第一个满足条件的数据的索引值（从左往右查），没找到返回-1。与Array对象身上的findIndex()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//findLastIndex()   这与上面的findIndex是一样的，区别是它是从右往左的查</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//flatten() 减少一级数组嵌套深度，与Array的flat()这个方法相似</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.flatten([<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>]]]]));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//flattenDeep() 把数组递归为一维数组。相当于[].flat(Infinity)</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.flattenDeep([<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>]]]])); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//flattenDepth()    减少n（第二个参数）层数组的嵌套。相当于[].flat(2)</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.flattenDepth([<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>]]]], <span class="number">2</span>)); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//fromPairs()   把数组转换为一个对象，与Object.fromEntries()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//head()/first()    获取数组里第一个元素，就是取下标为0的那个数据</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//last()    取数组里的最后一位数据，取下标为length-1的那个数据</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//indexOf() 查找数据，并返回数据对应的索引值，与Array对象身上的indexOf()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//lastIndexOf() 查找数据，并返回数据对应的索引值，与Array对象身上的lastIndexOf()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//initial() 获取数组里除了最后一位的所有数据。相当于删除数组里的最后一个数据，与Array对象身上的pop()方法一样。区别在于pop方法会改变原数组，而这个方法不会改变原数组</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//tail()    获取除了array数组第一个元素以外的全部元素，想当于Array对象身上的shift()，与initial()相反</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//intersection()    取数组的交集</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.intersection([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]));    <span class="comment">//[&#x27;b&#x27;]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//union()   取数组的并集（合并起来，去掉重复的）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.union([<span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]));  <span class="comment">//[2, 1]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//xor() 删除数组的交集，留下非交集的部分</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.xor([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])); <span class="comment">//[&quot;a&quot;, &quot;c&quot;, &quot;e&quot;]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//join()    把数组转成字符串，这个方法原生的Array对象也有</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//nth() 取数组里的某个数据，就是通过下标取到某个数据。只不过它的数字可以为负。表示倒着找</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.nth(array, <span class="number">1</span>),    <span class="comment">//b</span></span><br><span class="line">            </span><br><span class="line">_.nth(array, -<span class="number">3</span>),   <span class="comment">//c</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//以下这几个方法，用后面remove的方法代替</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//pull()    根据给的参数（参数为数据）删除原数组里的对应数据</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//pullAll() 与上面的方法一样，就是参数为数组（好比call,apply这两个方法）</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//pullAllBy()\pullAllWith() 与前面方面的语法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//pullAt()  根据给的参数（参数为索引）删除原数组里的对应数据</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//remove()  根据函数删除原数组里的数据</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">        </span><br><span class="line">_.remove(arr, <span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> index &gt; <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//without() 根据给的参数（参数为数据）删除原数组里的对应数据</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.without(arr, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">arr</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//reverse() 颠倒数组，这个方法原生的Array对象也有</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//slice()   截取数组，这个方法原生的Array对象也有</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//uniq()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.uniq([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]));  <span class="comment">//[1, 2]</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//uniqBy()/uniqWith() 与前面的一样</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//zip() 把各数组中索引值相同的数据放到一起，组成新数组</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.zip([<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;小刚&#x27;</span>], [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>], [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]));  <span class="comment">//[[&quot;小明&quot;, &quot;男&quot;, 12],[&quot;小红&quot;, &quot;女&quot;, 13],[&quot;小刚&quot;, &quot;男&quot;, 14]]</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//zipObject()   与上面方法一样，区别是它输出的是对象</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.zipObject([<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;小刚&#x27;</span>], [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>], [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]));    <span class="comment">//&#123;小明: &quot;男&quot;, 小红: &quot;女&quot;, 小刚: &quot;男&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//zipWith()</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//unzip()   这个方法与zip相反，把每个数组里索引值一样的数据放在一起</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.unzip([[<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">12</span>],[<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">13</span>],[<span class="string">&quot;小刚&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">14</span>]]));    <span class="comment">//[[&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;], [&#x27;男&#x27;, &#x27;女&#x27;, &#x27;男&#x27;], [12, 13, 14]]</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//unzipWith()   与zipWidth()一样，接收了一个迭代器的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">//countBy() 按照一定规则统计数量，key循环次数，value为匹配到的数量</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.countBy([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], <span class="string">&#x27;length&#x27;</span>));  <span class="comment">//&#123;3: 2, 5: 1&#125;  按每个字符串的length进行统计，length为3的有两个数据。length为5的有1个数据</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//groupBy() 按照一定规则进行分组，key为循环次数，value为匹配到的数组</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.groupBy([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], <span class="string">&#x27;length&#x27;</span>));  <span class="comment">//&#123;3: [&quot;one&quot;, &quot;two&quot;], 5: [&quot;three&quot;]&#125;</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//each()/forEach()  循环，与原生Array.forEach一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//eachRight()/forEachRight()    倒着循环</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//every()   与原生Array.every方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//filter()  过滤数组，与Array对象上的filter()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//find()    查找数据，与Array对象上的find()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//findLast()    与上面一样，区别在于它是从右往左查</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//flatMap()     生成一个扁平化的数组，与原生的flatMap()方法一样        </span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//flatMapDeep() 与上面一样，不过它可以递归</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//flatMapDepth()    与上面一样，它可以递归，并且可以指定递归的深度</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//includes()    与Array对象上的includes()方法一样</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//invokeMap()   使用第二个参数（方法）去处理数组，返回处理后的结果（数组）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.invokeMap([[<span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]], <span class="string">&#x27;sort&#x27;</span>),    <span class="comment">//[ [1, 5, 7],[1, 2, 3]]</span></span><br><span class="line">            </span><br><span class="line">_.invokeMap([<span class="number">123</span>, <span class="number">456</span>], <span class="built_in">String</span>.prototype.split, <span class="string">&#x27;&#x27;</span>),    <span class="comment">//[[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;],[&quot;4&quot;, &quot;5&quot;, &quot;6&quot;]]</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//keyBy()   创建一个对象，里面的key由第二个参数决定。value为原数组里对应的那条数据</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> array = [</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;dir&#x27;</span>: <span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">97</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;dir&#x27;</span>: <span class="string">&#x27;right&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">100</span> &#125;</span><br><span class="line">        </span><br><span class="line">];</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> result = _.keyBy(array, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(o.code); <span class="comment">//key为使用fromCharCode解析后的字符。value为它所在数组里的那条数据</span></span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//key为dir，value为key所在原数组里的那条数据</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.keyBy(array, <span class="string">&#x27;dir&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//orderBy() 排序，既能升序又能降序</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;fred&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">48</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;barney&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">34</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;fred&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">40</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;barney&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">36</span> &#125;</span><br><span class="line">        </span><br><span class="line">];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.orderBy(users, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;asc&#x27;</span>), <span class="comment">//以age属性的值进行升序排序</span></span><br><span class="line">            </span><br><span class="line">_.orderBy(users, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>),   <span class="comment">//以user属性的值进行降序排序</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//sortBy()      排序，只能升序</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.sortBy(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> o.user;</span><br><span class="line">            </span><br><span class="line">&#125;),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//partition()   根据第2个参数把一个数组分拆成一个二维数组</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;barney&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">36</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;fred&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">40</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;pebbles&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        </span><br><span class="line">];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.partition(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;   <span class="comment">//active为true的放在一起，active为false的放在一起</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> o.active;</span><br><span class="line">            </span><br><span class="line">&#125;),</span><br><span class="line">            </span><br><span class="line">_.partition(users, &#123; <span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">false</span> &#125;),<span class="comment">//把第二个参数对应的数据放一起，其余的放一起</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line"><span class="comment">//reduce()  与Array对象上的reduce()方法一样</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//reduceRight() 与Array对象上的reduceRight()方法一样</span></span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line"><span class="comment">//reject()</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;barney&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">36</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">            </span><br><span class="line">&#123; <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;fred&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">40</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        </span><br><span class="line">];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.reject(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> o.active;    <span class="comment">//barney</span></span><br><span class="line">            </span><br><span class="line">&#125;),</span><br><span class="line">            </span><br><span class="line">_.reject(users, &#123; <span class="string">&#x27;age&#x27;</span>: <span class="number">36</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">false</span> &#125;),    <span class="comment">//fred</span></span><br><span class="line">            </span><br><span class="line">_.reject(users, [<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;fred&#x27;</span>]),  <span class="comment">//barney</span></span><br><span class="line">            </span><br><span class="line">_.reject(users, <span class="string">&#x27;age&#x27;</span>), <span class="comment">//[]</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//sample()  从数组中随机取一个数据</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.sample([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//sampleSize()  获得 n 个随机数据</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.sampleSize([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//shuffle() 随机排序</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(_.shuffle([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//size()    返回集合长度</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">_.size([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]),  <span class="comment">//5</span></span><br><span class="line">            </span><br><span class="line">_.size(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;), <span class="comment">//2</span></span><br><span class="line">            </span><br><span class="line">_.size(<span class="string">&#x27;kaivon&#x27;</span>),   <span class="comment">//6</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//some()    与Array对象上的some()方法一样</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//defer()   推迟调用函数，在第二次事件循环的时候调用 </span></span><br><span class="line">    _.defer(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;, <span class="string">&#x27;第二次事件循环&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一次事件循环&#x27;</span>);</span><br><span class="line">    <span class="comment">//delay()</span></span><br><span class="line">    _.delay(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="string">&#x27;延迟一秒执行&#x27;</span>);</span><br><span class="line">    <span class="comment">//flip()    调用函数时翻转参数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fn1 = _.flip(fn1);</span><br><span class="line">    fn1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//negate()  结果取反函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(_.filter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], _.negate(fn2))); <span class="comment">//[1, 3, 5]</span></span><br><span class="line">    <span class="comment">//once()    函数只能调用一次</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fn3&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newFn3 = _.once(fn3);</span><br><span class="line">    newFn3();</span><br><span class="line">    newFn3();</span><br></pre></td></tr></table></figure>

<h2 id="Lang"><a href="#Lang" class="headerlink" title="Lang"></a>Lang</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//castArray()   强制转为数组，其实就是在外面加一层方括号</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.castArray(<span class="string">&#x27;a&#x27;</span>), <span class="comment">//[&quot;a&quot;]</span></span><br><span class="line">    _.castArray(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;), <span class="comment">//[&#123;a: 1, b: 2&#125;]</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//clone()   浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.clone(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2);</span><br><span class="line">obj2.b.c = <span class="number">3</span>, <span class="built_in">console</span>.log(obj1, obj2);</span><br><span class="line"><span class="comment">//cloneDeep()   深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj3 = _.cloneDeep(obj1);</span><br><span class="line">obj3.b.c = <span class="number">4</span>, <span class="built_in">console</span>.log(obj1, obj3);</span><br><span class="line"><span class="comment">//conformsTo()  通过第二个参数来检测对象的属性值是否满足条件</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.conformsTo(object, &#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), <span class="comment">//true</span></span><br><span class="line">    _.conformsTo(object, &#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), <span class="comment">//false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//ea()  比较两个值是否相等。与Object.is()这个方法一样</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.eq(<span class="number">12</span>, <span class="number">12</span>), <span class="comment">//true</span></span><br><span class="line">    _.eq(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    &#125;), <span class="comment">//false</span></span><br><span class="line">    _.eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>), <span class="comment">//true</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//gt()  第一个值是否大于第二个值</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.gt(<span class="number">3</span>, <span class="number">1</span>), <span class="comment">//true</span></span><br><span class="line">    _.gt(<span class="number">3</span>, <span class="number">3</span>), <span class="comment">//false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//gte() 第一个值是否大于等于第二个值</span></span><br><span class="line"><span class="comment">//lt()  小于</span></span><br><span class="line"><span class="comment">//lte() 小于等于</span></span><br><span class="line"><span class="comment">//isArray()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), <span class="comment">//true</span></span><br><span class="line">    _.isArray(<span class="built_in">document</span>.body.children), <span class="comment">//false</span></span><br><span class="line">    _.isObject(&#123;&#125;), <span class="comment">//true</span></span><br><span class="line">    _.isObject(<span class="literal">null</span>), <span class="comment">//false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//toArray()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.toArray(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;), <span class="comment">//[1, 2]</span></span><br><span class="line">    _.toArray(<span class="string">&#x27;abc&#x27;</span>), <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">    _.toArray(<span class="literal">null</span>), <span class="comment">//[]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//assign()  合并对象，与Object.assign()方法一样</span></span><br><span class="line"><span class="comment">//assignIn()/extend()   与上面一样，不过它能继承原型身上的属性</span></span><br><span class="line"><span class="comment">//assignInWith()/extendWith()   与上面一样，接收一个比较器的函数做为参数</span></span><br><span class="line"><span class="comment">//assignWith()  也是接收一个比较器的函数做为参数</span></span><br><span class="line"><span class="comment">//at()  根据传入的属性创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: [&#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.at(object, [<span class="string">&#x27;a[0].b.c&#x27;</span>, <span class="string">&#x27;a[1]&#x27;</span>])); <span class="comment">//[3, 4]</span></span><br><span class="line"><span class="comment">//create()  与Object.create()一样</span></span><br><span class="line"><span class="comment">//defaults()    合并对象，与assign()一样，不过assign方法合并时遇到相同的属性，后面的会覆盖前面的。defaults刚好相反，前面的覆盖后面的</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.defaults(&#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span></span><br><span class="line">    &#125;), <span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br><span class="line">    _.assign(&#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span></span><br><span class="line">    &#125;), <span class="comment">//&#123;a: 3, b: 2&#125;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//defaultsDeep()    与defaults一致，不过它会深递归</span></span><br><span class="line"><span class="comment">//toPairs()/entries()   把对象里可枚举的属性(不包括继承的)创建成一个数组，与Object.entities()的方法一样</span></span><br><span class="line"><span class="comment">//toPairsIn()/entriesIn()   与上面的一样，但它包括继承的属性</span></span><br><span class="line"><span class="comment">//findKey() 与前面讲的find方法一样，只不过它返回的是key</span></span><br><span class="line"><span class="keyword">var</span> users = &#123;</span><br><span class="line">    <span class="string">&#x27;barney&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">36</span>,</span><br><span class="line">        <span class="string">&#x27;active&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;fred&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="string">&#x27;active&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;pebbles&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;active&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.findKey(users, &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;active&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;)); <span class="comment">//pebbles</span></span><br><span class="line"><span class="comment">//findLastKey() 与上面一样，只不过它从反方向开始遍历</span></span><br><span class="line"><span class="comment">//forIn()   与原生 的for...in循环一样，只不过它是一个函数，语法与forEach一样。它遍历的是自己的属性与继承的属性</span></span><br><span class="line"><span class="comment">//forInRight()  与上面一样，只不过是反方向遍历</span></span><br><span class="line"><span class="comment">//forOwn()  与forIn()一样，只不过forOwn只能遍历到自己的属性</span></span><br><span class="line"><span class="comment">//forOwnRight() 与上面一样，只不过是反方向遍历</span></span><br><span class="line"><span class="comment">//functions()/functionsIn() 这两个没有说？？？？？？</span></span><br><span class="line"><span class="comment">//get() 获取属性的值，与Object.defineProperty() 属性描述对象上的get方法一致</span></span><br><span class="line"><span class="comment">//set() 设置属性的值，与Object.defineProperty() 属性描述对象上的set方法一致</span></span><br><span class="line"><span class="comment">//setWith() 与上面的一样，只不过可以给一个参数决定返回的是对象还是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(_.setWith(&#123;&#125;, <span class="string">&#x27;[0][1]&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="built_in">Array</span>));</span><br><span class="line"><span class="comment">//has() 检查属性是否为对象的直接属性，与Object.hasOwnProperty()方法返回true一样</span></span><br><span class="line"><span class="comment">//hasIn()   检查属性是对象的直接属性还是继承属性，也与Object.hasOwnProperty()一样，true表示直接属性，false表示继承属性</span></span><br><span class="line"><span class="comment">//invert()  把对象的key与value颠倒，后面的属性会覆盖前面的属性</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.invert(object)); <span class="comment">//&#123;1: &quot;c&quot;, 2: &quot;b&quot;&#125;</span></span><br><span class="line"><span class="comment">//invertBy()    与上面一样，它遇到相同的值后不会覆盖，而是会把所有放在一个数组里。另外它多了一个遍历器方法</span></span><br><span class="line"><span class="comment">//invoke()  调用方法去处理取到的属性值</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: [&#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;c&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.invoke(object, <span class="string">&#x27;a[0].b.c.slice&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>)); <span class="comment">//[2, 3]    用slice方法去截取a[0].b.c的1-3位</span></span><br><span class="line"><span class="comment">//keys()    把对象的key放到一个数组里，与Object.keys()的方法一样</span></span><br><span class="line"><span class="comment">//keysIn()  与上面一样，只不过它包含继承到的属性</span></span><br><span class="line"><span class="comment">//values()  把对象的value放到一个数组里，与Object.value()的方法一样</span></span><br><span class="line"><span class="comment">//valuesIn()    与上面一样，只不过它包含继承到的属性</span></span><br><span class="line"><span class="comment">//mapKeys() 修改对象的key，value不会变</span></span><br><span class="line"><span class="keyword">var</span> result = _.mapKeys(&#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key + value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//&#123;a1: 1, b2: 2&#125;</span></span><br><span class="line"><span class="comment">//mapValues()   与上个方法一样，只不过它修改的是value，key不会变</span></span><br><span class="line"><span class="comment">//merge()   它与assign一样，不过它遇到相同的属性名后并不会覆盖，它会合并</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: [&#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> other = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: [&#123;</span><br><span class="line">        <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.merge(object, other));</span><br><span class="line"><span class="comment">//mergeWith()   与上面的方法一致，不过多了接收一个比较器的函数做为参数</span></span><br><span class="line"><span class="comment">//omit()    删除对象里的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(_.omit(&#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span></span><br><span class="line">&#125;, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])); <span class="comment">//&#123;b: &quot;2&quot;&#125;</span></span><br><span class="line"><span class="comment">//_.omitBy  与上面一样，不过是接收一个迭代器的函数做为参数</span></span><br><span class="line"><span class="comment">//pick()    筛选对象里的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(_.pick(&#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span></span><br><span class="line">&#125;, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])); <span class="comment">//&#123;a: 1, c: 3&#125;</span></span><br><span class="line"><span class="comment">//pickBy()  与上面一样，不过是可接收一个迭代器的函数做为参数</span></span><br><span class="line"><span class="comment">//result()  获取对象属性，它与get一样。只不过它遇到函数的属性时会调用函数，并且把this指向对象本身</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.result(obj, <span class="string">&#x27;a&#x27;</span>)); <span class="comment">//12</span></span><br><span class="line">_.result(obj, <span class="string">&#x27;b&#x27;</span>); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(_.get(obj, <span class="string">&#x27;b&#x27;</span>)); <span class="comment">//它只能取到这个函数，并不能执行</span></span><br><span class="line"><span class="comment">//toPairs() 把对象的key与value一起放到数组里</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(_.toPairs(<span class="keyword">new</span> Foo()));</span><br><span class="line"><span class="built_in">console</span>.log(_.toPairsIn(<span class="keyword">new</span> Foo()));</span><br><span class="line"><span class="comment">//unset()   删除属性</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: [&#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;c&#x27;</span>: <span class="number">7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">_.unset(object, <span class="string">&#x27;a[0].b.c&#x27;</span>), <span class="built_in">console</span>.log(object);</span><br><span class="line"><span class="comment">//update()  这个与set一样，不过它可以接收一个函数的参数</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line">_.update(object, <span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(object); <span class="comment">///&#123;a: 100&#125;</span></span><br><span class="line"><span class="comment">//updateWith()  与上面的一样，不过可以接收一个路径的参数，决定生成的属性放在哪里</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;&#125;;</span><br><span class="line">_.updateWith(object, <span class="string">&#x27;[a][b]&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;, <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(object);</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camelCase()   转换字符串为驼峰格式</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.camelCase(<span class="string">&#x27;kaivon_chen&#x27;</span>),</span><br><span class="line">    _.camelCase(<span class="string">&#x27;kaivon chen&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"><span class="comment">//capitalize()  首字母为大写</span></span><br><span class="line"><span class="built_in">console</span>.log(_.capitalize(<span class="string">&#x27;kaivon&#x27;</span>)); <span class="comment">//Kaivon</span></span><br><span class="line"><span class="comment">//endsWith()    查检结尾的字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.endsWith(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//escape()  把特殊字符转义成真正的HTML实体字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.escape(<span class="string">&#x27;ka&lt;iv&gt;on&#x27;</span>)); <span class="comment">//ka&lt;iv&gt;on</span></span><br><span class="line"><span class="comment">//unescape()    与上面相反</span></span><br><span class="line"><span class="built_in">console</span>.log(_.unescape(<span class="string">&#x27;ka&lt;iv&gt;on&#x27;</span>)); <span class="comment">//ka&lt;iv&gt;on</span></span><br><span class="line"><span class="comment">//kebabCase()   转换字符为加-的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(_.kebabCase(<span class="string">&#x27;k a i&#x27;</span>)); <span class="comment">//k-a-i</span></span><br><span class="line"><span class="comment">//lowerCase()/toLower() 转小写</span></span><br><span class="line"><span class="comment">//upperCase()/toUpper() 转大写</span></span><br><span class="line"><span class="comment">//lowerFirst()  首字符转小写</span></span><br><span class="line"><span class="comment">//upperFirst()  首字符转大写</span></span><br><span class="line"><span class="comment">//pad() 填充字符串到指定的长度(左右填充)</span></span><br><span class="line"><span class="built_in">console</span>.log(_.pad(<span class="string">&#x27;abc&#x27;</span>, <span class="number">8</span>, <span class="string">&#x27;-&#x27;</span>)); <span class="comment">//--abc---</span></span><br><span class="line"><span class="comment">//padEnd()</span></span><br><span class="line"><span class="built_in">console</span>.log(_.padEnd(<span class="string">&#x27;abc&#x27;</span>, <span class="number">8</span>, <span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"><span class="comment">//padStart()</span></span><br><span class="line"><span class="built_in">console</span>.log(_.padStart(<span class="string">&#x27;abc&#x27;</span>, <span class="number">8</span>, <span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"><span class="comment">//parseInt()    把字符串类型的数字转成数字，</span></span><br><span class="line"><span class="comment">//repeat()  重复字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(_.repeat(<span class="string">&#x27;kaivon&#x27;</span>, <span class="number">2</span>)); <span class="comment">//kaivonkaivon</span></span><br><span class="line"><span class="comment">//replace() 替换字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(_.replace(<span class="string">&#x27;kaivon&#x27;</span>, <span class="string">&#x27;von&#x27;</span>, <span class="string">&#x27;***&#x27;</span>)); <span class="comment">//kai***</span></span><br><span class="line"><span class="comment">//snakeCase()   转换字符串为_的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(_.snakeCase(<span class="string">&#x27;k a i&#x27;</span>)); <span class="comment">//k_a_i</span></span><br><span class="line"><span class="comment">//split()   分隔字符串为数组，与原生String.split()一样</span></span><br><span class="line"><span class="comment">//startCase()   转换字符串为+空格的形式，并且首字符大写</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.startCase(<span class="string">&#x27;kaivon-chen&#x27;</span>), <span class="comment">//Kaivon Chen</span></span><br><span class="line">    _.startCase(<span class="string">&#x27;kaivonChen&#x27;</span>), <span class="comment">//Kaivon Chen</span></span><br><span class="line">    _.startCase(<span class="string">&#x27;kaivon_chen&#x27;</span>), <span class="comment">//Kaivon Chen</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//startsWith()  检查字符串的开始字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.startsWith(<span class="string">&#x27;kaivon&#x27;</span>, <span class="string">&#x27;k&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//template()    编译模板</span></span><br><span class="line"><span class="keyword">var</span> compiled = _.template(<span class="string">&#x27;hello &lt;%= user %&gt;!&#x27;</span>); <span class="comment">//user为一个占位符</span></span><br><span class="line"><span class="built_in">console</span>.log(compiled(&#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;kaivon&#x27;</span></span><br><span class="line">&#125;)); <span class="comment">//拿到数据后，给user赋值，它就能正确解析出内容了</span></span><br><span class="line"><span class="comment">//trim()    去除首尾空格，或者指定字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.trim(<span class="string">&#x27;kaivon-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)); <span class="comment">//kaivon</span></span><br><span class="line"><span class="comment">//trimEnd() 去除后面的空格，或者指定字符</span></span><br><span class="line"><span class="comment">//trimStart()   与上面的一样，只不过去除的是左边的</span></span><br><span class="line"><span class="comment">//truncate()</span></span><br><span class="line"><span class="built_in">console</span>.log(_.truncate(<span class="string">&#x27;Hi kaivon! How are you feeling today? I am felling great!&#x27;</span>)); <span class="comment">//Hi kaivon! How are you feel...</span></span><br><span class="line"><span class="built_in">console</span>.log(_.truncate(<span class="string">&#x27;Hi kaivon! How are you feeling today? I am felling great!&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//&#x27;length&#x27;: 10, //限制固定的字符个数</span></span><br><span class="line">    <span class="string">&#x27;separator&#x27;</span>: <span class="regexp">/!/</span> <span class="comment">//加个正则，遇到第一个空格后就加三个点</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">//words()   把字符串的单词拆分成数组</span></span><br><span class="line"><span class="built_in">console</span>.log(_.words(<span class="string">&#x27;kaivon chen&#x27;</span>)); <span class="comment">//[&quot;kaivon&quot;, &quot;chen&quot;]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js工具库</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>mock的基本语法</title>
    <url>/135xyq.github.io/2022/01/20/js%E5%B7%A5%E5%85%B7%E5%BA%93-mock%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="mock"><a href="#mock" class="headerlink" title="mock"></a><a href="https://github.com/nuysoft/Mock/wiki">mock</a></h1><hr>
<h2 id="mock-语法规范"><a href="#mock-语法规范" class="headerlink" title="mock 语法规范"></a>mock 语法规范</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">//1. 属性值是字符串 String</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;data1|1-4&#x27;</span>: <span class="string">&#x27;谢永强&#x27;</span>,     <span class="comment">//随机重复1-4次</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;data2|3&#x27;</span>: <span class="string">&#x27;好帅&#x27;</span>,    <span class="comment">//固定重置3次</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 属性值是数字 Number</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number1|+1&#x27;</span>: <span class="number">100</span>,  <span class="comment">//整数，自动加1并且初始值为100</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number2|1-100&#x27;</span>: <span class="number">12</span>,    <span class="comment">//整数，1-100之间的随机数，包括1和100（1=&lt;数字&lt;=100）  12用来确定是数据为数字类型</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number3|1-100.5&#x27;</span>: <span class="number">12</span>,  <span class="comment">//小数，整数部分为为1-100间随机数，包括1和100；小数部分为固定5位随机数</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number4|1-100.1-10&#x27;</span>: <span class="number">12</span>,   <span class="comment">//小数，整数部分为为1-100间随机数，包括1和100；小数部分为1-10个随机数（位数随机，数字也随机）</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number5|123.1-10&#x27;</span>: <span class="number">12</span>, <span class="comment">//数字123后面随机添加1-10位小数</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number6|123.10&#x27;</span>: <span class="number">12</span>,   <span class="comment">//数字123后面固定添加10位小数，但小数的值是随机的</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 属性值是布尔型 Boolean</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;b1|1&#x27;</span>: <span class="literal">false</span>,  <span class="comment">//随机生成一个布尔值，true与false的概率各为一半</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;b2|1-5&#x27;</span>: <span class="literal">true</span>, <span class="comment">//随机生成一个布尔值，值为value的概率是min / (min + max)，值为!value的概率是max / (min + max)</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 属性值是对象 Object</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;num1|1-3&#x27;</span>: &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;, <span class="comment">//随机选取对象里1-3个属性</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;num2|2&#x27;</span>: &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;,   <span class="comment">//随机选取对象里2个属性</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//属性值是数组 Array</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;arr1|1&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],    <span class="comment">//随机选取数组里1个数据</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;arr2|1-3&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],  <span class="comment">//通过重复属性值生成一个新数组，min&lt;=重复次数&lt;=max</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//6. 属性值是函数 Function</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;result&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> &#125;  <span class="comment">//把函数的返回值当作属性的结果</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//7. 属性值是正则表达式 RegExp</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;reg1&#x27;</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;reg2&#x27;</span>: <span class="regexp">/\w\W\s\S\d\D/</span>,</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;reg3&#x27;</span>: <span class="regexp">/\d&#123;5,10&#125;/</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Mock.Random</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> Random = Mock.Random;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// console.log(Random);</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//1、Basics  基础类里的方法，共7个</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.boolean()      随机一个布尔值</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.boolean(),</span><br><span class="line">            </span><br><span class="line">Random.boolean(<span class="number">1</span>, <span class="number">9</span>, <span class="literal">true</span>),</span><br><span class="line">            </span><br><span class="line">Random.boolean(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">false</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.natural()      随机一个自然数（大于等于 0 的整数）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.natural(),</span><br><span class="line">            </span><br><span class="line">Random.natural(<span class="number">100</span>),</span><br><span class="line">            </span><br><span class="line">Random.natural(<span class="number">0</span>, <span class="number">50</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.integer()  随机一个整数（包含负数）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.integer(),</span><br><span class="line">            </span><br><span class="line">Random.integer(-<span class="number">100</span>),</span><br><span class="line">            </span><br><span class="line">Random.integer(-<span class="number">50</span>, <span class="number">50</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.float()    随机一个小数</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.float(),</span><br><span class="line">            </span><br><span class="line">Random.float(<span class="number">0</span>),</span><br><span class="line">            </span><br><span class="line">Random.float(-<span class="number">10</span>, <span class="number">10</span>),</span><br><span class="line">            </span><br><span class="line">Random.float(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>),</span><br><span class="line">            </span><br><span class="line">Random.float(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.character()    //随机一个字符</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.character(),</span><br><span class="line">            </span><br><span class="line">Random.character(<span class="string">&#x27;abc123&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Random.character(<span class="string">&#x27;lower&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Random.character(<span class="string">&#x27;symbol&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.string()   随机一个字符串</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.string(),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="number">5</span>),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="number">7</span>, <span class="number">10</span>),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="string">&#x27;symbol&#x27;</span>, <span class="number">5</span>),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="string">&#x27;abc123&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.range()    随机一个整数数据的数组</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.range(<span class="number">7</span>),</span><br><span class="line">            </span><br><span class="line">Random.range(<span class="number">3</span>, <span class="number">7</span>),</span><br><span class="line">            </span><br><span class="line">Random.range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="keyword">var</span> Random = Mock.Random;</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//2、Date    日期类里的方法，共4个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.date()     随机一个日期</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.date(),</span><br><span class="line">            </span><br><span class="line">Random.date(<span class="string">&#x27;yyyy-MM--dd : HH-m-ss&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.time()     随机一个时间</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.time(),</span><br><span class="line">            </span><br><span class="line">Random.time(<span class="string">&#x27;A HH:mm:ss:SS&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.datetime() 随机一个日期+时间</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.datetime(),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.now()  返回当前的日期和时间字符串</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//week 定到这个周的第一天</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.now(),</span><br><span class="line">            </span><br><span class="line">Random.now(<span class="string">&#x27;minute&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//3、Image   图片类里的方法，花2个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.image()    生成一个随机的图片地址</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.image(),</span><br><span class="line">            </span><br><span class="line">Random.image(<span class="string">&#x27;200x100&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Random.image(<span class="string">&#x27;200x100&#x27;</span>, <span class="string">&#x27;#ffcc33&#x27;</span>, <span class="string">&#x27;#FFF&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;kaivon&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.dataImage()    //生成一段随机的 Base64 图片编码</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line"><span class="comment">//Random.dataImage(),</span></span><br><span class="line">            </span><br><span class="line">Random.dataImage(<span class="string">&#x27;200x100&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Color 颜色类里的方法，共5个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.color()    随机一个16进制的颜色</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.color(),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.hex()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.hex(),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.rgb()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.rgb(),   <span class="comment">//随机生成一个rgb格式的颜色</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.rgba()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.rgba(),  <span class="comment">//随机生成一个rgba格式的颜色</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.hsl()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.hsl(),   <span class="comment">//随机生成一个hsl格式(色相、饱和度、亮度)的颜色</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//5、Text    文本类里的方法，共8个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.paragraph()    随机生成一段文本</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.paragraph());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.paragraph(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.paragraph(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cparagraph()   随机生成一段中文文本。</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cparagraph());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cparagraph(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cparagraph(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.sentence() 随机生成一个句子，句子首字母大写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.sentence());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.sentence(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.sentence(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.csentence()    随机生成一段中文文本</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.csentence());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.csentence(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.csentence(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.word()     随机生成一个单词</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.word());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.word(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.word(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cword()    随机生成一个汉字</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="string">&#x27;零一二三四五六七八九十&#x27;</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="string">&#x27;零一二三四五六七八九十&#x27;</span>, <span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.title()    随机生成一个标题</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.title());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.title(<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.title(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.ctitle()   随机生成一句中文标题</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ctitle());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ctitle(<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ctitle(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//6、Name    名字类里的方法，共6个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.first()    随机生成一个常见的英文名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.first())</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.last()     随机生成一个常见的英文姓</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.last());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.name()     随机生成一个常见的英文姓名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.name(<span class="literal">true</span>)); <span class="comment">//是否添加一个中间值</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cfirst()   //随机生成一个常见的中文名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cfirst());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.clast()    //随机生成一个常见的中文姓</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.clast());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cname()    随机生成一个常见的中文姓名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cname());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//7、Web Web类里的方法，共6个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.url()  //随机生成一个 URL</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.url());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.url(<span class="string">&#x27;http&#x27;</span>));    <span class="comment">//指定协议</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.url(<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;kaivon.cn&#x27;</span>));   <span class="comment">//指定域名</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.protocol()     随机生成一个 URL 协议</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.protocol());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.domain()   随机生成一个域名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.domain());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.tld()  随机生成一个顶级域名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.tld());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.email()    随机生成一个邮件地址</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.email());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.email(<span class="string">&#x27;kaivon.cn&#x27;</span>)); <span class="comment">//指定@后的域名</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.ip()   随机生成一个 IP 地址</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ip());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//8、Address 地址类里的方法，共5个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.region()   随机生成一个（中国）大区</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.region());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.province() 随机生成一个（中国）省（或直辖市、自治区、特别行政区）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.province());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.city()     随机生成一个（中国）市</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.city());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.city(<span class="literal">true</span>)); <span class="comment">//是否生成所属的省</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.county()       随机生成一个（中国）县</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.county());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.county(<span class="literal">true</span>));   <span class="comment">//指示是否生成所属的省、市</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.zip()      随机生成一个邮政编码</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.zip());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//9、Helper  帮助类里的方法，共5个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.capitalize()   //把字符串的第一个字母转换为大写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.capitalize(<span class="string">&#x27;kaivon&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.upper()    //把字符串转换为大写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.upper(<span class="string">&#x27;kaivon&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.lower()    //把字符串转换为小写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.lower(<span class="string">&#x27;KAI&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.pick()     //从数组中随机选取一个元素</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.pick([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.shuffle()  //打乱数组中元素的顺序</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.shuffle([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//10、Miscellaneous  其它类里的方法，共3个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.guid()     随机生成一个 GUID</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.guid());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.id()       随机生成一个 18 位身份证</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.id());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(<span class="string">&#x27;@EMAIL&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Mock.mock(<span class="string">&#x27;@CITY(true)&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Mock.mock(<span class="string">&#x27;@cword(&quot;谢永强好帅&quot;, 1, 3)&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//扩展方法</span></span><br><span class="line">        </span><br><span class="line">Random.extend(&#123;</span><br><span class="line">            </span><br><span class="line"><span class="attr">constellation</span>: <span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">var</span> constellations = [<span class="string">&#x27;白羊座&#x27;</span>, <span class="string">&#x27;金牛座&#x27;</span>, <span class="string">&#x27;双子座&#x27;</span>, <span class="string">&#x27;巨蟹座&#x27;</span>, <span class="string">&#x27;狮子座&#x27;</span>, <span class="string">&#x27;处女座&#x27;</span>, <span class="string">&#x27;天秤座&#x27;</span>, <span class="string">&#x27;天蝎座&#x27;</span>, <span class="string">&#x27;射手座&#x27;</span>, <span class="string">&#x27;摩羯座&#x27;</span>, <span class="string">&#x27;水瓶座&#x27;</span>, <span class="string">&#x27;双鱼座&#x27;</span>];</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.pick(constellations)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.constellation());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Mock.mock(<span class="string">&#x27;@constellation&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js工具库</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>moment工具库的简单使用</title>
    <url>/135xyq.github.io/2022/01/20/js%E5%B7%A5%E5%85%B7%E5%BA%93-moment%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="moment-官网"><a href="#moment-官网" class="headerlink" title="moment   官网"></a><a href="http://momentjs.cn/">moment</a>   <a href="https://momentjs.com/">官网</a></h1><hr>
<h2 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//解析</span></span><br><span class="line">        <span class="comment">//moment() </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment());</span><br><span class="line">        <span class="comment">//moment(String)</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2013-02-08&#x27;</span>)); <span class="comment">//返回2013年2月8号的日期对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment(<span class="string">&#x27;2013-039&#x27;</span>), <span class="comment">//返回2013年的第39天，2013年2月8号</span></span><br><span class="line">            moment(<span class="string">&#x27;2013050&#x27;</span>), <span class="comment">//返回2013年的第50天，2013年2月19号</span></span><br><span class="line">            moment(<span class="string">&#x27;2013W065&#x27;</span>), <span class="comment">//返回2013年的第6个星期的第5天，2013年2月8号（W表示星期）</span></span><br><span class="line">            moment(<span class="string">&#x27;2013-02-08T09&#x27;</span>), <span class="comment">//返回2013年2月8号9点（T表示时间）</span></span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;kaivon&#x27;</span>)); <span class="comment">//警告，同时照样能返回那个对象，不过对象里的参数的值是不正确的</span></span><br><span class="line">        <span class="comment">//moment(String) 带格式 </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&quot;12-25-1995&quot;</span>, <span class="string">&quot;MM-DD-YYYY&quot;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&quot;12/25/1995&quot;</span>, <span class="string">&quot;LL&quot;</span>));</span><br><span class="line">        <span class="comment">//moment(String) 多个格式 </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&quot;29-06-1995&quot;</span>, [<span class="string">&quot;MM-DD-YYYY&quot;</span>, <span class="string">&quot;DD-MM&quot;</span>, <span class="string">&quot;DD-MM-YYYY&quot;</span>]));</span><br><span class="line">        <span class="comment">//moment(String) 特殊格式 </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-01-01T05:06:07&quot;</span>, moment.ISO_8601));</span><br><span class="line">        <span class="comment">//moment(Object) </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(&#123;</span><br><span class="line">            <span class="attr">year</span>: <span class="number">2010</span>,</span><br><span class="line">            <span class="attr">month</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">day</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">hour</span>: <span class="number">15</span>,</span><br><span class="line">            <span class="attr">minute</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">second</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">millisecond</span>: <span class="number">123</span></span><br><span class="line">        &#125;)); <span class="comment">//注意：这里的月份也是从0开始，此时对应的是4月</span></span><br><span class="line">        <span class="comment">//moment(Number) </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="number">1318781876406</span>)); <span class="comment">//这个参数为毫秒数</span></span><br><span class="line">        <span class="comment">//unix()</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment.unix(<span class="number">1318781876406</span> / <span class="number">1000</span>)); <span class="comment">//这个参数为秒数</span></span><br><span class="line">        <span class="comment">//moment(Date)</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">9</span>, <span class="number">16</span>)));</span><br><span class="line">        <span class="comment">//moment(Number[])  参数为一个数组 [year, month, day, hour, minute, second, millisecond]</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment([<span class="number">2010</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">125</span>])); <span class="comment">//注意月份是从0开始的，这里对应的是2月</span></span><br><span class="line">        <span class="comment">//moment(JSONDate) </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&quot;/Date(1198908717056-0700)/&quot;</span>)); <span class="comment">//前面一串数字为时间戳，-后面的是时区</span></span><br><span class="line">        <span class="comment">//moment(Moment) 参数为一个moment对象，用于克隆</span></span><br><span class="line">        <span class="keyword">var</span> a = moment([<span class="number">2012</span>]);</span><br><span class="line">        <span class="keyword">var</span> b = moment(a);</span><br><span class="line">        <span class="built_in">console</span>.log(a.valueOf() === b.valueOf());</span><br><span class="line">        <span class="comment">//clone()   也可以使用clone去克隆</span></span><br><span class="line">        <span class="keyword">var</span> a = moment([<span class="number">2008</span>]);</span><br><span class="line">        <span class="keyword">var</span> b = a.clone();</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            GMT 世界时，格林尼治标准时间 </span></span><br><span class="line"><span class="comment">            UTC 协调世界时，世界统一时间、世界标准时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//utc()</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().format()); <span class="comment">//GMT //默认为本地当前时间，东八区的时间（+08:00）</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment.utc().format()); <span class="comment">//UTC       //UTC的时间（世界标准时间，位于0时区，时区用Z表示，它与北京时间相差8个小时）</span></span><br><span class="line">        <span class="comment">//isValid()</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment([<span class="number">2015</span>, <span class="number">25</span>, <span class="number">35</span>]).isValid(), <span class="comment">//false</span></span><br><span class="line">            moment([<span class="number">2015</span>, <span class="number">10</span>, <span class="number">35</span>]).invalidAt(), <span class="comment">//2</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<h2 id="赋值取值方法"><a href="#赋值取值方法" class="headerlink" title="赋值取值方法"></a>赋值取值方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(moment().seconds() === <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds()); <span class="comment">//true</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment.utc().seconds() === <span class="keyword">new</span> <span class="built_in">Date</span>().getUTCSeconds()); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//millisecond()/milliseconds()  获取或设置毫秒</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().millisecond());</span><br><span class="line">        <span class="built_in">console</span>.log(moment().milliseconds());</span><br><span class="line">        <span class="built_in">console</span>.log(moment().millisecond(<span class="number">100</span>).valueOf());</span><br><span class="line">        <span class="built_in">console</span>.log(moment().milliseconds(<span class="number">100</span>).valueOf());</span><br><span class="line">        <span class="comment">//second()/seconds()    获取/设置秒</span></span><br><span class="line">        <span class="comment">//minute()/minutes()    获取/设置分</span></span><br><span class="line">        <span class="comment">//hour()/hours()        获取/设置小时</span></span><br><span class="line">        <span class="comment">//date()/dates()        获取/设置日期</span></span><br><span class="line">        <span class="comment">//day()/days()          获取/设置星期</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment().day(), <span class="comment">//1</span></span><br><span class="line">            moment().day(<span class="string">&#x27;Sunday&#x27;</span>), <span class="comment">//设置星期的时候可以传入一个星期的英文单词</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//weekday() 根据语言环境获获取/设置星期，根据语言环境获取或设置星期几</span></span><br><span class="line">        moment.locale(<span class="string">&#x27;zh-cn&#x27;</span>); <span class="comment">//把当前的语言环境设置为中文</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment().weekday(), <span class="comment">//0 </span></span><br><span class="line">            moment().weekday(<span class="number">0</span>), <span class="comment">//0 //英文下是周日，中文下是周一</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//dayOfYear()   获取或设置年份的日期（今天是今年的第几天）</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().dayOfYear()); <span class="comment">//111</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().dayOfYear(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//week()/weeks()    获取或设置年份的星期（当前星期是今年的第几个星期）</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().week()); <span class="comment">//17</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment([<span class="number">2021</span>, <span class="number">4</span>, <span class="number">20</span>]).week()); <span class="comment">//20</span></span><br><span class="line">        <span class="comment">//month()/months()  获取或设置月份，设置时范围为0-11，还支持月份名称</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().month()); <span class="comment">//3</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().month(<span class="string">&#x27;July&#x27;</span>)); <span class="comment">//3</span></span><br><span class="line">        <span class="comment">//quarter()/quarters()  获取或设置季度</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().quarter()); <span class="comment">//2 </span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().quarter(<span class="number">4</span>)); <span class="comment">//2 </span></span><br><span class="line">        <span class="comment">//year()/years()    获取或设置年份</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().year());</span><br><span class="line">        <span class="built_in">console</span>.log(moment().year(<span class="number">2088</span>));</span><br><span class="line">        <span class="comment">//weekYear()</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment([<span class="number">2020</span>, <span class="number">0</span>, <span class="number">1</span>]).weekYear());</span><br><span class="line">        <span class="built_in">console</span>.log(moment([<span class="number">2020</span>, <span class="number">11</span>, <span class="number">31</span>]).weekYear());</span><br><span class="line">        <span class="comment">//weeksInYear() 根据语言环境获取当前 moment 年份的周数</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().weeksInYear()); <span class="comment">//52</span></span><br><span class="line">        <span class="comment">//get() 获取日期</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment().get(<span class="string">&#x27;year&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(moment().get(<span class="string">&#x27;M&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(moment().get(<span class="string">&#x27;date&#x27;</span>));</span><br><span class="line">        <span class="comment">//set() 设置日期</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment().set(<span class="string">&#x27;year&#x27;</span>, <span class="number">2030</span>),</span><br><span class="line">            moment().set(<span class="string">&#x27;month&#x27;</span>, <span class="number">8</span>),</span><br><span class="line">            moment().set(&#123;</span><br><span class="line">                <span class="string">&#x27;year&#x27;</span>: <span class="number">2008</span>,</span><br><span class="line">                <span class="string">&#x27;month&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                <span class="string">&#x27;date&#x27;</span>: <span class="number">8</span></span><br><span class="line">            &#125;),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//max() 对比多个日期，返回最大的那个日期</span></span><br><span class="line">        <span class="comment">//min() 对比多个日期，返回最小的那个日期</span></span><br><span class="line">        <span class="keyword">var</span> a = moment(<span class="string">&#x27;2019-10-15&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> b = moment(&#123;</span><br><span class="line">            <span class="attr">year</span>: <span class="number">2010</span>,</span><br><span class="line">            <span class="attr">month</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">date</span>: <span class="number">5</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> c = moment([<span class="number">2020</span>, <span class="number">10</span>, <span class="number">20</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(moment.max(a, b, c)); <span class="comment">//c</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment.min(a, b, c)); <span class="comment">//b</span></span><br></pre></td></tr></table></figure>

<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//isBefore()    检查一个时间是否在另一个时间之前，默认是都转成毫秒数进行计算</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBefore()); <span class="comment">//true  没给参数默认为现在的时间</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBefore(<span class="string">&#x27;2010-10-19&#x27;</span>)); <span class="comment">//false 第一个日期是否在第二个日期之前</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2009-10-20&#x27;</span>).isBefore(<span class="string">&#x27;2010-10-19&#x27;</span>, <span class="string">&#x27;year&#x27;</span>)); <span class="comment">//false 二个参数为对比的单位，可以给的有year month week isoWeek day hour minute second</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBefore(<span class="string">&#x27;2008-12-31&#x27;</span>, <span class="string">&#x27;month&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//isSame()  检查两个时间是否相同</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isSame(<span class="string">&#x27;2010-10-20&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isSame(<span class="string">&#x27;2010-12-20&#x27;</span>, <span class="string">&#x27;year&#x27;</span>));</span><br><span class="line">        <span class="comment">//isAfter() 检查一个时间是否在另一个时间之后</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isAfter(<span class="string">&#x27;2010-09-19&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//isSameOrBefore()  检查一个时间是否在另一个时间之前或者与之相同（&lt;=）</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isSameOrBefore(<span class="string">&#x27;2010-10-21&#x27;</span>), <span class="comment">//true</span></span><br><span class="line">            moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isSameOrBefore(<span class="string">&#x27;2010-10-20&#x27;</span>), <span class="comment">//true</span></span><br><span class="line">            moment(<span class="string">&#x27;2010-11-20&#x27;</span>).isSameOrBefore(<span class="string">&#x27;2010-10-20&#x27;</span>), <span class="comment">//false</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//isSameOrAfter() 检查一个时间是否在另一个时间之后或者与之相同（&gt;=）</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment(<span class="string">&#x27;2010-11-20&#x27;</span>).isSameOrAfter(<span class="string">&#x27;2010-10-21&#x27;</span>), <span class="comment">//true</span></span><br><span class="line">            moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isSameOrAfter(<span class="string">&#x27;2010-10-20&#x27;</span>), <span class="comment">//true</span></span><br><span class="line">            moment(<span class="string">&#x27;2010-10-19&#x27;</span>).isSameOrAfter(<span class="string">&#x27;2010-10-20&#x27;</span>), <span class="comment">//false</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//isBetween()   检查一个时间是否在其他两个时间之间</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBetween(<span class="string">&#x27;2010-10-19&#x27;</span>, <span class="string">&#x27;2010-10-25&#x27;</span>), <span class="comment">//true</span></span><br><span class="line">            moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBetween(<span class="string">&#x27;2010-10-19&#x27;</span>, <span class="literal">undefined</span>), <span class="comment">//true undefined等于moment(),就是当前的时间</span></span><br><span class="line">            moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBetween(<span class="string">&#x27;2009-10-19&#x27;</span>, <span class="string">&#x27;2012-01-01&#x27;</span>, <span class="string">&#x27;year&#x27;</span>), <span class="comment">//true</span></span><br><span class="line">            <span class="comment">//第四个参数为包容性，第三个参数为null，表示对比单位为默认毫秒数</span></span><br><span class="line">            moment(<span class="string">&#x27;2016-10-30&#x27;</span>).isBetween(<span class="string">&#x27;2016-10-30&#x27;</span>, <span class="string">&#x27;2016-12-30&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;(]&#x27;</span>), <span class="comment">//false</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//isLeapYear()  检测是否为闰年</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment().isLeapYear(), <span class="comment">//true</span></span><br><span class="line">            moment([<span class="number">2019</span>]).isLeapYear(), <span class="comment">//false</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//isMoment() 检测变量是否为moment对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.isMoment(), <span class="comment">//false</span></span><br><span class="line">            moment.isMoment(<span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="comment">//false</span></span><br><span class="line">            moment.isMoment(moment()), <span class="comment">//true</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//isDate()  检测变量是否为原生的Date对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.isDate(), <span class="comment">//false</span></span><br><span class="line">            moment.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="comment">//true</span></span><br><span class="line">            moment.isDate(moment()), <span class="comment">//false</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<h2 id="国际化、自定义方法"><a href="#国际化、自定义方法" class="headerlink" title="国际化、自定义方法"></a>国际化、自定义方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//设置语言环境 (全局) </span></span><br><span class="line">        <span class="comment">//moment.locale(&#x27;zh-cn&#x27;);</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment.locale()); <span class="comment">//en //返回当前的语言环境</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment().weekday(<span class="number">0</span>), <span class="comment">//根据语言环境获取或设置（传参）星期几。英文环境为星期天，中文环境为星期一</span></span><br><span class="line">            moment().format(<span class="string">&#x27;LLLL&#x27;</span>), <span class="comment">//格式化时间，参数为本地化格式。英文环境与中文环境都不同</span></span><br><span class="line">            moment().month(),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//设置语言环境 (局部) </span></span><br><span class="line">        <span class="keyword">var</span> myMoment = moment();</span><br><span class="line">        myMoment.locale(<span class="string">&#x27;ar-dz&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(moment().format(<span class="string">&#x27;LLLL&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(myMoment.format(<span class="string">&#x27;LLLL&#x27;</span>));</span><br><span class="line">        <span class="comment">//months()/weekdays() </span></span><br><span class="line">        <span class="comment">/* moment.locale(&#x27;ru&#x27;);</span></span><br><span class="line"><span class="comment">        moment.locale(&#x27;zh-hk&#x27;); */</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.months(),</span><br><span class="line">            moment.monthsShort(),</span><br><span class="line">            moment.weekdays(),</span><br><span class="line">            moment.weekdaysShort(),</span><br><span class="line">            moment.weekdaysMin(),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//localeData()</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.localeData(),</span><br><span class="line">            moment.localeData().monthsShort(),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//自定义</span></span><br><span class="line">        moment.updateLocale(<span class="string">&#x27;zh-cn&#x27;</span>, &#123;</span><br><span class="line">            <span class="comment">//设置月份名称</span></span><br><span class="line">            <span class="attr">months</span>: <span class="string">&#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;</span>.split(<span class="string">&#x27;_&#x27;</span>),</span><br><span class="line">            <span class="comment">//设置月分名称的缩写</span></span><br><span class="line">            <span class="attr">monthsShort</span>: <span class="string">&#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;</span>.split(<span class="string">&#x27;_&#x27;</span>),</span><br><span class="line">            <span class="comment">//设置星期名称</span></span><br><span class="line">            <span class="attr">weekdays</span>: <span class="string">&#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;</span>.split(<span class="string">&#x27;_&#x27;</span>),</span><br><span class="line">            <span class="comment">//设置星期名称的缩写</span></span><br><span class="line">            <span class="attr">weekdaysShort</span>: <span class="string">&#x27;周日_周一_周二_周三_周四_周五_周六&#x27;</span>.split(<span class="string">&#x27;_&#x27;</span>),</span><br><span class="line">            <span class="comment">//设置星期名称的最小缩写</span></span><br><span class="line">            <span class="attr">weekdaysMin</span>: <span class="string">&#x27;日_一_二_三_四_五_六&#x27;</span>.split(<span class="string">&#x27;_&#x27;</span>),</span><br><span class="line">            <span class="comment">//设置长日期格式，是个对象</span></span><br><span class="line">            <span class="attr">longDateFormat</span>: &#123;</span><br><span class="line">                <span class="attr">LT</span>: <span class="string">&#x27;Ah点mm分&#x27;</span>,</span><br><span class="line">                <span class="attr">LTS</span>: <span class="string">&#x27;Ah点m分s秒&#x27;</span>,</span><br><span class="line">                <span class="attr">L</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span>,</span><br><span class="line">                <span class="attr">LL</span>: <span class="string">&#x27;YYYY年MMMD日&#x27;</span>,</span><br><span class="line">                <span class="attr">LLL</span>: <span class="string">&#x27;YYYY年MMMD日Ah点mm分&#x27;</span>,</span><br><span class="line">                <span class="attr">LLLL</span>: <span class="string">&#x27;YYYY年MMMD日ddddAh点mm分&#x27;</span>,</span><br><span class="line">                <span class="attr">l</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span>,</span><br><span class="line">                <span class="attr">ll</span>: <span class="string">&#x27;YYYY年MMMD日&#x27;</span>,</span><br><span class="line">                <span class="attr">lll</span>: <span class="string">&#x27;YYYY年MMMD日Ah点mm分&#x27;</span>,</span><br><span class="line">                <span class="attr">llll</span>: <span class="string">&#x27;YYYY年MMMD日ddddAh点mm分&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//设置相对时间，from()与to()的方法返回的值就是从这里取的</span></span><br><span class="line">            <span class="attr">relativeTime</span>: &#123;</span><br><span class="line">                <span class="attr">future</span>: <span class="string">&#x27;%s内&#x27;</span>,</span><br><span class="line">                <span class="attr">past</span>: <span class="string">&#x27;%s前&#x27;</span>,</span><br><span class="line">                <span class="attr">s</span>: <span class="string">&#x27;几秒&#x27;</span>,</span><br><span class="line">                <span class="attr">m</span>: <span class="string">&#x27;1 分钟&#x27;</span>,</span><br><span class="line">                <span class="attr">mm</span>: <span class="string">&#x27;%d 分钟&#x27;</span>,</span><br><span class="line">                <span class="attr">h</span>: <span class="string">&#x27;1 小时&#x27;</span>,</span><br><span class="line">                <span class="attr">hh</span>: <span class="string">&#x27;%d 小时&#x27;</span>,</span><br><span class="line">                <span class="attr">d</span>: <span class="string">&#x27;1 天&#x27;</span>,</span><br><span class="line">                <span class="attr">dd</span>: <span class="string">&#x27;%d 天&#x27;</span>,</span><br><span class="line">                <span class="attr">M</span>: <span class="string">&#x27;1 个月&#x27;</span>,</span><br><span class="line">                <span class="attr">MM</span>: <span class="string">&#x27;%d 个月&#x27;</span>,</span><br><span class="line">                <span class="attr">y</span>: <span class="string">&#x27;1 年&#x27;</span>,</span><br><span class="line">                <span class="attr">yy</span>: <span class="string">&#x27;%d 年&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//设置时间段，参数：小时,分钟,大小写</span></span><br><span class="line">            <span class="attr">meridiem</span>: <span class="function"><span class="keyword">function</span>(<span class="params">hour, minute, isLower</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> hm = hour * <span class="number">100</span> + minute;</span><br><span class="line">                <span class="keyword">if</span> (hm &lt; <span class="number">600</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;凌晨&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">900</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;早上&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">1130</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;上午&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">1230</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;中午&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">1800</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;下午&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;晚上&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//设置日历</span></span><br><span class="line">            <span class="attr">calendar</span>: &#123;</span><br><span class="line">                <span class="attr">sameDay</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? <span class="string">&#x27;[今天]Ah[点整]&#x27;</span> : <span class="string">&#x27;[今天]LT&#x27;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">nextDay</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? <span class="string">&#x27;[明天]Ah[点整]&#x27;</span> : <span class="string">&#x27;[明天]LT&#x27;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">lastDay</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? <span class="string">&#x27;[昨天]Ah[点整]&#x27;</span> : <span class="string">&#x27;[昨天]LT&#x27;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">nextWeek</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> startOfWeek, prefix;</span><br><span class="line">                    startOfWeek = moment().startOf(<span class="string">&#x27;week&#x27;</span>);</span><br><span class="line">                    prefix = <span class="built_in">this</span>.diff(startOfWeek, <span class="string">&#x27;days&#x27;</span>) &gt;= <span class="number">7</span> ? <span class="string">&#x27;[下]&#x27;</span> : <span class="string">&#x27;[本####]&#x27;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? prefix + <span class="string">&#x27;dddAh点整&#x27;</span> : prefix + <span class="string">&#x27;dddAh点mm&#x27;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">lastWeek</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> startOfWeek, prefix;</span><br><span class="line">                    startOfWeek = moment().startOf(<span class="string">&#x27;week&#x27;</span>);</span><br><span class="line">                    prefix = <span class="built_in">this</span>.unix() &lt; startOfWeek.unix() ? <span class="string">&#x27;[上]&#x27;</span> : <span class="string">&#x27;[本]&#x27;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? prefix + <span class="string">&#x27;dddAh点整&#x27;</span> : prefix + <span class="string">&#x27;dddAh点mm&#x27;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">sameElse</span>: <span class="string">&#x27;LL&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">week</span>: &#123;</span><br><span class="line">                <span class="attr">dow</span>: <span class="number">1</span>, <span class="comment">//星期的第一天是周1</span></span><br><span class="line">                <span class="attr">doy</span>: <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;今天是：&#x27;</span> + moment().format(<span class="string">&#x27;MMMM&#x27;</span>) + <span class="string">&#x27; &#x27;</span> + moment().format(<span class="string">&#x27;dddd&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;今天是：&#x27;</span> + moment().format(<span class="string">&#x27;MMM&#x27;</span>) + <span class="string">&#x27; &#x27;</span> + moment().format(<span class="string">&#x27;ddd&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(moment().format(<span class="string">&#x27;LLLL&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(moment([<span class="number">2008</span>]).from());</span><br><span class="line">        <span class="built_in">console</span>.log(moment().calendar(moment([<span class="number">2020</span>, <span class="number">3</span>, <span class="number">15</span>])));</span><br></pre></td></tr></table></figure>

<h2 id="时长方法"><a href="#时长方法" class="headerlink" title="时长方法"></a>时长方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//时长</span></span><br><span class="line">        <span class="built_in">console</span>.log(moment.duration());</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.duration(<span class="number">100</span>), <span class="comment">//给一个参数表示为毫秒</span></span><br><span class="line">            moment.duration(<span class="number">2</span>, <span class="string">&#x27;seconds&#x27;</span>), <span class="comment">//时长为2s</span></span><br><span class="line">            moment.duration(<span class="number">3</span>, <span class="string">&#x27;minutes&#x27;</span>), <span class="comment">//时长为3min</span></span><br><span class="line">            moment.duration(<span class="number">1</span>, <span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">            <span class="comment">//参数也可以是一个对象</span></span><br><span class="line">            moment.duration(&#123;</span><br><span class="line">                <span class="attr">seconds</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">minutes</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">hours</span>: <span class="number">3</span>,</span><br><span class="line">                <span class="attr">days</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">weeks</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">months</span>: <span class="number">6</span>,</span><br><span class="line">                <span class="attr">years</span>: <span class="number">7</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="comment">//ASP.NET 风格的时间跨度</span></span><br><span class="line">            moment.duration(<span class="string">&#x27;23:59:59&#x27;</span>), <span class="comment">//时:分:秒</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//clone() 克隆一个时长对象</span></span><br><span class="line">        <span class="keyword">var</span> d1 = moment.duration();</span><br><span class="line">        <span class="keyword">var</span> d2 = d1.clone();</span><br><span class="line">        d1.add(<span class="number">1</span>, <span class="string">&#x27;second&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(d1, d2);</span><br><span class="line">        moment.locale(<span class="string">&#x27;zh-cn&#x27;</span>);</span><br><span class="line">        <span class="comment">//humanize()    显示一段时长</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.duration(<span class="number">1</span>, <span class="string">&#x27;minutes&#x27;</span>).humanize(),</span><br><span class="line">            moment.duration(<span class="number">24</span>, <span class="string">&#x27;hours&#x27;</span>).humanize(),</span><br><span class="line">            moment.duration(<span class="number">1</span>, <span class="string">&#x27;minutes&#x27;</span>).humanize(<span class="literal">true</span>), <span class="comment">//1 分钟内</span></span><br><span class="line">            moment.duration(-<span class="number">1</span>, <span class="string">&#x27;minutes&#x27;</span>).humanize(<span class="literal">true</span>), <span class="comment">//1 分钟前</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//milliseconds()    此方法会计算溢出</span></span><br><span class="line">        <span class="comment">//asMilliseconds()</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.duration(<span class="number">500</span>).milliseconds(), <span class="comment">//500</span></span><br><span class="line">            moment.duration(<span class="number">1500</span>).milliseconds(), <span class="comment">//500</span></span><br><span class="line">            moment.duration(<span class="number">15000</span>).milliseconds(), <span class="comment">//0</span></span><br><span class="line">            <span class="comment">//moment.duration(1500)</span></span><br><span class="line">            moment.duration(<span class="number">500</span>).asMilliseconds(), <span class="comment">//500</span></span><br><span class="line">            moment.duration(<span class="number">1500</span>).asMilliseconds(), <span class="comment">//1500</span></span><br><span class="line">            moment.duration(<span class="number">15000</span>).asMilliseconds(), <span class="comment">//15000</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//seconds()</span></span><br><span class="line">        <span class="comment">//asSeconds()</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.duration(<span class="number">500</span>).seconds(), <span class="comment">//0</span></span><br><span class="line">            moment.duration(<span class="number">1500</span>).seconds(), <span class="comment">//1</span></span><br><span class="line">            moment.duration(<span class="number">15000</span>).seconds(), <span class="comment">//15</span></span><br><span class="line">            moment.duration(<span class="number">500</span>).asSeconds(), <span class="comment">//0.5</span></span><br><span class="line">            moment.duration(<span class="number">1500</span>).asSeconds(), <span class="comment">//1.5</span></span><br><span class="line">            moment.duration(<span class="number">15000</span>).asSeconds(), <span class="comment">//15</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//add() 增加时长，这个方法可以添加多种类型的参数</span></span><br><span class="line">        <span class="keyword">var</span> a = moment.duration(<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">//时长为1天</span></span><br><span class="line">        <span class="keyword">var</span> b = moment.duration(<span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">//时长为2天</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            a.add(b).days(),</span><br><span class="line">            moment.duration().add(<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>).days() <span class="comment">// 1</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//subtract()    减少时长</span></span><br><span class="line">        <span class="keyword">var</span> a = moment.duration(<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> b = moment.duration(<span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            a.subtract(b).days(), <span class="comment">//1</span></span><br><span class="line">            moment.duration(<span class="number">5</span>, <span class="string">&#x27;d&#x27;</span>).subtract(<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>).days() <span class="comment">//4</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//duration(x.diff(y))   获取两个时长的差值</span></span><br><span class="line">        <span class="keyword">var</span> a = moment([<span class="number">2018</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">05</span>]);</span><br><span class="line">        <span class="keyword">var</span> b = moment([<span class="number">2018</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">06</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.duration(b.diff(a)),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//as()</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            moment.duration(<span class="number">1000</span>).as(<span class="string">&#x27;milliseconds&#x27;</span>), <span class="comment">//1000</span></span><br><span class="line">            moment.duration(<span class="number">1000</span>).as(<span class="string">&#x27;seconds&#x27;</span>), <span class="comment">//1</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//get()</span></span><br><span class="line">        <span class="keyword">var</span> d = moment.duration(&#123;</span><br><span class="line">            <span class="attr">seconds</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">minutes</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">hours</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">days</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">months</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">years</span>: <span class="number">6</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(d);</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            d.get(<span class="string">&#x27;seconds&#x27;</span>),</span><br><span class="line">            d.get(<span class="string">&#x27;minutes&#x27;</span>),</span><br><span class="line">            d.get(<span class="string">&#x27;hours&#x27;</span>),</span><br><span class="line">            d.get(<span class="string">&#x27;days&#x27;</span>),</span><br><span class="line">            d.get(<span class="string">&#x27;months&#x27;</span>),</span><br><span class="line">            d.get(<span class="string">&#x27;years&#x27;</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js工具库</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>moment</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器本地存储</title>
    <url>/135xyq.github.io/2022/01/20/js%E5%B7%A5%E5%85%B7%E5%BA%93-%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><hr>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h4 id="cookie：可读可写-依托与http协议"><a href="#cookie：可读可写-依托与http协议" class="headerlink" title="cookie：可读可写,依托与http协议"></a>cookie：可读可写,依托与http协议</h4><ol>
<li>cookie不可跨域</li>
<li>cookie存储在浏览器里面</li>
<li>cookie有大小和数量的限制（超过部分删除）<ol>
<li>数量在50个左右</li>
<li>大小在4KB左右</li>
<li>cookie的存储时间非常灵活</li>
<li>cookie不光可以服务器设置，客户端也可以设置</li>
</ol>
</li>
</ol>
<h4 id="前端设置cookie："><a href="#前端设置cookie：" class="headerlink" title="前端设置cookie："></a>前端设置cookie：</h4><p>document.cookie (键值对形式)只能设置一次cookie</p>
<h3 id="cookie的属性："><a href="#cookie的属性：" class="headerlink" title="cookie的属性："></a>cookie的属性：</h3><ol>
<li>name：cookie的名字（唯一性）</li>
<li>value: cookie的值（字符串）</li>
<li>domain ： 设置cookie在哪个域下是有效的</li>
<li>path ： cookie的路径</li>
<li>expires : cookie的过期时间（默认是session在浏览器关闭时删除）具体时间点<br><code>document.cookie = &#39;margin = 20px;expires = &#39; + new Date(2021, 7, 3);</code></li>
<li>max-age : cookie的有效期（以秒为单位的时间段），存活时间<br><code>document.cookie = &#39;margin = 20px;max-age = 10&#39;;  //存活时间为10秒</code></li>
<li>HttpOnly ：有这个标记的cookie前端啊无法获取</li>
<li>Secure : 设置cookie只能通过HTTPS协议传输</li>
<li>SameSite ：设置cookie在跨域请求时不能被发送</li>
</ol>
<h2 id="Web-Storage：不依托于http协议"><a href="#Web-Storage：不依托于http协议" class="headerlink" title="Web Storage：不依托于http协议"></a>Web Storage：不依托于http协议</h2><p>不能跨域 </p>
<h4 id="localStorage：在所有域名下都有效，页面关闭还存在"><a href="#localStorage：在所有域名下都有效，页面关闭还存在" class="headerlink" title="localStorage：在所有域名下都有效，页面关闭还存在"></a>localStorage：在所有域名下都有效，页面关闭还存在</h4><h4 id="sessionStorage：仅在当前窗口有效，页面关闭不存在"><a href="#sessionStorage：仅在当前窗口有效，页面关闭不存在" class="headerlink" title="sessionStorage：仅在当前窗口有效，页面关闭不存在"></a>sessionStorage：仅在当前窗口有效，页面关闭不存在</h4><p>localStorage和sessionStorage都继承自对象Storage</p>
<h3 id="属性和方法："><a href="#属性和方法：" class="headerlink" title="属性和方法："></a>属性和方法：</h3><ol>
<li>length：本地存储的数量</li>
<li>key()：通过索引找到存储的数据，（排序不规范，和添加顺序不一样）</li>
<li>getItem（）：通过键名取到本地存储的数据（取到的是一个字符串）<br><code>console.log(localStorage.getItem(&#39;color&#39;));</code></li>
<li>setItem（）：设置一个本地存储数据</li>
</ol>
<p><code>localStorage.setItem(&#39;name&#39;, &#39;xyq&#39;);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> color = &#123;</span><br><span class="line">            <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;green&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;color&#x27;</span>, <span class="built_in">JSON</span>.stringify(color));</span><br><span class="line">添加对象</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>removeItem（）：删除一个本地存储数据</li>
<li>clearItem（）：清空本地存储<br><code>localStorage.clear();//全部清空</code></li>
</ol>
<h4 id="storage事件："><a href="#storage事件：" class="headerlink" title="storage事件："></a>storage事件：</h4><p>调用所有同域下其他窗口的storage事件，不过它本身触发storage即当前窗口是不会触发这个事件的`</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>本地存储</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>本地化存储</tag>
      </tags>
  </entry>
  <entry>
    <title>js中常用的数组方法</title>
    <url>/135xyq.github.io/2021/12/31/js%E6%94%B6%E5%AE%98%E5%92%8C%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js收官和数组方法"><a href="#js收官和数组方法" class="headerlink" title="js收官和数组方法"></a>js收官和数组方法</h1><hr>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p>for里面写上要关联内容的标识<br>添加事件时触发label时和label他关联的内容都触发，但触发内容事件时只触发自身</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>uesrname:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性和特性："><a href="#属性和特性：" class="headerlink" title="属性和特性："></a>属性和特性：</h2><p>特性属于属性<br>特性：系统上自带的一些属性<br>元素的特性是与dom对象一 一映射的<br>不是特性的属性不是一 一映射的</p>
<h2 id="图片的预加载和懒加载"><a href="#图片的预加载和懒加载" class="headerlink" title="图片的预加载和懒加载"></a>图片的预加载和懒加载</h2><h3 id="预加载："><a href="#预加载：" class="headerlink" title="预加载："></a>预加载：</h3><p>图片加载完之后才展现，不一行一行加载展现出来</p>
<h3 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h3><p>浏览到才开始加载</p>
<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h2><p>区间范围 ： [ 0 , 1 )</p>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="forEach-："><a href="#forEach-：" class="headerlink" title="forEach ："></a>forEach ：</h3><pre><code>- 循环遍历，两个参数为一个函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身），第二个参数代表this的指向（可省略（默认为window））

- 数组名.forEach(函数（有三个参数）（第一个是数组中的元素，第二个是索引，第三个是数组本身）)； 
无返回值
</code></pre>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter :"></a>filter :</h3><pre><code>- 对数组过滤，基于遍历 ，两个参数为一个函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身），第二个参数代表this的指向（可省略（默认为window））

- 执行完会返回一个新的数组。若函数的返回值为true代表当前元素保存在新数组中，为false时则过滤掉。
</code></pre>
<h3 id="map"><a href="#map" class="headerlink" title="map :"></a>map :</h3><pre><code>- 映射，两个参数为一个函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身），第二个参数代表this的指向（可省略（默认为window））
- 函数执行完的返回值决定map返回的值，会返回一个数组
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> newArr = personArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">ele, index, self</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self[index].name;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">//可以仅返回数组中每一项中的name属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>
<p>执行完会返回一个新的数组</p>
<h3 id="every-："><a href="#every-：" class="headerlink" title="every ："></a>every ：</h3><pre><code>- 数组中每元素都符合什么条件，两个参数，第一个参数为函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身）第二个参数代表this的指向（可省略（默认为window））

- 返回值为false则有元素不符合，返回值为true则所有项都符合，只有遇到有返回值为false就停止执行，返回结果为false。  
执行完会返回true或false。
</code></pre>
<h3 id="some-："><a href="#some-：" class="headerlink" title="some ："></a>some ：</h3><pre><code>- 数组中是否有元素都符合什么条件，两个参数，第一个参数为函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身）第二个参数代表this的指向（可省略（默认为window））

- 返回值为false则所有元素都不符合，返回值为true则至少有一个符合，只有遇到有返回值为true就停止执行，返回结果为true。   
执行完会返回true或false。
</code></pre>
<h3 id="字符串-indexOf-字符串1"><a href="#字符串-indexOf-字符串1" class="headerlink" title="字符串.indexOf(字符串1);"></a>字符串.indexOf(字符串1);</h3><pre><code>如果字符串中包含字符串1，则返回第一个索引值，不包含则返回 -1；
</code></pre>
<p>slice方法可以把类数组转为数组</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js基本语法</title>
    <url>/135xyq.github.io/2021/12/31/js%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js知识和基础语法"><a href="#js知识和基础语法" class="headerlink" title="js知识和基础语法"></a>js知识和基础语法</h1><hr>
<h2 id="浏览器组成："><a href="#浏览器组成：" class="headerlink" title="浏览器组成："></a>浏览器组成：</h2><ul>
<li>shell：</li>
<li>内核（核心）：<ul>
<li>渲染引擎（语法规则和渲染）</li>
<li>js引擎</li>
<li>其他模块</li>
</ul>
</li>
</ul>
<p>google发布的Chrome，引擎号V8（C语言），能直接将就是代码转化为机械码。</p>
<p>计算机中的同步和异步与现实生活中相反<br>异步：同时执行（link标签的加载）<br>同步：先干一件再干另一件</p>
<h3 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h3><p>解释性语言:一行一行执行，不生成文件；<br>单线程:同一时间只能干一件事<br>ECMA标准</p>
<p>js执行队列：<br>轮转时间片</p>
<p>js三大部分：<br>ECMAScript, DOM,BOM</p>
<h3 id="编译语言和解释语言："><a href="#编译语言和解释语言：" class="headerlink" title="编译语言和解释语言："></a>编译语言和解释语言：</h3><ul>
<li>编译（c c++ ）：     <pre><code>  优点：快  
  缺点：不跨平台，移植性不好
</code></pre>
</li>
<li>解释(javascript php)：   <pre><code>  优点：跨平台，移植性好
  不足：稍微慢
</code></pre>
</li>
</ul>
<p>java既不是编译型语言，也不是解释性语言（oak语言）</p>
<table>
<thead>
<tr>
<th align="center">主流浏览器</th>
<th align="center">内核</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IE</td>
<td align="center">trident</td>
</tr>
<tr>
<td align="center">Chrom</td>
<td align="center">webkit / blink</td>
</tr>
<tr>
<td align="center">firefox</td>
<td align="center">Gecko</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">presto</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">webkit</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="js引入："><a href="#js引入：" class="headerlink" title="js引入："></a>js引入：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script  type=<span class="string">&quot;text/javaScript&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">&quot;text/javaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>当一个script标签既引入外部js又有内部js时内部的失效</strong></p>
<p> javascript是面向对象语言</p>
<p>var  单一类型</p>
<h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><ol>
<li>原始值 (存储在栈中，栈与栈之间的赋值是拷贝)：Number   Boolean String undefined(未赋值的)  null(占位置)</li>
<li>引用值（存储在堆中， ）：array object function</li>
</ol>
<h3 id="代码错误：代码错误只会影响当前代码块"><a href="#代码错误：代码错误只会影响当前代码块" class="headerlink" title="代码错误：代码错误只会影响当前代码块"></a>代码错误：代码错误只会影响当前代码块</h3><ol>
<li>低级错误（语法错误）</li>
<li>逻辑错误</li>
</ol>
<p>赋值顺序：自右向左<br>计算顺序：自左向右</p>
<p>NaN不等于任何数，包括自己。</p>
<p>undefined , null , NaN ,” “ , 0 , false 转为布尔值都为 false</p>
<p>&amp;&amp;运算符（假设有两个值比较）（可用作短路语句），如果第一个值为false，直接输出第一个（结束执行），否则输出第二个值 。</p>
<p>||运算符（假设有两个值比较）：只有两个都为假时才返回假。前一个为真时后一个条件直接忽略（不执行）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">never - ending loop：死循环</span><br><span class="line"><span class="keyword">while</span> (<span class="string">&quot;never - ending loop&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>document.write() 可在页面中显示</code><br><code>console.log() :控制台输出</code></p>
<h4 id="switch-case语句选择："><a href="#switch-case语句选择：" class="headerlink" title="switch - case语句选择："></a>switch - case语句选择：</h4><p>case里面的类型不要求一致</p>
<p>continue :终止本次循环，开始下次的循环</p>
<p>数组里面的每个元素不用类型一样<br>length ：数组长度</p>
<h3 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">属性名（key）：属性值（value）,(属性之间用逗号分开)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出：对象名.属性名</p>
<p>typeof(变量名)  /  typeof  变量名:返回数据的类型：<br>返回值有：</p>
<ul>
<li>number ， </li>
<li>string , </li>
<li>boolean , </li>
<li>object , </li>
<li>undefined , </li>
<li>function</li>
</ul>
<p>数据null返回object</p>
<h3 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h3><h4 id="（显式类型转换）："><a href="#（显式类型转换）：" class="headerlink" title="（显式类型转换）："></a>（显式类型转换）：</h4><ul>
<li>Number（）：转为数字，null转为数字是0 ，undefined转为数字为NaN,  根据常识不能转为数字的显示为NaN ，true转为1 ， false转为 0 。</li>
<li>parseInt （参数1）： 转为整数型 ，不能转true和false（为NaN）；parseInt （参数一，参数二）：参数一：要转换的数，参数二：将数据看成什么进制（2,10,16（取值为2 - 36））转为10进制。转换原理：直接读取数值，遇到非数值部分截断。</li>
<li>parseFloat（）：转为浮点型，转换原理：直接读取数值，遇到除第一个小数点以外的非数值部分截断。</li>
<li>参数名.toString（）：转为字符串,undefined 和null 不能使用；参数名.toString（参数1）：参数1 是进制，将参数转为目标进制。</li>
<li>String（）：转为字符串。</li>
<li>Boolean（）：转为布尔类型。</li>
<li>toFixed（参数值）：保留 参数值位 小数</li>
</ul>
<h4 id="（隐式类型转换）："><a href="#（隐式类型转换）：" class="headerlink" title="（隐式类型转换）："></a>（隐式类型转换）：</h4><ul>
<li><p>isNaN（）：判断是否为NaN ，先调用Number（），再调用此方法。</p>
</li>
<li><p>++ / – / + / -  :先调用Number（），再计算，（都变成数字类型）。</p>
</li>
<li><p>+ :当两端有一个为字符串时，调用String（）,</p>
</li>
<li><p> */ % / / - :先调用Number（），再计算，（都变成数字类型）。</p>
</li>
<li><p>&gt; / &lt; / &gt;= &lt;= :转为其他的类型</p>
</li>
<li><p>== / != :转为其他的类型（null == undefined 结果为true  ，NaN == NaN 结果为false）。</p>
</li>
<li><p>===  / !==： 不发生类型转换的判断，直观判断左右是否相等。（NaN=== NaN 结果为false）。</p>
</li>
</ul>
<p>当一个变量未定义就使用时只有调用typeof(变量) （显示为undefined）不会报错，其他情况都报错。</p>
<p>alert() :网页弹出框</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>高内聚，低耦合。</p>
<p>解释性语言输出不了地址。</p>
<h3 id="定义方法："><a href="#定义方法：" class="headerlink" title="定义方法："></a>定义方法：</h3><ol>
<li><p>函数声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名（）</span>&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>命名函数表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span> 函数名</span>&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>匿名函数表达式（函数表达式）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h5><p><code>函数名（）;</code><br><code>函数名（参数，参数）：参数不需要指明类型。</code></p>
<p>定义函数的参数不要求与使用函数时传递的参数一样多，从前到后依次传，多的部分舍弃。</p>
<p>每个函数里面都有一个 arguments(类似于数组，参数列表，用来存放传递过来的实参，可以当成正常数组使用)。<br>当形参比实参多时：arguments 和 形参 多出来的部分不再满足映射（两个同时变化）。<br>可以通过 函数名.length  来求出形参的个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">w</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// document.write(&quot;a&quot; + &quot;&lt;br&gt;&quot;);</span></span><br><span class="line">            <span class="comment">// document.write(&quot;xyq&quot; + &quot;&lt;br&gt;&quot;);</span></span><br><span class="line">            <span class="comment">// document.write(x + y);</span></span><br><span class="line">            <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        w(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>return 函数返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">银行金额输出：</span><br><span class="line">        <span class="keyword">var</span> n = <span class="built_in">window</span>.prompt(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;壹&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;贰&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;叁&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;肆&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;伍&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;陆&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;柒&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;捌&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;玖&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;拾&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;佰&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;仟&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;万&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;拾万&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;佰万&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;千万&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;亿&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> i;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result += transform(n[i]);</span><br><span class="line">                    <span class="keyword">if</span> (n.length - i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        result += change(n.length - i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result += <span class="string">&#x27;元整&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(write(n));</span><br></pre></td></tr></table></figure>

<h3 id="递归-规律：先执行的最后执行完-："><a href="#递归-规律：先执行的最后执行完-：" class="headerlink" title="递归(规律：先执行的最后执行完)："></a>递归(规律：先执行的最后执行完)：</h3><ol>
<li>找规律</li>
<li>找出口</li>
</ol>
<p>函数变量作用域：里层可以访问外层，外层不能访问里层</p>
<h4 id="js执行三部曲："><a href="#js执行三部曲：" class="headerlink" title="js执行三部曲："></a>js执行三部曲：</h4><ul>
<li>语法分析</li>
<li>预编译</li>
<li>解释执行</li>
</ul>
<h4 id="预编译的结果："><a href="#预编译的结果：" class="headerlink" title="预编译的结果："></a>预编译的结果：</h4><ul>
<li>函数声明整体提升</li>
<li>变量  声明提升（只是声明了变量，不能使用里面的值）</li>
</ul>
<p>imply global暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。<br>全局对象（window)<br>一切声明的全局变量，全是window 的属性，即 var a = 123  =====&gt;  window.a =123;<br>window就是全局</p>
<h3 id="全局的预编译过程："><a href="#全局的预编译过程：" class="headerlink" title="全局的预编译过程："></a>全局的预编译过程：</h3><ol>
<li>创建GO对象（全局的执行期上下文） GO === window</li>
<li>找形参和变量声明，将变量和形参名作为GO属性名，值为undefined 。 </li>
<li>在函数体里面找函数声明（函数表达式不行），值赋予函数体 </li>
</ol>
<h3 id="函数体里的预编译过程：（预编译发生在函数执行的前一刻）"><a href="#函数体里的预编译过程：（预编译发生在函数执行的前一刻）" class="headerlink" title="函数体里的预编译过程：（预编译发生在函数执行的前一刻）"></a>函数体里的预编译过程：（预编译发生在函数执行的前一刻）</h3><ol>
<li>创建AO对象（执行期上下文）</li>
<li>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined。 </li>
<li>将实参值与形参统一  </li>
<li>在函数体里面找函数声明（函数表达式不行），值赋予函数体 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">            <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">            <span class="built_in">console</span>.log(b);</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn(<span class="number">1</span>);</span><br><span class="line">输出：</span><br><span class="line">ƒ <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">ƒ () &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> c;</span><br><span class="line">            a = <span class="number">3</span>;</span><br><span class="line">            b = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(b);</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">            <span class="built_in">console</span>.log(b);</span><br><span class="line">        &#125;</span><br><span class="line">        test(<span class="number">1</span>);</span><br><span class="line">答案</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
函数可以看成特殊的对象 </li>
</ol>
<h3 id="函数里面的属性："><a href="#函数里面的属性：" class="headerlink" title="函数里面的属性："></a>函数里面的属性：</h3><h4 id="可访问的："><a href="#可访问的：" class="headerlink" title="可访问的："></a>可访问的：</h4><ul>
<li>name </li>
<li>prototype<h4 id="不可访问的（隐式属性）："><a href="#不可访问的（隐式属性）：" class="headerlink" title="不可访问的（隐式属性）："></a>不可访问的（隐式属性）：</h4></li>
<li>[[scope]] :存放作用域</li>
</ul>
<p>但凡内部的函数保存到外部，一定生成了闭包。<br>闭包会导致作用链不释放，造成内存泄漏。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>针对初始化功能的函数（立即执行函数）：<br>执行完一次就销毁，其他和普通函数一样。</p>
<h4 id="普通的"><a href="#普通的" class="headerlink" title="普通的"></a>普通的</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">函数体</span><br><span class="line">        &#125;())</span><br></pre></td></tr></table></figure>
<h4 id="带参数的"><a href="#带参数的" class="headerlink" title="带参数的"></a>带参数的</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">形参</span>) </span>&#123;</span><br><span class="line">函数体</span><br><span class="line">        &#125;(实参))</span><br></pre></td></tr></table></figure>
<h4 id="带返回值的"><a href="#带返回值的" class="headerlink" title="带返回值的"></a>带返回值的</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    		函数体</span><br><span class="line">        	&#125;());</span><br></pre></td></tr></table></figure>

<p>只有表达式才能被执行符号执行。<br>被执行符号执行的函数名字会被直接放弃（丢弃），相当于变成了立即执行函数。</p>
<p>嵌套函数将内部函数保存到外部，一定会生成闭包，保存到外部的函数可以调用原来所处位置的变量。</p>
<p>多个函数和一个函数形成闭包，则多个函数的变量共用。</p>
<p>函数不执行（只定义）就不会运行函数内部的语句，什么时候执行函数，函数再运行内部语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">200</span>;</span><br><span class="line">        test();</span><br><span class="line">输出<span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="，-也可以作为运算符，返回后面的计算值。"><a href="#，-也可以作为运算符，返回后面的计算值。" class="headerlink" title="， 也可以作为运算符，返回后面的计算值。"></a>， 也可以作为运算符，返回后面的计算值。</h3><p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span> -<span class="number">1</span> , <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">a 的值为<span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> f = (</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        )();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br><span class="line">输出值为 number</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;) &#123; <span class="comment">//立即执行函数</span></span><br><span class="line">         x += <span class="keyword">typeof</span> f;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(x);</span><br><span class="line">输出 ： 1<span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象创建方法："><a href="#对象创建方法：" class="headerlink" title="对象创建方法："></a>对象创建方法：</h3><ol>
<li>plainObject   对象字面量 / 对象直接量<br>每个属性之间用 ， 分隔开<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名 ： 属性值，</span><br><span class="line">    </span><br><span class="line">    方法名 ： <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.属性名; <span class="comment">//调用属性  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>构造函数<ol>
<li>系统自带的构造函数  Object()<br>可以增，删，查，改 ，属性和方法<br><code>var 对象名 = new Object();</code></li>
<li>自定义(函数名使用大驼峰 （首字母全大写）)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.属性名 = 属性值;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.方法名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 对象名 = <span class="keyword">new</span> 函数名(参数);</span><br></pre></td></tr></table></figure>
例：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="string">&quot;1400&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.lang = <span class="string">&quot;49000&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;I am Running!&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="构造函数内部原理："><a href="#构造函数内部原理：" class="headerlink" title="构造函数内部原理："></a>构造函数内部原理：</h3><ol>
<li>在函数体最前面隐式的加上this = {}</li>
<li>执行this.xxx = xxx</li>
<li>隐式的返回this</li>
</ol>
<p>当一个对象的属性未定义就使用不会报错，会返回undefined。</p>
<p>对象属性使用：<br>对象名. 属性名  / 对象名. 方法名</p>
<p>this 第一人称可以用来指代对象。</p>
<h4 id="给对象增加属性和方法："><a href="#给对象增加属性和方法：" class="headerlink" title="给对象增加属性和方法："></a>给对象增加属性和方法：</h4><p>对象名.属性名 = “属性值” / 对象名. 方法名 = function() { }</p>
<h4 id="给对象改变属性和方法："><a href="#给对象改变属性和方法：" class="headerlink" title="给对象改变属性和方法："></a>给对象改变属性和方法：</h4><p>对象名.属性名 = “属性值” / 对象名. 方法名 = function() { }</p>
<h4 id="删除对象属性和方法："><a href="#删除对象属性和方法：" class="headerlink" title="删除对象属性和方法："></a>删除对象属性和方法：</h4><p>delete 对象名.属性名    /    delete  对象名. 方法名 </p>
<h4 id="原始值类型的变量没有属性和方法。"><a href="#原始值类型的变量没有属性和方法。" class="headerlink" title="原始值类型的变量没有属性和方法。"></a>原始值类型的变量没有属性和方法。</h4><h3 id="包装类："><a href="#包装类：" class="headerlink" title="包装类："></a>包装类：</h3><p>//创建一个数字型对象（可以有方法和属性）<br>var 对象名 = new Number(数字);</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//创建一个字符串型对象（可以有方法和属性）</span></span><br><span class="line"><span class="keyword">var</span>  对象名 = <span class="keyword">new</span> <span class="built_in">String</span>(字符串);</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个布尔型对象（可以有方法和属性）</span></span><br><span class="line"><span class="keyword">var</span> 对象名 = <span class="keyword">new</span> Strng(布尔类型);</span><br></pre></td></tr></table></figure>
<p>例：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>想操作原始值属性，系统会自动将其包装为对象，再删除对象。</p>
<h2 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h2><p>用法：函数名.prototype.属性名 = 属性值；<br>function对象的一个属性，他定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象（可以按照对象操作）。<br>利用原型特点和概念，可以提取共有属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        Car.prototype.height = <span class="string">&quot;1400&quot;</span>;</span><br><span class="line">        Car.prototype.lang = <span class="string">&quot;49000&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;I am Running!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">&quot;BWM&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> car1 = <span class="keyword">new</span> Car(<span class="string">&quot;AoDi&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="不能通过对象修改原型。"><a href="#不能通过对象修改原型。" class="headerlink" title="不能通过对象修改原型。"></a>不能通过对象修改原型。</h4><p>函数名.prototype.属性 = 属性值;//修改属性</p>
<p>delete 函数名.prototype.属性;  //删除</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> Car.prototype.height;</span><br></pre></td></tr></table></figure>

<p>对象名.constructor；   可以找出对象的构造函数。</p>
<p>charCodeAt()  方法可找出字符串的每一位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        Person.prototype.name = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person.prototype.name = <span class="string">&#x27;hsz&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(person.name);</span><br><span class="line">输出为 hsz</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// Person.prototype.name = &#x27;hsz&#x27;;</span></span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;hsz&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(person.name);</span><br><span class="line">输出为xyq</span><br><span class="line">会重新创建一个对象，更改地址了</span><br></pre></td></tr></table></figure>

<h4 id="绝大多数对象最终都继承自Object-prototype"><a href="#绝大多数对象最终都继承自Object-prototype" class="headerlink" title="绝大多数对象最终都继承自Object.prototype"></a>绝大多数对象最终都继承自Object.prototype</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">可以创建一个没有继承<span class="built_in">Object</span>的对象</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(number) ;  向下取整（舍弃小数部分）</span><br><span class="line"><span class="built_in">Math</span>.ceil(number); 向上取整（整数部分加一）</span><br></pre></td></tr></table></figure>

<p>可正常计算的范围：小数点前16位 ，后16位</p>
<h3 id="call-apply方法-："><a href="#call-apply方法-：" class="headerlink" title="call / apply方法 ："></a>call / apply方法 ：</h3><p>改变this的指向（可以借别人的方法来封装自己的功能）</p>
<h4 id="call需要把实参按照形参的个数传进去，apply只能传一个arguments-数组"><a href="#call需要把实参按照形参的个数传进去，apply只能传一个arguments-数组" class="headerlink" title="call需要把实参按照形参的个数传进去，apply只能传一个arguments(数组)"></a>call需要把实参按照形参的个数传进去，apply只能传一个arguments(数组)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;XYQ&#x27;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">        Person.call(obj, <span class="string">&#x27;xyq&#x27;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">obj会变成&#123;<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, tel, grade</span>) </span>&#123;</span><br><span class="line">            Person.call(<span class="built_in">this</span>, name, age, sex);</span><br><span class="line">            <span class="built_in">this</span>.tel = tel;</span><br><span class="line">            <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">可以生成Student函数有（name, age, sex, tel, grade）属性</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, tel, grade</span>) </span>&#123;</span><br><span class="line">            Person.apply(<span class="built_in">this</span>, [name, age, sex]);</span><br><span class="line">            <span class="built_in">this</span>.tel = tel;</span><br><span class="line">            <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">可以生成Student函数有（name, age, sex, tel, grade）属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>less的基本介绍</title>
    <url>/135xyq.github.io/2021/12/31/less/</url>
    <content><![CDATA[<p><img src="http://mdrs.yuanjin.tech/img/20210507101924.png" alt="技能树.drawio"></p>
<h1 id="什么是Less？"><a href="#什么是Less？" class="headerlink" title="什么是Less？"></a>什么是Less？</h1><p><strong>Less</strong>是一种更加简洁的样式代码，它非常像CSS，但又不太一样，它让编写样式变得更容易</p>
<p>下面是css代码和Less代码的对比，它们都表达了一样的含义</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210507125034.png" alt="image-20210507125034131"></p>
<p><strong>Less代码虽好，但它无法被浏览器识别</strong>，因此需要一个工具将其转换为血统纯正的css代码</p>
<p>由于<strong>node环境具有读写文件的能力</strong>，于是在node环境中可以轻松的完成文件的转换</p>
<p><code>npm</code>上有一个包叫做<code>less</code>，它运行在node环境中，通过它可以完成对Less代码的转换</p>
<img src="http://mdrs.yuanjin.tech/img/20210507105107.png" alt="image-20210507105107556" style="zoom:50%;" />

<p><strong>可以看出，node环境在前端工程化中，充当了一个辅助的角色，它并不直接运行前端代码，而是让我们编写前端代码更加舒适便利，在后续的课程中，你还会不断的体会到这一点</strong></p>
<p><strong>转换代码，称之为编译(compile)，转换代码的工具，称之为编译器(compiler)</strong></p>
<h1 id="体验Less"><a href="#体验Less" class="headerlink" title="体验Less"></a>体验Less</h1><ol>
<li><p>新建<code>index.less</code>文件，编写下面的<code>less</code>代码</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@green:</span> <span class="number">#008c8c</span>;</span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@green</span>;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="variable">@green</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>npm</code>下载<code>less</code></p>
<p><code>less</code>包提供了一个<code>cli</code>工具<code>lessc</code>，你可以有两种方案使用它</p>
<p><strong>方案一：全局安装less</strong></p>
<p>这种方案可以让你在任何终端目录使用<code>lessc</code>命令，但不利于版本控制</p>
<p><strong>方案二：本地安装less</strong></p>
<p>这种方案会把<code>less</code>安装到工程目录的<code>node_modules</code>中，你无法全局使用<code>lessc</code>命令，但可以在当前工程目录中使用<code>npx lessc</code>运行该命令</p>
<blockquote>
<p>npx是npm提供的一个小工具，它可以运行当前项目中安装到node_modules的cli命令</p>
<p>如果配置<code>package.json</code>脚本，无须使用<code>npx</code></p>
<p>如果可以，应该尽量使用本地安装，而非全局安装</p>
</blockquote>
<p>如果可以，应该尽量使用本地安装，而非全局安装</p>
</li>
<li><p>使用<code>lessc</code>命令，对编写的<code>less</code>文件进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 index.less 编译成为 index.css</span></span><br><span class="line">lessc index.less index.css</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个页面，引用编译结果<code>index.css</code></p>
</li>
</ol>
<blockquote>
<p>目前，编写less代码会遇到一点小麻烦，就是每次编写后，都需要运行命令进行编译</p>
<p>这个麻烦只是暂时的，将来很快就可以解决</p>
</blockquote>
<h1 id="Less的核心语法"><a href="#Less的核心语法" class="headerlink" title="Less的核心语法"></a>Less的核心语法</h1><blockquote>
<p>Less官网：<a href="https://lesscss.org/">https://lesscss.org/</a></p>
<p>Less民间中文网：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></p>
</blockquote>
<p>Less提供了非常多的功能，帮助我们更加轻松的编写css代码</p>
<p>其中，我们最常用的功能有下面3个：</p>
<ul>
<li><a href="https://less.bootcss.com/#%E5%8F%98%E9%87%8F%EF%BC%88variables%EF%BC%89">变量</a></li>
<li><a href="https://less.bootcss.com/#%E5%B5%8C%E5%A5%97%EF%BC%88nesting%EF%BC%89">嵌套</a></li>
<li><a href="https://less.bootcss.com/#%E6%B7%B7%E5%90%88%EF%BC%88mixins%EF%BC%89">混合</a></li>
</ul>
<p>另外，你需要关注Less的特殊<a href="https://less.bootcss.com/#%E6%B3%A8%E9%87%8A%EF%BC%88comments%EF%BC%89">注释</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>less</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>npm简介</title>
    <url>/135xyq.github.io/2022/01/20/npm%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="包的安装"><a href="#包的安装" class="headerlink" title="包的安装"></a>包的安装</h2><blockquote>
<p>安装（install）即下载包<br>由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址。目前，淘宝 <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 提供了国内的 registry 地址，先设置到该地址。设置方式为<code>npm config set registry https://registry.npm.taobao.org</code>。设置好后，通过命令<code>npm config get registry</code>进行检查</p>
</blockquote>
<p>npm 安装一个包，分为两种安装方式：</p>
<ol>
<li>本地安装</li>
<li>全局安装</li>
</ol>
<h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>使用命令<code>npm install 包名</code>或<code>npm i 包名</code>即可完成本地安装</p>
<p>本地安装的包出现在当前目录下的<code>node_modules</code>目录中</p>
<blockquote>
<p>随着开发的进展，<code>node_modules</code>目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用<code>.gitignore</code>文件忽略该目录中的内容<br>本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用<br>通常在项目的根目录中使用本地安装<br>安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到<code>node_modules</code>目录中<br>如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到<code>node_modules/.bin</code>下，使用命令<code>npx 命令名</code>即可调用</p>
</blockquote>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>全局安装的包放置在一个特殊的全局目录，该目录可以通过命令<code>npm config get prefix</code>查看</p>
<p>使用命令<code>npm install --global 包名</code> 或 <code>npm i -g 包名</code></p>
<p>重要：<strong>全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具</strong></p>
<p>大部分情况下，都不需要全局安装包，除非：</p>
<ol>
<li>包的版本非常稳定，很少有大的更新</li>
<li>提供的 CLI 工具在各个工程中使用的非常频繁</li>
<li>CLI 工具仅为开发环境提供支持，而非部署环境</li>
</ol>
<h2 id="包配置"><a href="#包配置" class="headerlink" title="包配置"></a>包配置</h2><p>目前遇到的问题：</p>
<ol>
<li>拷贝工程后如何还原？</li>
<li>如何区分开发依赖和生产依赖？</li>
<li>如果自身的项目也是一个包，如何描述包的信息</li>
</ol>
<p>以上这些问题都需要通过包的<strong>配置文件</strong>解决</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>npm 将每个使用 npm 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述</p>
<p><strong>配置文件的名称固定为：package.json</strong></p>
<p>可以手动创建该文件，而更多的时候，是通过命令<code>npm init</code>创建的</p>
<p>配置文件中可以描述大量的信息，包括：</p>
<ul>
<li>name：包的名称，该名称必须是<strong>英文单词字符</strong>，支持连接符</li>
<li>version：版本<ul>
<li>版本规范：主版本号.次版本号.补丁版本号</li>
<li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li>
<li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li>
<li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li>
</ul>
</li>
<li>description：包的描述</li>
<li>homepage：官网地址</li>
<li>author：包的作者，必须是有效的 npm 账户名，书写规范是 <code>account &lt;mail&gt;</code>，例如：<code>zhangsan &lt;zhangsan@gmail.com&gt;</code>，不正确的账号和邮箱可能导致发布包时失败</li>
<li>repository：包的仓储地址，通常指 git 或 svn 的地址，它是一个对象<ul>
<li>type：仓储类型，git 或 svn</li>
<li>url：地址</li>
</ul>
</li>
<li>main：包的入口文件，使用包的人默认从该入口文件导入包的内容</li>
<li>keywords: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包</li>
</ul>
<p>使用<code>npm init --yes</code>或<code>npm init -y</code>可以在生成配置文件时自动填充默认配置</p>
<h3 id="保存依赖关系"><a href="#保存依赖关系" class="headerlink" title="保存依赖关系"></a>保存依赖关系</h3><p>大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要package.json文件</p>
<p><strong>package.json文件最重要的作用，是记录当前工程的依赖</strong></p>
<ul>
<li>dependencies：生产环境的依赖包</li>
<li>devDependencies：仅开发环境的依赖包</li>
</ul>
<p>配置好依赖后，使用下面的命令即可安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 本地安装所有依赖 dependencies + devDependencies</span></span></span><br><span class="line">npm install</span><br><span class="line">npm i</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 仅安装生产环境的依赖 dependencies</span></span></span><br><span class="line">npm install --production</span><br></pre></td></tr></table></figure>

<p>这样一来，代码移植就不是问题了，只需要移植源代码和package.json文件，不用移植node_modules目录，然后在移植之后通过命令即可重新恢复安装</p>
<p>为了更加方便的添加依赖，npm支持在使用install命令时，加入一些额外的参数，用于将安装的依赖包保存到package.json文件中</p>
<p>涉及的命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装依赖到生产环境</span></span></span><br><span class="line">npm i 包名</span><br><span class="line">npm i --save 包名</span><br><span class="line">npm i -S 包名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装依赖到开发环境</span></span></span><br><span class="line">npm i --save-dev 包名</span><br><span class="line">npm i -D 包名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动保存的依赖版本，例如<code>^15.1.3</code>，这种书写方式叫做语义版本号（semver version），具体规则后续讲解</p>
</blockquote>
<h2 id="简易数据爬虫"><a href="#简易数据爬虫" class="headerlink" title="简易数据爬虫"></a>简易数据爬虫</h2><p>将豆瓣电影的电影数据抓取下来，保存到本地文件 movie.json 中</p>
<p>需要用到的包：</p>
<ol>
<li>axios：专门用于在各种环境中发送网络请求，并获取到服务器响应结果</li>
<li>cheerio：jquery的核心逻辑包，支持所有环境，可用于讲一个html字符串转换成为jquery对象，并通过jquery对象完成后续操作</li>
<li>fs：node核心模块，专门用于文件处理<ul>
<li>fs.writeFile(文件名, 数据)</li>
</ul>
</li>
</ol>
<h2 id="语义版本"><a href="#语义版本" class="headerlink" title="语义版本"></a>语义版本</h2><p>思考：如果你编写了一个包A，依赖另外一个包B，你在编写代码时，包B的版本是2.4.1，你是希望使用你包的人一定要安装包B，并且是2.4.1版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？</p>
<p>回顾：版本号规则</p>
<p>版本规范：主版本号.次版本号.补丁版本号</p>
<ul>
<li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li>
<li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li>
<li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li>
</ul>
<p>有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化</p>
<p>有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升</p>
<p>甚至我们希望依赖包保持固定的版本，尽管这比较少见</p>
<p>这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。</p>
<p>这种规则的描述，即<strong>语义版本</strong></p>
<p>语义版本的书写规则非常丰富，下面列出了一些常见的书写方式</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">描述</th>
<th align="center">示例</th>
<th align="center">示例描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;</td>
<td align="center">大于某个版本</td>
<td align="center">&gt;1.2.1</td>
<td align="center">大于1.2.1版本</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于某个版本</td>
<td align="center">&gt;=1.2.1</td>
<td align="center">大于等于1.2.1版本</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于某个版本</td>
<td align="center">&lt;1.2.1</td>
<td align="center">小于1.2.1版本</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于某个版本</td>
<td align="center">&lt;=1.2.1</td>
<td align="center">小于等于1.2.1版本</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">介于两个版本之间</td>
<td align="center">1.2.1 - 1.4.5</td>
<td align="center">介于1.2.1和1.4.5之间</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">不固定的版本号</td>
<td align="center">1.3.x</td>
<td align="center">只要保证主版本号是1，次版本号是3即可</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">补丁版本号可增</td>
<td align="center">~1.3.4</td>
<td align="center">保证主版本号是1，次版本号是3，补丁版本号大于等于4</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">此版本和补丁版本可增</td>
<td align="center">^1.3.4</td>
<td align="center">保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">最新版本</td>
<td align="center">*</td>
<td align="center">始终安装最新版本</td>
</tr>
</tbody></table>
<h3 id="避免还原的差异"><a href="#避免还原的差异" class="headerlink" title="避免还原的差异"></a>避免还原的差异</h3><p>版本依赖控制始终是一个两难的问题</p>
<p>如果允许版本增加，可以让依赖包的bug得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的bug）</p>
<p>如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力</p>
<p>而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现</p>
<p>基于此，npm 在安装包的时候，会自动生成一个 package-lock.json 文件，该文件记录了安装包时的确切依赖关系</p>
<p>当移植工程时，如果移植了 package-lock.json 文件，恢复安装时，会按照 package-lock.json 文件中的确切依赖进行安装，最大限度的避免了差异</p>
<h2 id="扩展-npm的差异版本处理"><a href="#扩展-npm的差异版本处理" class="headerlink" title="[扩展]npm的差异版本处理"></a>[扩展]npm的差异版本处理</h2><p>如果两个包依赖同一个包的不同版本，如下图</p>
<p><img src="/images/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/npm-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E5%A4%84%E7%90%86.jpg"></p>
<p>面对这种情况，在 node_modules 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│   ├── a </span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   │   ├── c</span><br><span class="line">│   │   │   |   |—— c包的文件</span><br><span class="line">│   │   │── a包的文件     </span><br><span class="line">│   ├── b </span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   │   ├── c</span><br><span class="line">│   │   │   |   |—— c包的文件</span><br><span class="line">│   │   │── b包的文件           </span><br></pre></td></tr></table></figure>

<h2 id="npm-脚本-（npm-scripts）"><a href="#npm-脚本-（npm-scripts）" class="headerlink" title="npm 脚本 （npm scripts）"></a>npm 脚本 （npm scripts）</h2><p>在开发的过程中，我们可能会反复使用很多的 CLI 命令，例如：</p>
<ul>
<li>启动工程命令（node 或 一些第三方包提供的CLI命令）</li>
<li>部署工程命令（一些第三方包提供的CLI命令）</li>
<li>测试工程命令（一些第三方包提供的CLI命令）</li>
</ul>
<p>这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆</p>
<p>于是，npm 非常贴心的支持了脚本，只需要在 package.json 中配置 scripts 字段，即可配置各种脚本名称</p>
<p>之后，我们就可以运行简单的指令来完成各种操作了</p>
<p>运行方式是 <code>npm run 脚本名称</code></p>
<p>不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用run的：</p>
<ul>
<li>start</li>
<li>stop</li>
<li>test</li>
</ul>
<p>一些细节：</p>
<ul>
<li>脚本中可以省略npx</li>
<li>start脚本有默认值：node server.js</li>
</ul>
<h2 id="运行环境配置"><a href="#运行环境配置" class="headerlink" title="运行环境配置"></a>运行环境配置</h2><p>我们书写的代码一般有三种运行环境：</p>
<ol>
<li>开发环境</li>
<li>生产环境</li>
<li>测试环境</li>
</ol>
<p>有的时候，我们可能需要在 node 代码中根据不同的环境做出不同的处理</p>
<p>如何优雅的让 node 知道处于什么环境，是极其重要的</p>
<p>通常我们使用如下的处理方式：</p>
<p>node中有一个全局变量 global (可以类比浏览器环境的window)，该变量是一个对象，对象中的所有属性均可以直接使用</p>
<p>global有一个属性是process，该属性是一个对象，包含了当前运行node程序的计算机的很多信息，其中有一个信息是env，是一个对象，包含了计算机中所有的系统变量</p>
<p>通常，我们通过系统变量 NODE_ENV 的值，来判定node程序处于何种环境</p>
<p>有两种方式设置 NODE_ENV 的值</p>
<ol>
<li>永久设置</li>
<li>临时设置</li>
</ol>
<p>我们一般使用临时设置</p>
<p>因此，我们可以配置 scripts 脚本，在设置好了 NODE_ENV 后启动程序</p>
<blockquote>
<p>为了避免不同系统的设置方式的差异，可以使用第三方库 cross-env 对环境变量进行设置</p>
</blockquote>
<h3 id="在node中读取package-json"><a href="#在node中读取package-json" class="headerlink" title="在node中读取package.json"></a>在node中读取package.json</h3><p>有的时候，我们可能在 package.json 中配置一些自定义的字段，这些字段需要在node中读取</p>
<p>在node 中，可以直接导入一个json格式的文件，它会自动将其转换为js对象</p>
<h2 id="其他npm命令-ignore"><a href="#其他npm命令-ignore" class="headerlink" title="其他npm命令 {ignore}"></a>其他npm命令 {ignore}</h2><p>[toc]</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>精确安装最新版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-exact 包名 </span><br><span class="line">npm install -E 包名</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装指定版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install 包名@版本号</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ol>
<li>查询包安装路径</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm root [-g]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看包信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm view 包名 [子信息]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># view aliases：v info show</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查询安装包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm list [-g] [--depth=依赖深度]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># list aliases: ls  la  ll</span></span></span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ol>
<li>检查有哪些包需要更新</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update [-g] [包名]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># update 别名（aliases）：up、upgrade</span></span></span><br></pre></td></tr></table></figure>

<h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall [-g] 包名</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># uninstall aliases: remove, rm, r, un, unlink</span></span></span><br></pre></td></tr></table></figure>

<h3 id="npm-配置"><a href="#npm-配置" class="headerlink" title="npm 配置"></a>npm 配置</h3><p>npm的配置会对其他命令产生或多或少的影响</p>
<p>安装好npm之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置</p>
<p>通常，我们不关心具体的配置文件，而只关心最终生效的配置</p>
<p>通过下面的命令可以查询目前生效的各种配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config ls [-l] [--json]</span><br></pre></td></tr></table></figure>

<p>另外，可以通过下面的命令操作配置</p>
<ol>
<li>获取某个配置项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get 配置项</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置某个配置项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set 配置项=值</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>移除某个配置项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete 配置项</span><br></pre></td></tr></table></figure>

<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>移除淘宝镜像源</li>
<li>到npm官网注册一个账号，并完成邮箱认证</li>
<li>本地使用 npm cli 进行登录<ol>
<li>使用命令<code>npm login</code>登录</li>
<li>使用命令<code>npm whoami</code>查看当前登录的账号</li>
<li>使用命令<code>npm logout</code>注销</li>
</ol>
</li>
<li>创建工程根目录</li>
<li>使用npm init进行初始化</li>
</ol>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ol>
<li>开发</li>
<li>确定版本</li>
<li>使用命令<code>npm publish</code>完成发布</li>
</ol>
<h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><p><img src="/images/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/npm-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE.jpg"></p>
<p>可以通过网站 <a href="http://choosealicense.online/appendix/">http://choosealicense.online/appendix/</a> 选择协议，并复制协议内容</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的v-model</title>
    <url>/135xyq.github.io/2022/01/01/v-model/</url>
    <content><![CDATA[<p>面试题：请阐述一下 <code>v-model</code> 的原理</p>
<p><code>v-model</code>即可以作用于表单元素，又可作用于自定义组件，无论是哪一种情况，它都是一个语法糖，最终会生成一个属性和一个事件</p>
<p><strong>当其作用于表单元素时</strong>，<code>vue</code>会根据作用的表单元素类型而生成合适的属性和事件。例如，作用于普通文本框的时候，它会生成<code>value</code>属性和<code>input</code>事件，而当其作用于单选框或多选框时，它会生成<code>checked</code>属性和<code>change</code>事件。</p>
<p><code>v-model</code>也可作用于自定义组件，<strong>当其作用于自定义组件时</strong>，默认情况下，它会生成一个<code>value</code>属性和<code>input</code>事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等效于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">:value</span>=<span class="string">&quot;data&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;data=$event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>开发者可以通过组件的<code>model</code>配置来改变生成的属性和事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comp</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&quot;number&quot;</span>, <span class="comment">// 默认为 value</span></span><br><span class="line">    <span class="attr">event</span>: <span class="string">&quot;change&quot;</span> <span class="comment">// 默认为 input</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等效于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">:number</span>=<span class="string">&quot;data&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;data=$event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn简介</title>
    <url>/135xyq.github.io/2022/01/20/yarn%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="yarn-简介"><a href="#yarn-简介" class="headerlink" title="yarn 简介"></a>yarn 简介</h2><blockquote>
<p>yarn 官网：<a href="https://www.yarnpkg.com/zh-Hans/">https://www.yarnpkg.com/zh-Hans/</a></p>
</blockquote>
<p>yarn 是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，<strong>它仍然使用 npm 的registry</strong>，不过提供了全新 CLI 来对包进行管理</p>
<p>过去，yarn 的出现极大的抢夺了 npm 的市场，甚至有人戏言，npm 只剩下一个 registry 了。</p>
<p>之所以会出现这种情况，是因为在过去，npm 存在下面的问题：</p>
<ul>
<li>依赖目录嵌套层次深：过去，npm 的依赖是嵌套的，这在 windows 系统上是一个极大的问题，由于众所周知的原因，windows 系统无法支持太深的目录</li>
<li>下载速度慢<ul>
<li>由于嵌套层次的问题，所以npm对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有完全利用</li>
<li>多个相同版本的包被重复的下载</li>
</ul>
</li>
<li>控制台输出繁杂：过去，npm 安装包的时候，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量的信息输出到控制台，遇到错误极难查看</li>
<li>工程移植问题：由于 npm 的版本依赖可以是模糊的，可能会导致工程移植后，依赖的确切版本不一致。</li>
</ul>
<p>针对上述问题，yarn 从诞生那天就已经解决，它用到了以下的手段：</p>
<ul>
<li>使用扁平的目录结构</li>
<li>并行下载</li>
<li>使用本地缓存</li>
<li>控制台仅输出关键信息</li>
<li>使用yanr-lock文件记录确切依赖</li>
</ul>
<p>不仅如此，yarn还优化了以下内容：</p>
<ul>
<li>增加了某些功能强大的命令</li>
<li>让既有的命令更加语义化</li>
<li>本地安装的CLI工具可以使用 yarn 直接启动</li>
<li>将全局安装的目录当作一个普通的工程，生成package.json文件，便于全局安装移植</li>
</ul>
<p>yarn 的出现给 npm 带来了巨大的压力，很快，npm 学习了 yarn 先进的理念，不断的对自身进行优化，到了目前的npm6版本，几乎完全解决了上面的问题：</p>
<ul>
<li>目录扁平化</li>
<li>并行下载</li>
<li>本地缓存</li>
<li>使用package-lock记录确切依赖</li>
<li>增加了大量的命令别名</li>
<li>内置了npx，可以启动本地的CLI工具</li>
<li>极大的简化了控制台输出</li>
</ul>
<p><strong>总结</strong></p>
<p>npm6 之后，可以说npm已经和yarn非常接近，甚至没有差距了。很多新的项目，又重新从yarn转回到npm。</p>
<p>这两个包管理器是目前的主流，都必须要学习。</p>
<h2 id="yarn-的核心命令"><a href="#yarn-的核心命令" class="headerlink" title="yarn 的核心命令"></a>yarn 的核心命令</h2><ol>
<li><strong>初始化</strong></li>
</ol>
<p>初始化：<code>yarn init [--yes/-y]</code></p>
<ol start="2">
<li><strong>安装</strong></li>
</ol>
<p>添加指定包：<code>yarn [global] add package-name [--dev/-D] [--exact/-E]</code></p>
<p>安装package.json中的所有依赖：<code>yarn install [--production/--prod]</code></p>
<ol start="3">
<li><strong>脚本和本地CLI</strong></li>
</ol>
<p>运行脚本：<code>yarn run 脚本名</code> </p>
<blockquote>
<p>start、stop、test可以省略run</p>
</blockquote>
<p>运行本地安装的CLI：<code>yarn run CLI名</code></p>
<ol start="4">
<li><strong>查询</strong></li>
</ol>
<p>查看bin目录：<code>yarn [global] bin</code></p>
<p>查询包信息：<code>yarn info 包名 [子字段]</code></p>
<p>列举已安装的依赖：<code>yarn [global] list [--depth=依赖深度]</code></p>
<blockquote>
<p>yarn的list命令和npm的list不同，yarn输出的信息更加丰富，包括顶级目录结构、每个包的依赖版本号</p>
</blockquote>
<ol start="5">
<li><strong>更新</strong></li>
</ol>
<p>列举需要更新的包：<code>yarn outdated</code></p>
<p>更新包：<code>yarn [global] upgrade [包名]</code></p>
<ol start="6">
<li><strong>卸载</strong></li>
</ol>
<p>卸载包：<code>yarn remove 包名</code></p>
<h2 id="yarn-的特别礼物"><a href="#yarn-的特别礼物" class="headerlink" title="yarn 的特别礼物"></a>yarn 的特别礼物</h2><p>在终端命令上，yarn不仅仅是对npm的命令做了一个改名，还增加了一些原本没有的命令，这些命令在某些时候使用起来非常方便</p>
<ol>
<li><strong>yarn check</strong></li>
</ol>
<p>使用<code>yarn check</code>命令，可以验证package.json文件的依赖记录和lock文件是否一致</p>
<p>这对于防止篡改非常有用</p>
<ol start="2">
<li><strong>yarn audit</strong></li>
</ol>
<p>使用<code>yarn audit</code>命令，可以检查本地安装的包有哪些已知漏洞，以表格的形式列出，漏洞级别分为以下几种：</p>
<ul>
<li>INFO：信息级别</li>
<li>LOW: 低级别</li>
<li>MODERATE：中级别</li>
<li>HIGH：高级别</li>
<li>CRITICAL：关键级别</li>
</ul>
<ol start="3">
<li><strong>yarn why</strong></li>
</ol>
<p>使用<code>yarn why 包名</code>命令，可以在控制台打印出为什么安装了这个包，哪些包会用到它</p>
<ol start="4">
<li><strong>yarn create</strong></li>
</ol>
<p>非常有趣的命令</p>
<p>今后，我们会学习一些脚手架，所谓脚手架，就是使用一个命令来搭建一个工程结构</p>
<p>过去，我们都是使用如下的做法：</p>
<ol>
<li>全局安装脚手架工具</li>
<li>使用全局命令搭建脚手架</li>
</ol>
<p>由于大部分脚手架工具都是以<code>create-xxx</code>的方式命名的，比如react的官方脚手架名称为<code>create-react-app</code></p>
<p>因此，可以使用<code>yarn create</code>命令来一步完成安装和搭建</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的两条命令</span></span><br><span class="line">yarn global add create-react-app</span><br><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的使用</title>
    <url>/135xyq.github.io/2021/12/31/webpack/</url>
    <content><![CDATA[<p><img src="http://mdrs.yuanjin.tech/img/20210508151156.png" alt="技能树"></p>
<blockquote>
<p><strong>工程化，为复杂应用而生</strong></p>
<p>本文为保持简单，牺牲了某些语言的准确性</p>
</blockquote>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p><strong>webpack是用来搭建前端工程的</strong></p>
<p>它运行在node环境中，它所做的事情，简单来说，就是<strong>打包</strong></p>
<img src="http://mdrs.yuanjin.tech/img/20210508172954.png" alt="image-20210508172953979" style="zoom:50%;" />

<p>具体来说，就是以某个模块作为入口，根据入口分析出所有模块的依赖关系，然后对各种模块进行合并、压缩，形成最终的打包结果</p>
<p><strong>在webpack的世界中，一切皆是模块</strong></p>
<h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><blockquote>
<p>老师提供的工程，以<code>src/main.js</code>作为入口文件</p>
<p>按照习惯，所有的模块均放置在<code>src</code>目录中</p>
</blockquote>
<ol>
<li><p>安装依赖</p>
</li>
<li><p>编写多个模块</p>
<p>随意编写一些模块，可以是js、图片、音视频，以入口模块为起点，形成依赖关系</p>
</li>
<li><p>运行<code>npm run build</code>命令，进行打包</p>
</li>
<li><p>查看打包结果</p>
<p>打包结果放置在dist目录中</p>
</li>
</ol>
<p>通过上面的体验，可以发现，webpack给我们带来了至少以下好处：</p>
<ul>
<li><p>可以大胆的使用任意模块化标准</p>
<p>无须担心兼容性问题，因为webpack完成打包后，已经没有了任何模块化语句</p>
</li>
<li><p>可以将一些非JS代码也视为模块</p>
<p>这样可以对css、图片等资源进行更加细粒度的划分</p>
</li>
<li><p>在前端开发中，也可以使用npm</p>
<p>webpack不会运行你的源代码，无论是你自己写的模块，还是通过npm安装的模块，webpack一视同仁，统统视为依赖，最终合并到打包结果中</p>
</li>
<li><p>非常适合开发单页应用</p>
<p>单页应用是前端用户体验最好的web应用</p>
<p>所谓单页应用，是指只有一个html页面，页面中没有任何内容，所有的内容均靠js生成</p>
<p>要优雅的实现单页应用，最好依托于前端框架，比如vue、react</p>
</li>
</ul>
<p>webpack给我们开发带来的变化远不止于此，接下来一一体验</p>
<h1 id="页面模板"><a href="#页面模板" class="headerlink" title="页面模板"></a>页面模板</h1><p>对于单页应用而言，只有一个空白的页面，所有内容都靠JS代码创建</p>
<p>webpack会自动生成一个页面，并且在页面中会自动加入对js和css的引用</p>
<p>它生成页面时，参考的是<code>public/index.html</code>，其称之为页面模板</p>
<h1 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a>public目录</h1><p>webpack会非常暴力的将public目录中的所有文件（除页面模板外），复制到打包结果中</p>
<h1 id="开发服务器"><a href="#开发服务器" class="headerlink" title="开发服务器"></a>开发服务器</h1><p>如果每次修改完代码，都要经过<code>打包-&gt;运行</code>，未免太过麻烦</p>
<p>在开发阶段，我们可以运行<code>npm run serve</code>命令获得更好的打包体验</p>
<p>该命令会让<code>webpack</code>启动一个<strong>开发服务器</strong>。</p>
<p>在这个阶段，webpack并不会形成打包结果文件，而是把打包的内容放到内存中，当我们请求服务器时，服务器从内存中给予我们打包结果</p>
<p>与此同时，当源码发生变动时，webpack会自动重新打包，同时刷新页面以访问到最新的打包结果</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210508194443.png" alt="image-20210508194442940"></p>
<h1 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h1><p>可以看到，除了页面外，其他的资源在打包完成后，文件名多了一些奇奇怪怪的字符</p>
<p>例如：<code>js/app-9ea93.js</code></p>
<p>其中，<code>9ea93</code>这样的字符称之为<code>hash</code>，它会随着模块内容的变化而变化</p>
<p><strong>源码内容不变，hash不变；源码内容变化，hash变化</strong></p>
<p>之所以这样做，是因为生产环境中，浏览器会对除页面外的静态资源进行缓存</p>
<p>如果不设置hash值，一旦代码更新，浏览器还会使用之前缓存的结果，无法使用最新的代码</p>
<img src="http://mdrs.yuanjin.tech/img/20210508183135.png" alt="image-20210508183135487" style="zoom:50%;" />

<p>有了hash值之后，即可解决此问题</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210508183454.png" alt="image-20210508183454385"></p>
<p>webpack会在打包时自动处理hash值，并不会对我们写代码造成任何影响，但作为一个前端开发者，有必要了解这一点</p>
<h1 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h1><p><strong>除代码和样式模块外，其他模块被视为资源模块</strong></p>
<p>值得特别注意的是，<strong>资源模块在源代码中的路径和打包后的路径是不一样的</strong>，这就导致我们在编写代码的时候，根本无法知晓最终的路径</p>
<p>最常见的例子，就是在css中使用背景图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="comment">/* 背景图使用了源码中的路径 */</span></span><br><span class="line">  backgroud: <span class="built_in">url</span>(<span class="string">&#x27;../assets/1.png&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它能正常工作吗？</p>
<p>它能！</p>
<p>因为webpack非常智能的发现了这一点，对于css中的路径，webpack在打包时，会将其自动转换为打包结果的路径，比如，上面的代码在打包完成后，可能被转换为下面的格式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="comment">/* css中的资源路径会被自动替换，我们无须关心 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">/img/1492ea.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们要通过js动态的使用路径，webpack是无法识别的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包前</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;./assets/1.png&#x27;</span>; <span class="comment">// 该路径无法被转换</span></span><br><span class="line">img.src = url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;./assets/1.png&#x27;</span>; <span class="comment">// ❌</span></span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure>

<p>正确的做法是，通过模块化的方式导入资源，并获取资源路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包前</span></span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">&#x27;./assets/1.png&#x27;</span>; <span class="comment">// 打包后，url得到的将是真实的路径</span></span><br><span class="line">img.src = url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/img/1492ea.png&#x27;</span>; <span class="comment">// ✅</span></span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure>

<h1 id="缺省的文件和后缀名"><a href="#缺省的文件和后缀名" class="headerlink" title="缺省的文件和后缀名"></a>缺省的文件和后缀名</h1><p>导入模块时，所有js模块均可省略<code>.js</code>，若导入的模块文件名为<code>index.js</code>，可省略文件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./home&#x27;</span>; <span class="comment">// 若存在home.js，可省略js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./movie&#x27;</span>; <span class="comment">// 若movie是一个目录，此次导入的是 ./movie/index.js</span></span><br></pre></td></tr></table></figure>

<h1 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h1><p>随着体量的增长，不可避免的，会形成层级极深的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">	|- src</span><br><span class="line">		|- a</span><br><span class="line">				|- a1</span><br><span class="line">						|- a2</span><br><span class="line">							 |- index.js</span><br><span class="line">		|- b</span><br><span class="line">				|- b1</span><br><span class="line">						|- index.js</span><br></pre></td></tr></table></figure>

<p>如果需要在<code>./src/a/a1/a2/index.js</code>中导入<code>./src/b/b1/index.js</code>，则可能产生下面特别恶心的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../../../b/b1/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>webpack提供了别名供我们快速定位到<code>./src</code>目录，通常，该别名为<code>@</code></p>
<p>上面的导入代码可简化为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/b/b1&#x27;</span>; <span class="comment">// @表示src目录，同时省略了index.js</span></span><br></pre></td></tr></table></figure>

<h1 id="js兼容性"><a href="#js兼容性" class="headerlink" title="js兼容性"></a>js兼容性</h1><p>当webpack读取到js代码时，会自动对其进行兼容性处理</p>
<p>具体的处理方案涉及到两个配置文件：</p>
<ul>
<li><code>babel.config.js</code>：通过配置该文件，可以设置对哪些js代码进行降级处理</li>
<li><code>.browserslistrc</code>：通过配置该文件，可以设置在降级时，要兼容哪些浏览器，兼容的范围越光，降级产生的代码就越多，自然，打包后的体积就越大</li>
</ul>
<p>你无须知晓具体的配置方式</p>
<h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><p>webpack在打包时，会对所有js和css代码进行压缩</p>
<p>对于js，除了压缩之外，还会对其中的各种名称进行混淆</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(self.webpackChunkmovie_list=self.webpackChunkmovie_list||[]).push([[<span class="number">587</span>],&#123;<span class="number">3587</span>:<span class="function">(<span class="params">r,t,n</span>)=&gt;</span>&#123;<span class="string">&quot;use strict&quot;</span>;n.r(t),n(<span class="number">5666</span>),n(<span class="number">1539</span>),n(<span class="number">8674</span>),n(<span class="number">9600</span>),n(<span class="number">1249</span>),n(<span class="number">2222</span>);<span class="keyword">var</span> e=n(<span class="number">9755</span>),a=n.n(e);<span class="keyword">var</span> o;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">r</span>)</span>&#123;o.html(r.map((<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">return</span><span class="string">&#x27;&lt;li&gt;\n  &lt;a href=&quot;&#x27;</span>.concat(r.url,<span class="string">&#x27;&quot; target=&quot;_blank&quot;&gt;\n    &lt;img src=&quot;&#x27;</span>).concat(r.cover,<span class="string">&#x27;&quot; title=&quot;&#x27;</span>).concat(r.title,<span class="string">&#x27;&quot;&gt;\n  &lt;/a&gt;\n  &lt;a href=&quot;&#x27;</span>).concat(r.url,<span class="string">&#x27;&quot; target=&quot;_blank&quot; class=&quot;&#x27;</span>).concat(<span class="string">&quot;qmUYQv1xlJhGMQKz-kfAp&quot;</span>,<span class="string">&#x27;&quot;&gt;&#x27;</span>).concat(r.title,<span class="string">&#x27;&lt;/a&gt;\n  &lt;p class=&quot;&#x27;</span>).concat(<span class="string">&quot;_3yV5wC-URYTUP0sPvaE0ZR&quot;</span>,<span class="string">&#x27;&quot;&gt;&#x27;</span>).concat(r.rate,<span class="string">&quot;&lt;/p&gt;\n  &lt;/li&gt;&quot;</span>)&#125;)).join(<span class="string">&quot;&quot;</span>))&#125;o=a()(<span class="string">&quot;&lt;ul&gt;&quot;</span>).addClass(<span class="string">&quot;_1fsrc5VinfYHBXCF1s58qS&quot;</span>).appendTo(<span class="string">&quot;#app&quot;</span>);<span class="keyword">var</span> c=n(<span class="number">8138</span>);<span class="keyword">const</span> u=</span><br></pre></td></tr></table></figure>

<p>混淆的作用一方面是为了进一步压缩包体积，另一方面是为了让我们的代码更难被其他人理解利用</p>
<h1 id="源码地图-source-map"><a href="#源码地图-source-map" class="headerlink" title="源码地图 source map"></a>源码地图 source map</h1><p>我们运行的是webpack打包后的结果，而打包后的结果是很难阅读的</p>
<p>但这样一来会带来新的问题，如果代码报错，我们就难以知道到底是那一行代码写的有问题</p>
<p>此时源码地图就发挥了作用</p>
<p>可以发现，js代码打包后都会跟上一个同名的、后缀为<code>.map</code>的文件，该文件就保存了原始代码的内容</p>
<p>请放心，这个内容人类是看不懂的，但浏览器可以看懂</p>
<p>当代码报错时，浏览器会定位到源码地图中的对应代码，而不是把真实报错的代码展示给我们</p>
<p>你无须关心这一点，但可以自然的从其中获得巨大的便利</p>
<h1 id="css工程化"><a href="#css工程化" class="headerlink" title="css工程化"></a>css工程化</h1><p>webpack能够识别<strong>所有</strong>的样式代码，包括<code>css</code>、<code>less</code>、<code>sass</code>、<code>stylus</code></p>
<p>在打包时，会将它们转换成纯正的<code>css</code></p>
<p>除此之外，它还具备以下的神奇能力</p>
<h2 id="自动厂商前缀"><a href="#自动厂商前缀" class="headerlink" title="自动厂商前缀"></a>自动厂商前缀</h2><p>css有很多兼容性问题，解决这些兼容性问题的最常见办法，就是加上厂商前缀。</p>
<p>比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 兼容性不好的代码 */</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 兼容性好的代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack会根据<code>.browserlistrc</code>中指定的浏览器范围，<strong>按需、自动</strong>加上厂商前缀</p>
<p>我们开发无须关心</p>
<h2 id="css-module"><a href="#css-module" class="headerlink" title="css module"></a>css module</h2><p>css文件多了后，你怎么保证它们里面没有冲突的类样式？</p>
<p>靠层级选择器？就不担心效率？</p>
<p>靠命名规范？就不担心脑袋爆炸？</p>
<p>要靠就靠css module</p>
<p>当样式文件以<code>xxx.mdoule.xxx</code>的方式命名时，webpack会将该文件当成一个开启了<code>css module</code>的文件</p>
<p>比如：<code>index.module.less</code>、<code>movie.module.css</code>，都是开启了<code>css module</code>的文件</p>
<p><strong>文件中的所有类名都会被hash化</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.list</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包结果，绝无可能重名</span></span><br><span class="line"><span class="selector-class">._2GFVidHvoHtfgtrdifua24</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">._1fsrc5VinfYHBXCF1s58qS</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.urPUKUukdS_UTSuWRI5-5</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在就一个问题，我们在使用类名时，如何知道它打包结果的类名呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.module.less&#x27;</span>;</span><br><span class="line">dom.classList.add(<span class="string">&#x27;container&#x27;</span>); <span class="comment">// ❌ 最终的类名可不是这个</span></span><br></pre></td></tr></table></figure>

<p>正确的方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// styles 是一个对象，里面映射了源码类名和打包类名的关系</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.less&#x27;</span>;</span><br><span class="line">dom.classList.add(styles.container); <span class="comment">// ✅ 属性container中记录的就是container转换后的类名</span></span><br></pre></td></tr></table></figure>



<h1 id="真正的webpack没有那么神奇"><a href="#真正的webpack没有那么神奇" class="headerlink" title="真正的webpack没有那么神奇"></a>真正的webpack没有那么神奇</h1><p>实际上，webpack没有做这么多事，我们不能把功劳（怨念）全归结于它</p>
<p>它只是站在巨人（其他流氓）肩膀上而已</p>
<p>下图可以看个热闹</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210508203658.png" alt="image-20210508203658298"></p>
<p>webpack通过插件（plugin）和加载器（loader）将这些技术整合在一起</p>
<p><code>上图的技术 + 乱七八糟一大堆其他技术 + 老师的配置 = 呈现给你的工程</code></p>
<p>目前，你无须理解这一些，保持敬畏即可</p>
<p>最后，说明一下工程中看不懂的文件：</p>
<ul>
<li><code>.browserslistrc</code>，表达适配的浏览器范围，会被工程化中的其他技术所使用</li>
<li><code>babel.config.js</code>，<code>babel</code>的配置文件，做js降级处理</li>
<li><code>postcss.config.js</code>，<code>postcss</code>的配置文件，做css代码转换</li>
<li><code>webpack.config.js</code>，<code>webpack</code>的配置文件，整合其他工程化技术，以及配置打包细节、开发服务器、路径别名等等</li>
</ul>
<h1 id="对我们开发的影响"><a href="#对我们开发的影响" class="headerlink" title="对我们开发的影响"></a>对我们开发的影响</h1><ol>
<li><p>学会访问开发服务器查看效果</p>
</li>
<li><p>学会动态获取资源文件路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">&#x27;./assets/1.png&#x27;</span>; </span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure></li>
<li><p>学会省略文件和后缀名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./home&#x27;</span>; <span class="comment">// 若存在home.js，可省略js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./movie&#x27;</span>; <span class="comment">// 若movie是一个目录，此次导入的是 ./movie/index.js</span></span><br></pre></td></tr></table></figure></li>
<li><p>学会使用别名简化导入代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/b/b1&#x27;</span>; <span class="comment">// 实际导入： src/b/b1/index.js  (若b1是目录)</span></span><br></pre></td></tr></table></figure></li>
<li><p>学会使用css module</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// styles 是一个对象，里面映射了源码类名和打包类名的关系</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.less&#x27;</span>;</span><br><span class="line">dom.classList.add(styles.container); </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>人机交互技术期末复习</title>
    <url>/135xyq.github.io/2022/01/08/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="人机交互知识点总结"><a href="#人机交互知识点总结" class="headerlink" title="人机交互知识点总结"></a>人机交互知识点总结</h1><h2 id="考试题型及分值分布："><a href="#考试题型及分值分布：" class="headerlink" title="考试题型及分值分布："></a>考试题型及分值分布：</h2><ol>
<li>选择题（10题、20分）</li>
<li>填空题（10题、20分）</li>
<li>判断题（可选、5题、10分）</li>
<li>解答题（5、6题、30分）</li>
<li>分析计算题（1、2题、20分）<br>注意：<strong>答案有多条时，用1、2、3形式分别列出。</strong></li>
</ol>
<h2 id="考查内容"><a href="#考查内容" class="headerlink" title="考查内容"></a>考查内容</h2><ol>
<li>掌握人机交互技术基本概念、研究内容及发展趋势</li>
<li>主要人机交互设备及其主要原理</li>
<li>行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换</li>
<li>能够根据案例分析某软件结构的行为模型或结构模型</li>
<li>掌握图形用户界面的基本原则</li>
<li>掌握移动互联网设计的基本原则及其特点</li>
<li>掌握几种基本的软件体系结构</li>
<li>熟悉LOTOS的几种关系及其语法</li>
<li>什么是可用性及其可用性的基本原则</li>
<li>案例综合分析</li>
</ol>
<h2 id="掌握人机交互技术基本概念、研究内容及发展趋势-P1"><a href="#掌握人机交互技术基本概念、研究内容及发展趋势-P1" class="headerlink" title="掌握人机交互技术基本概念、研究内容及发展趋势(P1)"></a>掌握人机交互技术基本概念、研究内容及发展趋势(P1)</h2><h3 id="人机交互技术基本概念"><a href="#人机交互技术基本概念" class="headerlink" title="人机交互技术基本概念"></a>人机交互技术基本概念</h3><p>人机交互是指关于设计、评价和实现供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科。<br>狭义的讲:人机交互技术主要是研究<strong>人与计算机</strong>和<strong>计算机到人</strong>的<strong>信息交换</strong>两部分。</p>
<h3 id="人机交互的研究内容"><a href="#人机交互的研究内容" class="headerlink" title="人机交互的研究内容"></a>人机交互的研究内容</h3><h4 id="1-人机交互界面的表示模型与设计方法"><a href="#1-人机交互界面的表示模型与设计方法" class="headerlink" title="1. 人机交互界面的表示模型与设计方法"></a>1. 人机交互界面的表示模型与设计方法</h4><p>一个交互界面的优劣，直接影响软件开发的成败。友好的人机交互界面的开发离不开好的交互模型和设计方法。</p>
<h4 id="2-可用性分析与评估"><a href="#2-可用性分析与评估" class="headerlink" title="2. 可用性分析与评估"></a>2. 可用性分析与评估</h4><p>它关系到人机交互能否达到用户期待的目标，以及实现这一目标的效率与便捷性。</p>
<h4 id="3-多通道交互技术"><a href="#3-多通道交互技术" class="headerlink" title="3. 多通道交互技术"></a>3. 多通道交互技术</h4><p>研究视觉、听觉、触觉和力觉等多通道信息的融合理论和方法。<br>多通道交互主要研究多通道交互界面的表示模型、多通道交互界面的评估方法以及多通道信息的融合等。<br>其中，多通道融合是多通道用户界面研究的重点和难点。</p>
<h4 id="4-认知与智能用户界面"><a href="#4-认知与智能用户界面" class="headerlink" title="4. 认知与智能用户界面"></a>4. 认知与智能用户界面</h4><p>目标是：是人机交互和人-人交互一样自然、方便。</p>
<h4 id="5-群件"><a href="#5-群件" class="headerlink" title="5. 群件"></a>5. 群件</h4><p>群件是指为群组提供计算机支持的协作环境，主要涉及个人或群组间的信息传递、群组内的信息共享、业务过程自动化与协调以及人和过程之间的交互活动等。</p>
<h4 id="6-web设计"><a href="#6-web设计" class="headerlink" title="6. web设计"></a>6. web设计</h4><p>web设计重点研究web界面的信息交互模型和结构、web界面设计的基本思想和原则、web设计的工具和技术，以及web界面设计的可用性分析与评估方法等内容。</p>
<h4 id="7-移动界面设计"><a href="#7-移动界面设计" class="headerlink" title="7. 移动界面设计"></a>7. 移动界面设计</h4><h3 id="人机交互技术发展趋势"><a href="#人机交互技术发展趋势" class="headerlink" title="人机交互技术发展趋势"></a>人机交互技术发展趋势</h3><h4 id="1-命令行交互阶段"><a href="#1-命令行交互阶段" class="headerlink" title="1. 命令行交互阶段"></a>1. 命令行交互阶段</h4><p>通过键盘输入数据和命令信息，界面输出以字符为主，因此这种人机交互方法缺乏自然性。</p>
<h4 id="2-图形用户界面交互阶段（GUI）"><a href="#2-图形用户界面交互阶段（GUI）" class="headerlink" title="2. 图形用户界面交互阶段（GUI）"></a>2. 图形用户界面交互阶段（GUI）</h4><p>与命令行界面相比，图形用户界面的自然性和交互效率都有较大的提高。<br>图形用户界面很大程度上依赖<strong>菜单选择</strong>和<strong>交互构件</strong>。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>鼠标驱动的界面便于初学者使用，但重复性的菜单选择会给有经验的用户造成不方便。</li>
<li>图形用户界面需要占用较多的屏幕空间，并且难以表达和支持非空间性的抽象信息的交互。</li>
</ol>
<h4 id="3-自然和谐的人机交互阶段"><a href="#3-自然和谐的人机交互阶段" class="headerlink" title="3. 自然和谐的人机交互阶段"></a>3. 自然和谐的人机交互阶段</h4><ol>
<li>多通道交互</li>
<li>情感计算</li>
<li>虚拟现实</li>
<li>智能用户界面</li>
<li>自然语言理解</li>
</ol>
<h2 id="主要人机交互设备及其主要原理-P42"><a href="#主要人机交互设备及其主要原理-P42" class="headerlink" title="主要人机交互设备及其主要原理(P42)"></a>主要人机交互设备及其主要原理(P42)</h2><h3 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h3><h4 id="文本输入设备"><a href="#文本输入设备" class="headerlink" title="文本输入设备"></a>文本输入设备</h4><h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>一般由按键、导电塑胶、编码器、接口电路组成。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>键盘得每一个按键对应一个编码，当用户按下一个按键时，导电塑胶将线路板上的这个按键的排线接通，键盘中的编码器能够迅速将此键盘所对应的编码通过接口电路输送到计算机的键盘缓冲器中，由计算机识别处理。</p>
<h5 id="手写输入设备"><a href="#手写输入设备" class="headerlink" title="手写输入设备"></a>手写输入设备</h5><p>手写板是一种常见的支持手写输入设备的交互设备。</p>
<h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ol>
<li>电阻式压力手写板</li>
<li>电磁式感应手写板</li>
<li>电容式触控手写板</li>
</ol>
<h6 id="电阻式压力手写板"><a href="#电阻式压力手写板" class="headerlink" title="电阻式压力手写板"></a>电阻式压力手写板</h6><p>组成：一层可变形的电阻薄膜、一层固定的电阻薄膜、中间由空气相隔离。</p>
<p>原理：当用笔或手接触手写板时，上层电阻受压变形并与下层电阻相接触，下层电阻就能判断笔或手指的位置。</p>
<p>缺点：</p>
<ol>
<li>由于通过感应材料的变形判断位置，感应材料易疲劳，使用寿命较短；</li>
<li>感应不是很灵敏，使用时压力不够没有感应，压力过大又易损伤感应板。</li>
</ol>
<h6 id="电磁式手写板"><a href="#电磁式手写板" class="headerlink" title="电磁式手写板"></a>电磁式手写板</h6><p>原理：手写板的下方电路通电后，在一定空间范围内形成电磁场，来感应带有线圈的笔尖的位置进行工作。</p>
<p>缺点：</p>
<ol>
<li>对电压要求较高，电压达不到要求就会出现工作不稳定或不能工作的情况；</li>
<li>抗电磁干扰较差，易于其他电磁设备发生干扰；</li>
<li>手写笔笔尖是活动部件，使用寿命短；</li>
<li>必须有手写笔才能工作，不能用手指直接操作</li>
</ol>
<h6 id="电容式手写板"><a href="#电容式手写板" class="headerlink" title="电容式手写板"></a>电容式手写板</h6><p>原理：通过人体的电容来感知手指的位置，即当使用者的手指接触到触控板的瞬间，就在板的表面产生一个电容。在触控板的表面附着着一种传感矩阵，这种矩阵与特殊芯片一起，持续不断地跟踪使用者手指电容的“轨迹”得到位置。</p>
<h4 id="图像输入设备"><a href="#图像输入设备" class="headerlink" title="图像输入设备"></a>图像输入设备</h4><h5 id="二维扫描仪"><a href="#二维扫描仪" class="headerlink" title="二维扫描仪"></a>二维扫描仪</h5><h6 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h6><p>光学系统、步进电机</p>
<h6 id="光学系统"><a href="#光学系统" class="headerlink" title="光学系统"></a>光学系统</h6><p>将光线照射到稿件上，产生的发射光或透射光经过反光镜组反射到图像传感器（CCD）中，CCD将光电信号转为数字图像信号。</p>
<h6 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h6><p>控制光学系统在传动导轨上平行移动，对待扫稿件逐行进行扫描，最终完成全部稿件的扫描。</p>
<h6 id="指标性能"><a href="#指标性能" class="headerlink" title="指标性能"></a>指标性能</h6><ol>
<li>扫描速度</li>
<li>分辨率</li>
</ol>
<p>扫描速度决定了扫描仪的工作效率，分辨率决定了最高扫描精度。</p>
<p>分辨率受光学部分、硬件部分和软件部分三个因素影响。</p>
<h5 id="数字摄像头"><a href="#数字摄像头" class="headerlink" title="数字摄像头"></a>数字摄像头</h5><p>直接捕捉影像，然后通过计算机的串口、并口或USB接口传送到计算机。</p>
<h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p>感光部件、简单的镜头、数据传输线路</p>
<h6 id="衡量因素"><a href="#衡量因素" class="headerlink" title="衡量因素"></a>衡量因素</h6><ol>
<li>感光元件的类型</li>
<li>像素数</li>
<li>解析度</li>
<li>视频速度</li>
<li>镜头的好坏</li>
</ol>
<h4 id="三维信息输入设备"><a href="#三维信息输入设备" class="headerlink" title="三维信息输入设备"></a>三维信息输入设备</h4><h5 id="三维扫描仪"><a href="#三维扫描仪" class="headerlink" title="三维扫描仪"></a>三维扫描仪</h5><h6 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h6><p>根据传感方式的不同：接触式和非接触式</p>
<h6 id="接触式"><a href="#接触式" class="headerlink" title="接触式"></a>接触式</h6><p>原理：探测头直接接触物体表面，把探测头反馈回来的光电信号转换为描述物体表面形状的数字信息。</p>
<p>优点：有较高的准确性和可靠性</p>
<p>缺点：测量速度慢、费用较高、探头易磨损</p>
<h6 id="非接触式"><a href="#非接触式" class="headerlink" title="非接触式"></a>非接触式</h6><p>主要有三维激光扫描仪和结构光式三维扫描仪。</p>
<p>优点：扫描速度快、易于操作、对物体表面损伤少。</p>
<p>三维激光扫描仪通过高速激光扫描测量技术，获取被测对象表面的空间坐标数据。</p>
<p>常用TOF（飞行时间）测量法或三角测量法进行深度数据的获取。</p>
<p>（1）TOF测量法</p>
<p>通过激光二极管向物体发射近红外波长的激光束，通过测量激光在仪器和目标物体表面的往返时间，计算仪器和点之间的距离，从而计算出目标点的深度。</p>
<p>（2）三角测量法</p>
<p>三角测量法是一种线扫描技术，通过线激光器向被测物体投射一条激光射线，激光线受到物体表面形状的调制，形成反应物体表面轮廓的曲线，利用扫描仪内部内置的摄像头拍摄曲线图像，根据激光器和摄像头之间的三角关系，根据双目视觉方法，反求出激光亮线处物体的深度信息。</p>
<p>结构光三维扫描仪</p>
<p>是一种面扫描技术，通过投影仪向被测物体投射光栅模板图像，光栅在物体表面发生调制变形，其周期与相位的变化反映了物体表面的三维信息。通过相机拍摄物体表面的光栅图像，检测出相应相位变化值，再利用双目视觉方法计算出三维数据。</p>
<p>三维扫描仪的性能指标主要包括扫描的速度、精度和范围等。</p>
<h5 id="动作捕捉设备"><a href="#动作捕捉设备" class="headerlink" title="动作捕捉设备"></a>动作捕捉设备</h5><h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><p>动作捕捉设备在运动物体的关键部位设置跟踪点，由系统捕捉跟踪点在三维空间中运动的轨迹，再经过计算机处理后，得到物体的运动数据。</p>
<h6 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h6><ol>
<li>机械式</li>
<li>光学式</li>
<li>电磁式</li>
</ol>
<h6 id="光学式运动捕捉的原理"><a href="#光学式运动捕捉的原理" class="headerlink" title="光学式运动捕捉的原理"></a>光学式运动捕捉的原理</h6><p>利用计算机视觉原理，通过对目标上特定光点的监视和跟踪来完成运动捕捉的任务。对于空间中的一个点，只要它同时为两部摄像机所见，则根据同一时刻两部摄像机所拍摄的图像和对应参数，可以计算出该点该时刻的空间位置。</p>
<h5 id="体感输入设备"><a href="#体感输入设备" class="headerlink" title="体感输入设备"></a>体感输入设备</h5><p>原理和应用和光学式捕捉设备类似。</p>
<h4 id="指点输入设备"><a href="#指点输入设备" class="headerlink" title="指点输入设备"></a>指点输入设备</h4><p>指点设备常用于完成一些定位和选择物体的交互任务。</p>
<h5 id="鼠标及控制杆"><a href="#鼠标及控制杆" class="headerlink" title="鼠标及控制杆"></a>鼠标及控制杆</h5><p>鼠标根据工作原理 不同可以分为 机械鼠标和光电鼠标。</p>
<p>控制杆的移动导致屏幕上光标的移动，根据两者的移动关系可以将其分为移动定位和压力定位。</p>
<p>移动定位的控制杆：屏幕上的光标依据控制杆的位移而移动，因而位移是非常重要的定位特征。<br>压力定位的控制杆：其受到的压力被转化为屏幕上光标的移动速度。</p>
<h5 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h5><h6 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h6><p>触摸检测部件、触摸屏控制器。</p>
<p>触摸屏检测部件：安装在显示器屏幕前面，用于检测用户触摸位置，然后传送给触摸屏控制器。</p>
<p>触摸屏控制器：处理从触摸检测部件接收到的触摸信息，并将它转换成触点坐标，再传送给CPU，同时接受CPU发出来的命令并加以执行。</p>
<h6 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h6><p>电阻式触摸屏、电容式触摸屏、基于光学的触摸屏</p>
<h6 id="电阻式触摸屏"><a href="#电阻式触摸屏" class="headerlink" title="电阻式触摸屏"></a>电阻式触摸屏</h6><p>优点：原理简单、工艺要求低、价格低廉</p>
<p>电阻式触摸屏是一种传感器，通过转换触摸点的物理位置坐标（X,Y）得到代表X坐标和Y坐标的电压。</p>
<h6 id="电容式触摸屏"><a href="#电容式触摸屏" class="headerlink" title="电容式触摸屏"></a>电容式触摸屏</h6><p>由四层复合玻璃组成，利用人体的电流感应进行工作。</p>
<p>缺点：</p>
<ol>
<li>当较大面积的手掌或手持的导体物靠近电容屏而未触摸时就能引起电容屏的误动作，在潮湿的天气，这种情况尤为严重。</li>
<li>用带手套的手或手持不导电的物体触摸时没有反应，这是因为引入了更为绝缘的介质。</li>
</ol>
<h6 id="基于光学的触摸屏"><a href="#基于光学的触摸屏" class="headerlink" title="基于光学的触摸屏"></a>基于光学的触摸屏</h6><p>优点：高扩展性、低成本、易搭建</p>
<h3 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h3><h4 id="光栅显示器"><a href="#光栅显示器" class="headerlink" title="光栅显示器"></a>光栅显示器</h4><p>显示器是计算机的重要输出设备，是人机对话的重要工具。它的主要功能是接收主机发出的信息，经过一系列的变换，最后以<strong>点阵</strong>的形式将文字和图形显示出来。 </p>
<h5 id="光栅显示器工作原理"><a href="#光栅显示器工作原理" class="headerlink" title="光栅显示器工作原理"></a>光栅显示器工作原理</h5><p>常见的光栅显示器包括阴极线管显示器（CRT）、等离子显示器和液晶（LCD）显示器</p>
<h6 id="CRT显示器的组成"><a href="#CRT显示器的组成" class="headerlink" title="CRT显示器的组成"></a>CRT显示器的组成</h6><ol>
<li>阴极</li>
<li>电平控制器</li>
<li>聚焦系统</li>
<li>加速系统</li>
<li>偏转系统</li>
<li>阳极荧光粉涂层</li>
</ol>
<p>这六部分都在真空管内。</p>
<p>阴极、 电平控制器、 聚焦系统、 加速系统统称为电子枪。</p>
<h6 id="CRT显示器工作原理"><a href="#CRT显示器工作原理" class="headerlink" title="CRT显示器工作原理"></a>CRT显示器工作原理</h6><ol>
<li>当显像管内部的电子枪阴极发出的电子束，经强度控制、聚焦和加速后变成细小的电子流，再经过偏转线圈的作用向正确目标偏离，穿越荫罩的小孔或栅栏，轰击到荧光屏上的荧光粉发出光线。</li>
<li>彩色CRT光栅扫描显示器有三个电子枪，它的荧光屏上涂有三种荧光物质，分别能发红、绿、蓝三种颜色的光。</li>
</ol>
<h6 id="等离子显示器"><a href="#等离子显示器" class="headerlink" title="等离子显示器"></a>等离子显示器</h6><p>等离子显示器诞生于二十世纪60年代，它采用等离子管作为发光材料，1个等离子管负责一个像素的显示：等离子管内的氖氙混合气体在高压电极的刺激下产生紫外线，紫外线照射涂有三色荧光粉的玻璃板，荧光粉受激发出可见光 。</p>
<p>优点：重量较轻、完全无X射线辐射，而且屏幕亮度非常均匀，不存在明显的亮区和暗区；由于各个发光单元的结构完全相同，因此不会出现CRT显示器那样存在某些区域聚焦不良或因使用时间过长出现散焦的毛病。</p>
<p>缺点：是价格较高，由于显示屏上的玻璃较薄使屏幕较脆弱。</p>
<h6 id="液晶显示器"><a href="#液晶显示器" class="headerlink" title="液晶显示器"></a>液晶显示器</h6><p>在充电条件下，液晶能改变分子排列，继而造成光线的扭曲或折射。</p>
<p>液晶显示器工作原理是通过能阻塞或传递光的液晶材料，传递来自周围的或内部光源的偏振光。以电流刺激液晶分子产生点、线、面配合背部灯管构成画面。</p>
<p>LCD比CRT显示器具有更好的图像清晰度，画面稳定性和更低的功率消耗，但液晶材质粘滞性比较大，图像更新需要较长响应时间，因此不适合显示动态图象。</p>
<h5 id="光栅显示器的技术指标"><a href="#光栅显示器的技术指标" class="headerlink" title="光栅显示器的技术指标"></a>光栅显示器的技术指标</h5><ol>
<li>扫描方式：分为逐行扫描和隔行扫描（已淘汰）；</li>
<li>刷新频率：屏幕刷新速度，75Hz是最低要求；</li>
<li>点距：同一像素中两颜色相近的磷光的距离。越小，图像越细腻</li>
<li>分辨率：屏幕上水平方向和垂直方向上所显示的点数，分辨率越高图像越清晰，且能增加屏幕上的信息容量。</li>
<li>亮度：显示白色图形白块的亮度，并不是越亮越好；</li>
<li>对比度：显示的画面或字符与屏幕背景底色的亮度对比。对比度越大，显示的字符或画面越清晰。</li>
<li>尺寸：屏幕尺寸实际上指显现管的尺寸。</li>
</ol>
<h5 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h5><p>显示器必须依靠显卡提供的显示信号才能显示出各种字符和图像，显卡是连接显示器和个人计算机主板的重要设备。</p>
<h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><p>根据CPU提供的指令和有关数据进行相应的处理，并把处理结果转换为显示器能够接受的文字和图像显示信号，通过屏幕显示出来。</p>
<h6 id="显卡组成："><a href="#显卡组成：" class="headerlink" title="显卡组成："></a>显卡组成：</h6><p>显卡BIOS芯片、图像处理芯片（GPU）(核心)、显存、数模转换器芯片（RAMDAC）芯片、接口。</p>
<h4 id="投影仪"><a href="#投影仪" class="headerlink" title="投影仪"></a>投影仪</h4><p>将数字图像或视频投射到幕布上的设备。<br>从数字信号到光信号的转换设备。</p>
<p>根据投影仪的工作方式不同，主要分为CRT型、LCD型及DLP型三种不同类型的投影仪，而其中LCD投影仪与DLP投影仪又是目前商用投影仪中的主流。</p>
<h4 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h4><p>打印机是目前非常通用的一种输出设备，其结构可分为机械装置和控制电路两部分。</p>
<p>常见的有针式、喷墨、激光打印机三类。</p>
<p>打印分辨率、速度、幅面、最大打印能力等是衡量打印机性能的重要指标。</p>
<h4 id="3D打印机"><a href="#3D打印机" class="headerlink" title="3D打印机"></a>3D打印机</h4><p>3D打印机又称三维打印机，它以数字模型文件为输入，运用特殊蜡材、粉末状金属或塑料等可粘合材料，通过打印一层层的粘合材料来制造三维的物体。</p>
<p>3D打印机与传统打印机最大的区别在于它使用的“墨水”是实实在在的原材料，可用于打印的介质种类多样，从繁多的塑料到金属、陶瓷以及橡胶类物质。有些打印机还能结合不同介质，令打印出来的物体一头坚硬而另一头柔软。</p>
<h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><p>分为喷墨式，熔积成型，激光烧结三种类型的3D打印机</p>
<h4 id="语音交互设备"><a href="#语音交互设备" class="headerlink" title="语音交互设备"></a>语音交互设备</h4><p>语音作为一种重要的交互手段，日益受到人们的重视。</p>
<h5 id="基本的语音交互设备"><a href="#基本的语音交互设备" class="headerlink" title="基本的语音交互设备"></a>基本的语音交互设备</h5><ol>
<li>耳机</li>
<li>麦克风</li>
<li>声卡</li>
</ol>
<h3 id="虚拟现实交互设备"><a href="#虚拟现实交互设备" class="headerlink" title="虚拟现实交互设备"></a>虚拟现实交互设备</h3><h4 id="三维空间定位设备"><a href="#三维空间定位设备" class="headerlink" title="三维空间定位设备"></a>三维空间定位设备</h4><h5 id="空间跟踪定位器"><a href="#空间跟踪定位器" class="headerlink" title="空间跟踪定位器"></a>空间跟踪定位器</h5><p>又称三维空间传感器，是一种能实时地检测物体空间运动的装置，可以得到物体在六个自由度上相对于某个固定物体的位移，包括X、Y、Z坐标上的位置以及围绕X、Y、Z轴的旋转值（转动、俯仰、摇摆）。称为“非接触式传感器”。</p>
<h6 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h6><ol>
<li>定位精度：传感器所能测出来的最小位置变化。</li>
<li>位置修改速率：传感器在一秒内所能完成的测量次数。</li>
<li>延时：被检测物体的某个动作与传感器测出该动作的时间间隔。</li>
</ol>
<h5 id="数据手套"><a href="#数据手套" class="headerlink" title="数据手套"></a>数据手套</h5><p>在虚拟环境中，操作者通过数据手套可以用手去抓会推动虚拟物体，以及做出各种手势命令。</p>
<h6 id="数据手套的作用："><a href="#数据手套的作用：" class="headerlink" title="数据手套的作用："></a>数据手套的作用：</h6><ol>
<li>捕捉手指和手腕的瞎蒙对运动，提供各种手势信号；</li>
<li>配合一个六自由度的跟踪器，跟踪手的实际位置和方向。</li>
</ol>
<h6 id="组成-3"><a href="#组成-3" class="headerlink" title="组成"></a>组成</h6><ol>
<li>位置、方向传感器</li>
<li>沿每个手指背部安装的一组有保护套的光纤导线。</li>
</ol>
<h5 id="触觉和力反馈器"><a href="#触觉和力反馈器" class="headerlink" title="触觉和力反馈器"></a>触觉和力反馈器</h5><p>手指触觉反馈器的实现主要通过视觉、气压感、振动触觉、电子触觉和神经模拟。</p>
<h4 id="三维显示设备"><a href="#三维显示设备" class="headerlink" title="三维显示设备"></a>三维显示设备</h4><h5 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h5><h6 id="立体视觉原理"><a href="#立体视觉原理" class="headerlink" title="立体视觉原理"></a>立体视觉原理</h6><p>通过立体摄像机获取具有细微差别的左右两组图像，然后通过相应的3D显示技术分别播放给人的左、右眼以模拟人在现实中观察物体的情形，从而在人脑中呈现虚拟的立体场景。</p>
<h6 id="立体视觉显示技术"><a href="#立体视觉显示技术" class="headerlink" title="立体视觉显示技术"></a>立体视觉显示技术</h6><p>主动式立体模式和被动式立体模式。</p>
<p>主动式立体模式常用于立体电视及立体投影仪设备，对应用户的左右眼影像将按照顺序<strong>交替显示</strong>，用户使用LCD立体眼镜保持与立体影像的同步，这种模式可以产生高质量的立体效果。</p>
<p>被动式立体模式常用于影院环境，需要使用两套显示设备以及投影设备分别生成左右眼影像并进行投影，不同的投影分别使用不同角度的<strong>偏振光</strong>来区别左右眼影像，用户使用偏振光眼镜保持立体影像的同步。</p>
<h6 id="头盔式显示器"><a href="#头盔式显示器" class="headerlink" title="头盔式显示器"></a>头盔式显示器</h6><p>头盔式显示器（Head Mounted Display，HMD，）是一种立体图形显示设备，可单独与主机相连以接受来自主机的三维虚拟现实场景信息。</p>
<p>分类：单通道和双通道。</p>
<h5 id="投影拼接融合的沉浸式显示环境"><a href="#投影拼接融合的沉浸式显示环境" class="headerlink" title="投影拼接融合的沉浸式显示环境"></a>投影拼接融合的沉浸式显示环境</h5><p>投影拼接融合是指将多台投影仪所投射出的画面进行边缘融入，显示出无缝、大幅面、高亮度、高分辨率的整幅画面，为观众提供全沉浸式的观看体验及多用户参与的交互体验。</p>
<h6 id="投影拼接融合技术组成部分"><a href="#投影拼接融合技术组成部分" class="headerlink" title="投影拼接融合技术组成部分"></a>投影拼接融合技术组成部分</h6><ol>
<li>几何校正:对投影图像变形失真和重叠区域画面纹理不齐进行的误差校正方法。</li>
<li>亮度/色彩校正：对于投影的画面拼接中有投影光线和画面重叠部分的融合处理。</li>
</ol>
<h6 id="投影拼接融合分类"><a href="#投影拼接融合分类" class="headerlink" title="投影拼接融合分类"></a>投影拼接融合分类</h6><p>根据拼接融合方式，分为：手动拼接融合和自动拼接融合。</p>
<p>手动拼接融合的步骤：</p>
<ol>
<li>几何校正：为每个投影仪的实际投影区域添加控制网格，通过调整控制网格实现投影区域的拼接。细化并调整控制网格，以使得投影画面的重叠区域实现精准对齐。</li>
<li>亮度融合：手动拖动调整每台投影仪实际投影区域的重合区域亮度衰减曲线，以消除重合区域的过暗与过亮现象。</li>
<li>颜色融合：分别调整每台投影仪白色、红色、绿色、蓝色值阈值，使得两台投影仪颜色基本相同。</li>
</ol>
<p>手动拼接实现简单，拼接效果可控；但是手动拼接系统需要专业人员操作，拼接耗时，且拼接效果取决于操作人员的主观判断。</p>
<h5 id="裸眼立体显示设备"><a href="#裸眼立体显示设备" class="headerlink" title="裸眼立体显示设备"></a>裸眼立体显示设备</h5><h6 id="裸眼立体显示器实现技术分类"><a href="#裸眼立体显示器实现技术分类" class="headerlink" title="裸眼立体显示器实现技术分类"></a>裸眼立体显示器实现技术分类</h6><ol>
<li>视差壁（Parallax Barrier）技术</li>
<li>柱状透镜（Lenticular Lens）技术</li>
</ol>
<h2 id="行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换-P121"><a href="#行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换-P121" class="headerlink" title="行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换(P121)"></a>行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换(P121)</h2><h3 id="行为模型"><a href="#行为模型" class="headerlink" title="行为模型"></a>行为模型</h3><h4 id="GOMS"><a href="#GOMS" class="headerlink" title="GOMS"></a>GOMS</h4><p>通过目标 (Goal)、操作 (Operator)、方法 (Method) 以及选择规则 (Selection) 四个元素来描述用户的行为。</p>
<p>GOMS是在交互系统中用来分析建立用户行为的模型。它采用“分而治之”的思想，将一个任务进行多层次的细化</p>
<ol>
<li>目标 Goals<br>目标就是用户执行任务最终想要得到的结果,它可以在不同的层次中进行定义。</li>
<li>操作 Operators<br>操作是任务分析到最低层时的行为，是用户为了完成任务所必须执行的基本动作。 </li>
<li>方法 Methods<br>方法是描述如何完成目标的过程。一个方法本质上来说是内部的算法，用来确定子目标序列及完成目标所需要的操作。</li>
<li>选择 Selection<br>选择是用户要遵守的判定规则，以确定在特定环境下所要使用的方法。<br>当有多个方法可供选择时，GOMS中并不认为这是一个随机的选择，而是尽量来预测会使用哪个方法,这需要根据特定用户、系统的状态、目标的细节来预测要选择哪种方法。</li>
</ol>
<h5 id="GOMS的应用"><a href="#GOMS的应用" class="headerlink" title="GOMS的应用"></a>GOMS的应用</h5><p>作为一种人机交互界面表示的理论模型，GOMS是人机交互研究领域内少有的几个广为人知的模型之一，并被称为最成熟的工程典范，该模型在计算机系统的评估方面也有广泛的应用。</p>
<h5 id="GOMS的局限性"><a href="#GOMS的局限性" class="headerlink" title="GOMS的局限性"></a>GOMS的局限性</h5><ul>
<li>GOMS没有清楚的描述错误处理的过程，假设用户完全按一种正确的方式进行人机交互，因此只针对那些不犯任何错误的专家用户。</li>
<li>GOMS对于任务之间的关系描述过于简单,只有顺序和选择.另外选择关系通过非形式化的附加规则描述，实现起来也比较困难。</li>
<li>GOMS把所有的任务都看作是面向操作目标的，而忽略了一些任务所要解决的问题本质以及用户间的个体差异，它的建立不是基于现有的认知心理学，无法代表真正的认知过程。   </li>
</ul>
<h4 id="LOTOS"><a href="#LOTOS" class="headerlink" title="LOTOS"></a>LOTOS</h4><p>国际标准形式描述语言，适于描述具有并发、交互、反馈和不确定性等特点的并发（concurrent）系统中的行为。</p>
<p>开始作为一种描述网络协议的语言，由于交互系统、特别是多通道交互系统有并发系统的特点，因此成为用来描述交互系统的行为模型。</p>
<h5 id="LOTOS算子的思想"><a href="#LOTOS算子的思想" class="headerlink" title="LOTOS算子的思想"></a>LOTOS算子的思想</h5><ul>
<li>系统的外部可见行为可以看作是由一个有时序关系的交互序列组成。</li>
<li>系统由一系列进程组成，进程同环境之间通过称为“关口”（gates）的交互点进行交互。</li>
<li>两个以上的进程在执行同一个外部可见的行为时会发生交互操作，进行数据交换、信息传递、协调同步等操作。</li>
<li>进程行为用“行为表达式”来描述，复杂的行为由简单的行为表达式通过表示时序关系的LOTOS算符组合而成。</li>
<li>在将LOTOS思想用于人机交互的行为模型时，用进程之间的约束关系来描述交互子任务之间的关系。 </li>
</ul>
<h5 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符(*)"></a>基本运算符(*)</h5><ul>
<li><p>T1 ||| T2（交替Interleaving）<br>T1和T2两个任务相互独立执行，可按任意顺序执行，但永远不会同步。 </p>
</li>
<li><p>T1 [] T2（选择Choice）<br>需要在T1，T2中选择一个执行，一旦选择某一个后，必须执行它直到结束，在这中间另一个再无执行机会。 </p>
</li>
<li><p>T1 | [a1,…,an] | T2（同步Synchronization）<br>任务T1，T2必须在动作（a1,……，an）处保持同步 </p>
</li>
<li><p>T1 [&gt; T2（禁止Deactivation）<br>一旦T2任务被执行，T1便无效（不活动）</p>
</li>
<li><p>T1 &gt;&gt; T2（允许Enabling）<br>当T1成功结束后才允许T2执行 </p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bafe3765f1e848338faaf7d6c13fd2a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOAL:中国象棋</span><br><span class="line">  [&gt;:</span><br><span class="line">  GOAL:运行</span><br><span class="line">    |||:</span><br><span class="line">    *GOAL:走棋</span><br><span class="line">      ACTION:自动记录棋谱</span><br><span class="line">      &gt;&gt;:</span><br><span class="line">      GOAL:当前方走</span><br><span class="line">        &gt;&gt;:</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子 </span><br><span class="line">      GOAL:对弈方走 </span><br><span class="line">        &gt;&gt;</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子</span><br><span class="line">    *GOAL:打谱</span><br><span class="line">       []:</span><br><span class="line">       OPRATOR:加速</span><br><span class="line">       OPRATOR:减速</span><br><span class="line">       OPRATOR:暂停</span><br><span class="line">       OPRATOR:恢复</span><br><span class="line">  GOAL:退出</span><br></pre></td></tr></table></figure>

<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>LOTOS最大的优越性在于可以构造一套现成的自动化工具，利用这些工具，可自动进行错误检测，但它过于形式化的记法比较晦涩难懂。</p>
<h4 id="UAN"><a href="#UAN" class="headerlink" title="UAN"></a>UAN</h4><p>UAN—User Action Notation</p>
<p>UAN是一种简单的符号语言，主要描述用户的行为序列以及在执行任务时所用的界面物理对象。</p>
<p>尽管UAN属于一种行为模型，但作为一种任务描述语言，它又涉及一定程度的系统行为的描述，因而它兼有行为模型和结构模型的一些特点。</p>
<h5 id="UAN的特点"><a href="#UAN的特点" class="headerlink" title="UAN的特点"></a>UAN的特点</h5><ol>
<li><p>预定义一些标识符</p>
</li>
<li><p>采用一种表格结构来表示任务</p>
<table>
<thead>
<tr>
<th align="center">任务：任务名称</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户行为</td>
<td>界面反馈</td>
<td>界面状态</td>
</tr>
</tbody></table>
</li>
<li><p>界面被分解成一些类似层次结构的异步任务，每个任务的实现都用表格来描述，用户动作的关联性和时序关系由表格的行列对齐关系和从上到下、从左到右的阅读顺序来确定。</p>
</li>
</ol>
<h5 id="UAN的标识符"><a href="#UAN的标识符" class="headerlink" title="UAN的标识符"></a>UAN的标识符</h5><ol>
<li>用户动作标识符</li>
<li>条件选择标识符</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>UAN模型更接近于实现，界面状态和界面反馈用一般的程序语言描述，实现起来比较方便，当然这种描述由于接近于程序语言，因此设计时需要一定的编程基础</p>
<p>UAN模型在精确刻画各成分之间的各种平行和串行的时序关系方面尚显不足，任务之间的时序关系没有明确表示出来，当所描述的界面使用多种输入设备和有若干可选交互路径时，比较繁琐。 </p>
<h5 id="层次化的界面描述方法"><a href="#层次化的界面描述方法" class="headerlink" title="层次化的界面描述方法"></a>层次化的界面描述方法</h5><p>任务分析(GOMS) –&gt; 逐步精化(LOTOS) –&gt;  原子任务说明(UAN)</p>
<h4 id="G-U-L模型"><a href="#G-U-L模型" class="headerlink" title="G-U-L模型"></a>G-U-L模型</h4><p>可以考虑将GOMS、UAN、LOTOS中模型结合为一个预测行为模型：G-U-L模型。</p>
<p>G-U-L运用GOMS原理为基础进行任务分解，建立基本的行为模型，原子操作由UAN模型描述，在此基础上，运用LOTOS算符来表示任务目标之间的时序关系。</p>
<p>在G-U-L模型中没有加入规则，在表示目标之间的关系中也未考虑同步。这主要考虑到规则的转换要涉及到推理、建立知识库等问题，而同步的问题的描述和转换也非常的复杂，这会在工作的初期造成非常大的困难。</p>
<h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><h4 id="产生式规则"><a href="#产生式规则" class="headerlink" title="产生式规则"></a>产生式规则</h4><p><strong>形式化语言的描述</strong>，这种结构的方法从理论上可以引导界面设计者及界面工具的设计者进行有效的设计。</p>
<p>又称为上下文无关文法，将人机交互对话看作是一种语言，运用<strong>基于语法</strong>的方法来描述交互对话。</p>
<p>产生式规则是一种形式化语言，这些规则可用于描述人机交互界面。产生式规则的一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if  condition  then  action</span><br><span class="line">这些规则可以表示为不同的形式，如</span><br><span class="line">condition → action</span><br><span class="line">condition：action</span><br></pre></td></tr></table></figure>

<p>规则定义的顺序并不重要，只要与规则中的条件相匹配，就可以激活相应的动作。产生式规则系统可以是事件引导的，也可以是状态引导的，或者两者都有。 </p>
<h5 id="事件引导的系统"><a href="#事件引导的系统" class="headerlink" title="事件引导的系统"></a>事件引导的系统</h5><h6 id="事件的主要类型"><a href="#事件的主要类型" class="headerlink" title="事件的主要类型"></a>事件的主要类型</h6><ul>
<li><p>用户事件（user event），Sel-line表示从菜单中选择line命令，C-point 和D-point表示用户在绘图平面上单击和双击鼠标 </p>
</li>
<li><p>内部事件，用于保持对话状态，如start-line 表示开始画线后的状态，rest- line表示选择了第一个点之后的状态。 </p>
</li>
<li><p>系统响应事件，以尖括号表示可见或可听的系统响应，如<code>&lt;highlight  &#39;line&#39;&gt;</code>，把菜单项’line’ 高亮度显示，<code>&lt;draw  line&gt;</code>表示在屏幕上显示直线，<code>&lt;rubber  band  on&gt; </code>表示橡皮筋绘制方式打开，<code>&lt;rubber band  off&gt;</code>表示橡皮筋绘制方式关闭。 </p>
</li>
</ul>
<h6 id="对话控制"><a href="#对话控制" class="headerlink" title="对话控制"></a>对话控制</h6><ul>
<li>对话控制主要负责事件的产生和规则的匹配，可以看到在每一时刻系统内存中会保存一些内部事件，当产生一个事件时，可能是用户事件（如单击鼠标），也可能是内部事件（如时钟事件等）。</li>
<li>对话控制就要将所有的产生式规则与事件集合进行匹配，这个过程是复杂的而且是耗时的，当产生式很多并且产生式规则的条件复杂时，匹配算法的效率就显的更为重要，因此需要设计好的数据结构和匹配算法来提高匹配规则的效率。</li>
<li>可以将规则和事件进行分组和分层。 </li>
</ul>
<h5 id="状态引导的系统"><a href="#状态引导的系统" class="headerlink" title="状态引导的系统"></a>状态引导的系统</h5><p>状态引导的系统在系统内存保存的不再是动态的随时进出的事件，而是一些表示系统的<strong>当前状态</strong>的属性，这些属性在不同的时刻有不同的值。</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul>
<li>当产生式规则的条件和状态匹配时将激活该产生式规则，对于某一特定的属性，如果前面的状态需要改变成新的状态时才需要在产生规则的后面标注。</li>
<li>属性的永久特性有时会引起一些奇怪的错误。</li>
</ul>
<h5 id="混合引导系统"><a href="#混合引导系统" class="headerlink" title="混合引导系统"></a>混合引导系统</h5><p>有的对话过程比较适合于事件引导方式，有的对话过程适合于状态引导方式，当然也可以将两者结合起来，例如采用下面的形式：<br>event: condition → action<br>来描述一个产生式规则，事件用来计划产生式规则，如果条件不满足，即当前系统内存中的状态和产生式的规则不匹配，则无法激活规则，另外当状态改变时，产生式规则中的action本身也可以产生新的事件，从而可以激活另一条规则。 </p>
<h5 id="产生式规则总结"><a href="#产生式规则总结" class="headerlink" title="产生式规则总结"></a>产生式规则总结</h5><ul>
<li>描述操作时序能力强，并发顺序均可</li>
<li>无法描述误操作</li>
<li>界面复杂时，状态、事件复杂，产生式过多，要求产生式匹配算法性能高</li>
</ul>
<h4 id="状态转换网络"><a href="#状态转换网络" class="headerlink" title="状态转换网络"></a>状态转换网络</h4><p>用结构化的方法来描述人机交互的一般过程，是一种图示化的结构。</p>
<p>状态转换网络（STN）的基本思想是定义一个具有一定数量状态的转换机，称之为有限状态机-Finite State Machine(FSM)，FSM从外部世界中接收到事件，并能使FSM从一个状态转换到另一个状态。</p>
<h5 id="传统状态转换网络"><a href="#传统状态转换网络" class="headerlink" title="传统状态转换网络"></a>传统状态转换网络</h5><h6 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h6><p>当发生一个外部或内部事件时，系统就会从一个状态转换到另外一个状态，这称为状态转换。</p>
<p>外部事件主要由用户操作外部输入设备来产生，内部事件可以是系统产生的事件，如时钟事件，也可以是为了改变系统的状态和行为而产生的事件，如当一个任务完成后可以激活另一个任务等。</p>
<p>一个状态转换与一对状态相关联。</p>
<p>一般的系统具有很多个状态，假设系统由n个状态组成，状态之间的转换最多可能有n*(n-1)个。</p>
<p><img src="https://img-blog.csdnimg.cn/7e6fec3c63db44e4abb57af67eedc1ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h6><ul>
<li><p>状态转换网络比相应的文本解决方案更易于设计、理解、修改和文档化，它给出了对行为的精确的、甚至是格式化的定义。</p>
</li>
<li><p>存在着一定的局限性，一个最大的缺陷是需要定义出系统的所有状态，这对于小型的系统是没有问题的，但是在一个较大的系统中，系统会很快崩溃，状态的数目是呈指数级增长的，同时状态的增长直接导致了状态转换网络过于复杂、无法实际应用。  </p>
</li>
</ul>
<h5 id="扩展状态转换网络"><a href="#扩展状态转换网络" class="headerlink" title="扩展状态转换网络"></a>扩展状态转换网络</h5><p><img src="https://img-blog.csdnimg.cn/4fe6587e131442d58798b1542a05172f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="行为模型和结构模型的转换-P140-P148"><a href="#行为模型和结构模型的转换-P140-P148" class="headerlink" title="行为模型和结构模型的转换 (P140~P148)"></a>行为模型和结构模型的转换 (P140~P148)</h3><h2 id="掌握图形用户界面的基本原则-P100"><a href="#掌握图形用户界面的基本原则-P100" class="headerlink" title="掌握图形用户界面的基本原则(P100)"></a>掌握图形用户界面的基本原则(P100)</h2><h3 id="图形用户界面的主要思想"><a href="#图形用户界面的主要思想" class="headerlink" title="图形用户界面的主要思想"></a>图形用户界面的主要思想</h3><h4 id="1-桌面隐喻"><a href="#1-桌面隐喻" class="headerlink" title="1. 桌面隐喻"></a>1. 桌面隐喻</h4><p>桌面隐喻是指在用户界面中用人们熟悉的桌面上的图例清楚地表示计算机可以处理的能力。</p>
<h4 id="2-所见即所得"><a href="#2-所见即所得" class="headerlink" title="2. 所见即所得"></a>2. 所见即所得</h4><p>在WYSIWYG交互界面中，其所显示的用户交互行为与应用程序最终产生的结果是一致的。</p>
<h4 id="3-直接操纵"><a href="#3-直接操纵" class="headerlink" title="3. 直接操纵"></a>3. 直接操纵</h4><p>直接操纵是指可以把操作的对象、属性、关系显式地表示出来，用光笔、鼠标、触摸屏或数据手套等指点设备直接从屏幕上获取形象化命令与数据的过程。</p>
<h3 id="图形用户界面设计的一般原则"><a href="#图形用户界面设计的一般原则" class="headerlink" title="图形用户界面设计的一般原则"></a>图形用户界面设计的一般原则</h3><ol>
<li>界面具有一致性</li>
<li>常用操作有快捷方式</li>
<li>提供必要的错误处理能力</li>
<li>提供信息反馈</li>
<li>允许可逆操作</li>
<li>设计良好的联机帮助</li>
<li>合理划分并高效地使用显示屏幕</li>
</ol>
<h2 id="掌握移动互联网设计的基本原则及其特点"><a href="#掌握移动互联网设计的基本原则及其特点" class="headerlink" title="掌握移动互联网设计的基本原则及其特点"></a>掌握移动互联网设计的基本原则及其特点</h2><h3 id="移动互联网的简介-P211"><a href="#移动互联网的简介-P211" class="headerlink" title="移动互联网的简介(P211)"></a>移动互联网的简介(P211)</h3><p>移动互联网概念的理解可能因人而异，特别是与无线互联网（Wireless Internet）可能会当成一回事。<br>从概念上而言，移动与无线是两个不同的概念，<br>在很多情况下，无线与移动是两个重叠的概念，但在另外一些情况下，这两者又有明显的区别，这也使得移动互联网的概念可以从狭义与广义两个角度来理解。 </p>
<ul>
<li>从狭义的角度上来讲，移动互联网指的就是基于分组交换技术的无线数据通信技术，有时可能会被称之为无线互联网（Wireless Internet）。 </li>
<li>从广义的角度上来讲，移动互联网不一定局限于一般的无线数据通信方式，与无线互联网的概念有一定的区别，我们可以从设备的移动性与数据连接方式这两个方面来说明。</li>
</ul>
<h3 id="Web界面设计原则-P187"><a href="#Web界面设计原则-P187" class="headerlink" title="Web界面设计原则(P187)"></a>Web界面设计原则(P187)</h3><h4 id="1-以用户为中心"><a href="#1-以用户为中心" class="headerlink" title="1. 以用户为中心"></a>1. 以用户为中心</h4><p>要求把用户放在第一位。设计时既要考虑用户的共性，同时也要考虑他们之间的差异性。</p>
<h4 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2. 一致性"></a>2. 一致性</h4><p>Web界面设计还必须考虑内容和形式的一致性。其次，Web界面自身的风格也要一致性，保持统一的整体形象。</p>
<h4 id="3-简洁与明确"><a href="#3-简洁与明确" class="headerlink" title="3. 简洁与明确"></a>3. 简洁与明确</h4><p>Web界面设计是设计的一种，要求简练、明确。</p>
<h4 id="4-体现特色"><a href="#4-体现特色" class="headerlink" title="4.体现特色"></a>4.体现特色</h4><p>只有丰富特色、内容翔实的网页才能使浏览者驻足阅读。特色鲜明的Web网站是精心策划的结果，只有独特的创意和赏心悦目的网页设计才能在一瞬间打动浏览者。</p>
<h4 id="5-兼顾不同的浏览器"><a href="#5-兼顾不同的浏览器" class="headerlink" title="5. 兼顾不同的浏览器"></a>5. 兼顾不同的浏览器</h4><h4 id="6-明确的导航设计"><a href="#6-明确的导航设计" class="headerlink" title="6. 明确的导航设计"></a>6. 明确的导航设计</h4><p>网站首页导航应尽量展现整个网站的架构和内容，要能让浏览者确切地知道自己在整个网站中的位置，可以确定下一步的浏览去向。</p>
<h3 id="移动界面设计存在的限制-P217"><a href="#移动界面设计存在的限制-P217" class="headerlink" title="移动界面设计存在的限制(P217)"></a>移动界面设计存在的限制(P217)</h3><ol>
<li>资源相对匮乏</li>
<li>移动设备的种类繁多</li>
<li>连接方式复杂</li>
</ol>
<h3 id="移动界面设计的原则"><a href="#移动界面设计的原则" class="headerlink" title="移动界面设计的原则"></a>移动界面设计的原则</h3><ol>
<li>简单直观</li>
<li>个性化设计</li>
<li>易于检索</li>
<li>界面风格一致</li>
<li>避免不必要的文本输入</li>
<li>根据用户的要求使服务个性化</li>
<li>最大限度地避免用户出错</li>
<li>文本信息应当本地化</li>
</ol>
<h2 id="掌握几种基本的软件体系结构"><a href="#掌握几种基本的软件体系结构" class="headerlink" title="掌握几种基本的软件体系结构"></a>掌握几种基本的软件体系结构</h2><h2 id="熟悉LOTOS的几种关系及其语法-P124"><a href="#熟悉LOTOS的几种关系及其语法-P124" class="headerlink" title="熟悉LOTOS的几种关系及其语法(P124)"></a>熟悉LOTOS的几种关系及其语法(P124)</h2><ul>
<li><p>T1 ||| T2（交替Interleaving）<br>T1和T2两个任务相互独立执行，可按任意顺序执行，但永远不会同步。 </p>
</li>
<li><p>T1 [] T2（选择Choice）<br>需要在T1，T2中选择一个执行，一旦选择某一个后，必须执行它直到结束，在这中间另一个再无执行机会。 </p>
</li>
<li><p>T1 | [a1,…,an] | T2（同步Synchronization）<br>任务T1，T2必须在动作（a1,……，an）处保持同步 </p>
</li>
<li><p>T1 [&gt; T2（禁止Deactivation）<br>一旦T2任务被执行，T1便无效（不活动）</p>
</li>
<li><p>T1 &gt;&gt; T2（允许Enabling）<br>当T1成功结束后才允许T2执行 </p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c87f8d7319344282aee17bc5e2522ef6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/eda4dc20664b476ab8b832c2230e203e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOAL:中国象棋</span><br><span class="line">  [&gt;:</span><br><span class="line">  GOAL:运行</span><br><span class="line">    |||:</span><br><span class="line">    *GOAL:走棋</span><br><span class="line">      ACTION:自动记录棋谱</span><br><span class="line">      &gt;&gt;:</span><br><span class="line">      GOAL:当前方走</span><br><span class="line">        &gt;&gt;:</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子 </span><br><span class="line">      GOAL:对弈方走 </span><br><span class="line">        &gt;&gt;</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子</span><br><span class="line">    *GOAL:打谱</span><br><span class="line">       []:</span><br><span class="line">       OPRATOR:加速</span><br><span class="line">       OPRATOR:减速</span><br><span class="line">       OPRATOR:暂停</span><br><span class="line">       OPRATOR:恢复</span><br><span class="line">  GOAL:退出</span><br></pre></td></tr></table></figure>

<h2 id="什么是可用性及其可用性的基本原则（P247）"><a href="#什么是可用性及其可用性的基本原则（P247）" class="headerlink" title="什么是可用性及其可用性的基本原则（P247）"></a>什么是可用性及其可用性的基本原则（P247）</h2><h3 id="可用性定义"><a href="#可用性定义" class="headerlink" title="可用性定义"></a>可用性定义</h3><p>指特定的用户在特定环境下使用产品并达到特定目标的效力、效率和满意的程度。<br>这五个方面集中反映了用户对产品的需求，从它们的英文表达上被归纳为五个“E：</p>
<ol>
<li>有效性：怎样准确、完整地完成工作或达到目标</li>
<li>效率：怎样快速地完成工作</li>
<li>吸引力：用户界面如何吸引用户进行交互并在使用中得到满意和满足</li>
<li>容错能力：产品避免错误的发生并帮助用户修正错误的能力</li>
<li>易于学习：支持用户对产品的入门使用及在以后使用过程中的持续学习</li>
</ol>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><h4 id="1-可学习型"><a href="#1-可学习型" class="headerlink" title="1. 可学习型"></a>1. 可学习型</h4><p>可学习性是指交互系统能否让新手学会如何使用系统，以及如何达到最佳交互效能。</p>
<h5 id="1-可预见性"><a href="#1-可预见性" class="headerlink" title="1. 可预见性"></a>1. 可预见性</h5><p>不应该让用户感到过分惊奇；用户利用前面交互过程的了解就足以确定后面交互的结果。</p>
<h5 id="2-同步性"><a href="#2-同步性" class="headerlink" title="2. 同步性"></a>2. 同步性</h5><p>指用户依据界面当前状态评估过去操作造成影响的能力，也就是说用户能不能同步地知道交互操作的结果。</p>
<h5 id="3-熟悉性"><a href="#3-熟悉性" class="headerlink" title="3. 熟悉性"></a>3. 熟悉性</h5><h5 id="4-通用性"><a href="#4-通用性" class="headerlink" title="4. 通用性"></a>4. 通用性</h5><p>在交互中尽可能地提供一些通用的或能够从现有功能类推出来的功能。</p>
<h5 id="5-一致性"><a href="#5-一致性" class="headerlink" title="5. 一致性"></a>5. 一致性</h5><p>在相似的环境下或执行相似任务时一般会执行相似的行为。</p>
<h4 id="2-灵活性"><a href="#2-灵活性" class="headerlink" title="2.灵活性"></a>2.灵活性</h4><p>灵活性体现了用户与系统交流信息方式的多样性。</p>
<h5 id="1-可定制性"><a href="#1-可定制性" class="headerlink" title="1. 可定制性"></a>1. 可定制性</h5><p>用户或系统修改界面的能力。</p>
<h5 id="2-对话主动性"><a href="#2-对话主动性" class="headerlink" title="2. 对话主动性"></a>2. 对话主动性</h5><p>将人机交互的双方看作是一对对话者，重点是谁是对话的发起人。</p>
<h5 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h5><h5 id="4-可互换性"><a href="#4-可互换性" class="headerlink" title="4. 可互换性"></a>4. 可互换性</h5><p>任务的执行可以在系统控制和用户控制间进行转移。</p>
<h5 id="5-可替换性"><a href="#5-可替换性" class="headerlink" title="5. 可替换性"></a>5. 可替换性</h5><p>要求等量的数值可以彼此交换。</p>
<h4 id="3-鲁棒性"><a href="#3-鲁棒性" class="headerlink" title="3.鲁棒性"></a>3.鲁棒性</h4><p>用户使用计算机的目的是达到某种目标。能不能成功地达到目标和能不能对到达的目标进行评估就体现为交互的鲁棒性.</p>
<h5 id="1-可观察性"><a href="#1-可观察性" class="headerlink" title="1. 可观察性"></a>1. 可观察性</h5><p>允许用户通过观察交互界面的表现来了解系统的内部状态。</p>
<h5 id="2-可恢复性"><a href="#2-可恢复性" class="headerlink" title="2. 可恢复性"></a>2. 可恢复性</h5><p>用户意识到发生了错误并进行更正的能力。</p>
<h5 id="3-响应性"><a href="#3-响应性" class="headerlink" title="3. 响应性"></a>3. 响应性</h5><p>反映了系统与用户之间交流的频率。</p>
<h5 id="4-任务规范性"><a href="#4-任务规范性" class="headerlink" title="4. 任务规范性"></a>4. 任务规范性</h5><p>系统为完成交互任务所提供的功能是否规范。</p>
<h2 id="案例综合分析-P277"><a href="#案例综合分析-P277" class="headerlink" title="案例综合分析(P277)"></a>案例综合分析(P277)</h2>]]></content>
      <categories>
        <category>人机交互</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>人机交互</tag>
      </tags>
  </entry>
  <entry>
    <title>代理和反射</title>
    <url>/135xyq.github.io/2021/12/31/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>Property Descriptor 属性描述符  是一个普通对象，用于描述一个属性的相关信息</p>
<p>通过<code>Object.getOwnPropertyDescriptor(对象, 属性名)</code>可以得到一个对象的某个属性的属性描述符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>value：属性值</li>
<li>configurable：该属性的描述符是否可以修改</li>
<li>enumerable：该属性是否可以被枚举</li>
<li>writable：该属性是否可以被重新赋值</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">const obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj))</span><br><span class="line">a: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">b: &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要为某个对象添加属性时 或 修改属性时， 配置其属性描述符，可以使用下面的代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(对象, 属性名, 描述符);</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(对象, 多个属性的描述符)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">7</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h2><p>属性描述符中，如果配置了 get 和 set 中的任何一个，则该属性，不再是一个普通属性，而变成了存取器属性。</p>
<p>get 和 set配置均为函数，如果一个属性是存取器属性，则读取该属性时，会运行get方法，将get方法得到的返回值作为属性值；如果给该属性赋值，则会运行set方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了get方法!&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了set方法！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b)</span><br><span class="line">输出结果：</span><br><span class="line">调用了set方法！</span><br><span class="line">调用了get方法!</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">变成正常的属性（将值先存储到其他变量中）</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了get方法!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj._a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了set方法！&quot;</span>)</span><br><span class="line">        obj._a = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b)</span><br><span class="line"></span><br><span class="line">调用了set方法！</span><br><span class="line">调用了get方法!</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>存取器属性最大的意义，在于可以控制属性的读取和赋值。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="1-Reflect是什么？"><a href="#1-Reflect是什么？" class="headerlink" title="1. Reflect是什么？"></a>1. Reflect是什么？</h3><p>Reflect是一个内置的JS对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些JS底层功能</p>
<p>由于它类似于其他语言的<strong>反射</strong>，因此取名为Reflect</p>
<h3 id="2-它可以做什么？"><a href="#2-它可以做什么？" class="headerlink" title="2. 它可以做什么？"></a>2. 它可以做什么？</h3><p>使用Reflect可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中  等等功能</p>
<h3 id="3-这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？"><a href="#3-这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？" class="headerlink" title="3. 这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？"></a>3. 这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？</h3><p>有一个重要的理念，在ES5就被提出：减少魔法、让代码更加纯粹</p>
<p>这种理念很大程度上是受到函数式编程的影响</p>
<p>ES6进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的API，并高度聚合到某个对象中，于是，就造就了Reflect对象</p>
<p>因此，你可以看到Reflect对象中有很多的API都可以使用过去的某种语法或其他API实现。</p>
<h3 id="4-它里面到底提供了哪些API呢？"><a href="#4-它里面到底提供了哪些API呢？" class="headerlink" title="4. 它里面到底提供了哪些API呢？"></a>4. 它里面到底提供了哪些API呢？</h3><ul>
<li>Reflect.set(target, propertyKey, value): 设置对象target的属性propertyKey的值为value，等同于给对象的属性赋值</li>
<li>Reflect.get(target, propertyKey): 读取对象target的属性propertyKey，等同于读取对象的属性值</li>
<li>Reflect.apply(target, thisArgument, argumentsList)：调用一个指定的函数，并绑定this和参数列表。等同于函数调用</li>
<li>Reflect.deleteProperty(target, propertyKey)：删除一个对象的属性</li>
<li>Reflect.defineProperty(target, propertyKey, attributes)：类似于Object.defineProperty，不同的是如果配置出现问题，返回false而不是报错</li>
<li>Reflect.construct(target, argumentsList)：用构造函数的方式创建一个对象</li>
<li>Reflect.has(target, propertyKey): 判断一个对象是否拥有一个属性</li>
<li>其他API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li>
</ul>
<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><p>代理：提供了修改底层实现的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//代理一个目标对象</span></span><br><span class="line"><span class="comment">//target：目标对象</span></span><br><span class="line"><span class="comment">//handler：是一个普通对象，其中可以重写底层实现</span></span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新增的集合</title>
    <url>/135xyq.github.io/2021/12/31/%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="其他集合"><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h1><hr>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p><strong>set用于存放不重复的数据</strong></p>
<h3 id="1-如何创建set集合"><a href="#1-如何创建set集合" class="headerlink" title="1. 如何创建set集合"></a>1. 如何创建set集合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//创建一个没有任何内容的set集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(iterable); <span class="comment">//创建一个具有初始内容的set集合，内容来自于可迭代对象每一次迭代的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line">运行结果：</span><br><span class="line"><span class="function"><span class="title">Set</span>(<span class="params"><span class="number">5</span></span>)</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-如何对set集合进行后续操作"><a href="#2-如何对set集合进行后续操作" class="headerlink" title="2. 如何对set集合进行后续操作"></a>2. 如何对set集合进行后续操作</h3><ul>
<li>add(数据): 添加一个数据到set集合末尾，如果数据已存在，则不进行任何操作<ul>
<li>set使用Object.is的方式判断两个数据是否相同，但是，针对+0和-0，set认为是相等<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="number">1</span>);</span><br><span class="line">s.add(<span class="number">2</span>);</span><br><span class="line">s.add(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>has(数据): 判断set中是否存在对应的数据</li>
<li>delete(数据)：删除匹配的数据，返回是否删除成功</li>
<li>clear()：清空整个set集合</li>
<li>size: 获取set集合中的元素数量，只读属性，无法重新赋值</li>
</ul>
<h3 id="3-如何与数组进行相互转换"><a href="#3-如何与数组进行相互转换" class="headerlink" title="3. 如何与数组进行相互转换"></a>3. 如何与数组进行相互转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([x,x,x,x,x]);</span><br><span class="line"><span class="comment">// set本身也是一个可迭代对象，每次迭代的结果就是每一项的值</span></span><br><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将集合变为数组</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</span><br><span class="line"><span class="keyword">const</span> result = [...s]</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h3 id="4-如何遍历"><a href="#4-如何遍历" class="headerlink" title="4. 如何遍历"></a>4. 如何遍历</h3><p>1). 使用for-of循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>2). 使用set中的实例方法forEach</p>
<p><strong>注意：set集合中不存在下标，因此forEach中的回调的第二个参数和第一个参数是一致的，均表示set中的每一项</strong></p>
<h3 id="set的应用"><a href="#set的应用" class="headerlink" title="set的应用"></a>set的应用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">24</span>, <span class="number">42</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">90</span>, <span class="number">86</span>, <span class="number">32</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">24</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">38</span>, <span class="number">49</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">90</span>, <span class="number">47</span>];</span><br><span class="line"><span class="comment">// 求两个数组的并集</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [...new <span class="built_in">Set</span>([...arr1, ...arr2])];</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数组的交集</span></span><br><span class="line"><span class="keyword">const</span> arr4 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line"><span class="keyword">const</span> arr5 = [...new <span class="built_in">Set</span>(arr2)];</span><br><span class="line"><span class="keyword">const</span> result = arr5.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr4.has(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数组的差集</span></span><br><span class="line"><span class="keyword">const</span> result1 = arr3.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(arr4.has(item))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result1)</span><br></pre></td></tr></table></figure>


<h2 id="map集合"><a href="#map集合" class="headerlink" title="map集合"></a>map集合</h2><p>键值对（key value pair）数据集合的特点：键不可重复</p>
<p>map集合专门用于存储多个键值对数据。</p>
<p>在map出现之前，我们使用的是对象的方式来存储键值对，键是属性名，值是属性值。</p>
<h3 id="使用对象存储有以下问题："><a href="#使用对象存储有以下问题：" class="headerlink" title="使用对象存储有以下问题："></a>使用对象存储有以下问题：</h3><ol>
<li>键名只能是字符串</li>
<li>获取数据的数量不方便</li>
<li>键名容易跟原型上的名称冲突</li>
</ol>
<h3 id="1-如何创建map"><a href="#1-如何创建map" class="headerlink" title="1. 如何创建map"></a>1. 如何创建map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//创建一个空的map</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(iterable); <span class="comment">//创建一个具有初始内容的map，初始内容来自于可迭代对象每一次迭代的结果，但是，它要求每一次迭代的结果必须是一个长度为2的数组，数组第一项表示键，数组的第二项表示值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">   [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">   [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(mp)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-属性和方法"><a href="#2-属性和方法" class="headerlink" title="2. 属性和方法"></a>2. 属性和方法</h3><ul>
<li>size：只读属性，获取当前map中键的数量</li>
<li>set(键, 值)：设置一个键值对，键和值可以是任何类型<ul>
<li>如果键不存在，则添加一项</li>
<li>如果键已存在，则修改它的值</li>
<li>比较键的方式和set相同</li>
</ul>
</li>
<li>get(键): 根据一个键得到对应的值</li>
<li>has(键)：判断某个键是否存在</li>
<li>delete(键)：删除指定的键</li>
<li>clear(): 清空map</li>
</ul>
<h3 id="3-和数组互相转换"><a href="#3-和数组互相转换" class="headerlink" title="3. 和数组互相转换"></a>3. 和数组互相转换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> arr = [...mp];</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">(<span class="number">3</span>) [<span class="built_in">Array</span>(<span class="number">2</span>), <span class="built_in">Array</span>(<span class="number">2</span>), <span class="built_in">Array</span>(<span class="number">2</span>)]</span><br><span class="line"><span class="number">0</span>: (<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">1</span>: (<span class="number">2</span>) [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span>: (<span class="number">2</span>) [<span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4. 遍历"></a>4. 遍历</h3><ul>
<li>for-of，每次迭代得到的是一个长度为2的数组</li>
<li>forEach，通过回调函数遍历<ul>
<li>参数1：每一项的值</li>
<li>参数2：每一项的键</li>
<li>参数3：map本身<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line">mp.forEach(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, index, array)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的变量 字符串 函数对象</title>
    <url>/135xyq.github.io/2021/12/31/%E5%8F%98%E9%87%8F_%E5%AD%97%E7%AC%A6%E4%B8%B2%20_%E5%87%BD%E6%95%B0%20_%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="变量-字符串-函数-对象"><a href="#变量-字符串-函数-对象" class="headerlink" title="变量 字符串 函数 对象"></a>变量 字符串 函数 对象</h1><hr>
<h2 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h2><h3 id="let声明变量："><a href="#let声明变量：" class="headerlink" title="let声明变量："></a>let声明变量：</h3><p>解决全局污染问题，let声明的变量不会挂载到全局变量。<br>let声明的变量，不允许在一个作用域范围内（全局作用域，函数作用域，块级作用域）重复声明 。<br>块级作用域：{}，在块级作用域中定义的变量，在外部无法访问。<br>let变量不会变量提升，不能在定义之前使用该变量。<br>在循环中，用let声明的变量会进行特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域（每次循环使用的是一个全新的变量）。<br>用let声明的循环变量在循环结束时会自动销毁。</p>
<h2 id="const声明常量："><a href="#const声明常量：" class="headerlink" title="const声明常量："></a>const声明常量：</h2><p>const和let完全相同，仅在于const声明的变量，必须在变量声明时赋值，而且不可以重新赋值。<br>多使用const避免犯错。<br>const声明一个对象时，对象里面的属性是可以更改的，仅仅是对象的名不能重新赋值。<br>在for循环中循环变量不能使用const常量，在for in循环中可以使用。</p>
<h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><h3 id="字符串API（以下全为实例方法）："><a href="#字符串API（以下全为实例方法）：" class="headerlink" title="字符串API（以下全为实例方法）："></a>字符串API（以下全为实例方法）：</h3><ul>
<li>原字符串.includes（子字符串，开始查找的索引值（可省略，默认从0开始））：判断字符串是否包含指定的子字符串。</li>
<li>startWith（子字符串，开始查找的索引值（可省略，默认从0开始））:是否以指定字符串开头。</li>
<li>endWith（子字符串，开始查找的索引值（可省略，默认从0开始））：是否以指定字符串结尾。</li>
<li>repeat（子字符串，开始查找的索引值（可省略，默认从0开始））：将字符串重复指定的次数，重新返回一个新的字符串。</li>
</ul>
<h3 id="模板字符串："><a href="#模板字符串：" class="headerlink" title="模板字符串："></a>模板字符串：</h3><p>写在 `` 里面，<br>要拼接字符串，将要拼接的字符串加在${}里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> level1 = <span class="string">&quot;谢永强&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> level2 = <span class="string">&quot;帅&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> txt = <span class="string">`我感觉<span class="subst">$&#123;level1&#125;</span>很<span class="subst">$&#123;level2&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(txt);</span><br></pre></td></tr></table></figure>
<p>在模板字符串前面加上标记 ： String.raw ,可以将模板字符串里面的特殊字符直接输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> text1 = <span class="built_in">String</span>.raw <span class="string">`谢永强\t真帅！`</span></span><br><span class="line">        <span class="built_in">console</span>.log(text1)</span><br></pre></td></tr></table></figure>
<h4 id="在模板字符串书写之前可以之前可以加上一个标记："><a href="#在模板字符串书写之前可以之前可以加上一个标记：" class="headerlink" title="在模板字符串书写之前可以之前可以加上一个标记："></a>在模板字符串书写之前可以之前可以加上一个标记：</h4><p>&emsp;标记名``（模板字符串）：得到是标记函数的返回值<br>&emsp;标记是一个函数：<br>&emsp;该函数的第一个参数是被要插入内容（${}里面的值）分割的字符串数组<br>&emsp;后续的参数是要插入内容（${}里面的值） </p>
<h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h3 id="参数默认值："><a href="#参数默认值：" class="headerlink" title="参数默认值："></a>参数默认值：</h3><p>参数默认值，在定义函数时直接给形参赋值，如果调用函数时不传递参数，则使用默认值。<br>在严格模式下（“use strict”）下形参和arguments是脱离的（不在满足一一映射关系），只要给函数加上了参数默认值，该函数会自动变成严格模式下的规则（形参和arguments是脱离的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b = <span class="number">4</span></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a + b);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="剩余参数："><a href="#剩余参数：" class="headerlink" title="剩余参数："></a>剩余参数：</h3><p>函数名.length :可得到函数形参的个数<br>解决参数数量不确定情况下的问题。<br>实现方法：在函数是形参中加上 （…数组名）就可以了，用一个数组收集剩下的所有参数。<br>一个函数只能有一个剩余参数。<br>一个函数如果有剩余参数，剩余参数必须是最后一个参数。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">            sum = sum + a + b;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                sum += args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="展开运算符："><a href="#展开运算符：" class="headerlink" title="展开运算符："></a>展开运算符：</h3><p>作用：将数组的每一项分别提取出来。<br>语法：在要展开的数组和对象前面加上(…数组名 /  …对象名)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(...arr)</span><br><span class="line">输出结果：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;xyq&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">	...obj</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(obj1)</span><br></pre></td></tr></table></figure>

<p>new.target :可用来判断函数是否用new来调用函数。  </p>
<h3 id="箭头函数："><a href="#箭头函数：" class="headerlink" title="箭头函数："></a>箭头函数：</h3><h4 id="this指向："><a href="#this指向：" class="headerlink" title="this指向："></a>this指向：</h4><ol>
<li>通过对象调用函数，this指向对象</li>
<li>直接调用函数，this指向全局对象</li>
<li>如果通过new调用函数，this指向新创建的对象</li>
<li>如果通过apply、call、bind等调用函数，this指向指定的数据</li>
<li>如果是dom对象，this指向事件源<h4 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h4>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">完整语法：</span><br><span class="line"> (参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)=&gt;&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line">如果参数只有一个，可以省略小括号</span><br><span class="line">参数 =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">如果箭头函数只有一条返回语句，可以省略大括号，和<span class="keyword">return</span>关键字</span><br><span class="line">参数 =&gt; 返回值</span><br></pre></td></tr></table></figure>
<h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4></li>
</ol>
<ul>
<li>箭头函数中，不存在this、arguments、new.target，如果使用了，则使用的是函数外层的对应的this、arguments、new.target</li>
<li>箭头函数没有原型</li>
<li>箭头函数不能作用构造函数使用<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="临时性使用的函数，并不会可以调用它，比如："><a href="#临时性使用的函数，并不会可以调用它，比如：" class="headerlink" title="临时性使用的函数，并不会可以调用它，比如："></a>临时性使用的函数，并不会可以调用它，比如：</h5></li>
<li>事件处理函数</li>
<li>异步处理函数</li>
<li>其他临时性的函数</li>
<li>为了绑定外层this的函数</li>
<li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li>
</ul>
<h2 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h2><h3 id="变量字面量语法："><a href="#变量字面量语法：" class="headerlink" title="变量字面量语法："></a>变量字面量语法：</h3><h4 id="成员速写："><a href="#成员速写：" class="headerlink" title="成员速写："></a>成员速写：</h4><p>如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写，可将 变量名：变量名  简写成 变量名</p>
<h4 id="方法速写："><a href="#方法速写：" class="headerlink" title="方法速写："></a>方法速写：</h4><p>可以将：function省略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                name,</span><br><span class="line">                age,</span><br><span class="line">                sex,</span><br><span class="line">                <span class="function"><span class="title">fuc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算属性名："><a href="#计算属性名：" class="headerlink" title="计算属性名："></a>计算属性名：</h4><p>有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在ES6，可以使用中括号来表示该属性名是通过计算得到的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">const</span> prop1 = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> prop2 = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> prop3 = <span class="string">&#x27;sex&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">            [prop1]: <span class="string">&#x27;xyq&#x27;</span>,</span><br><span class="line">            [prop2]: <span class="number">20</span>,</span><br><span class="line">             [prop3]: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(obj1)</span><br></pre></td></tr></table></figure>
<h3 id="Object的新增API："><a href="#Object的新增API：" class="headerlink" title="Object的新增API："></a>Object的新增API：</h3><ul>
<li>Object.is:<br>判断两个对象是否相等，基本和 === 是一致的，除了 NaN和NaN相等 、 +0 和-0不相等</li>
<li>Object.assign：<br>用于混合对象（可以用展开运算符实现）；<br>缺陷：会更改原来的第一个对象，解决方案：第一个参数传递一个空对象</li>
<li>Object.getOwnPropertyNames:<br>Object.getOwnPropertyNames方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。<br>ES6规定了该方法返回的数组的排序方式如下：<br>先排数字，并按照升序排序<br>再排其他，按照书写顺序排序</li>
<li>Object.setPrototypeOf<br>该函数用于设置某个对象的隐式原型<br>比如： Object.setPrototypeOf(obj1, obj2)， 相当于： obj1.<strong>proto</strong> = obj2<h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><h3 id="传统的构造函数的问题"><a href="#传统的构造函数的问题" class="headerlink" title="传统的构造函数的问题"></a>传统的构造函数的问题</h3></li>
<li>属性和原型方法定义分离，降低了可读性</li>
<li>原型成员可以被枚举</li>
<li>默认情况下，构造函数仍然可以被当作普通函数使用<h3 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h3></li>
<li>类声明不会被提升，与 let 和 const 一样，存在暂时性死区</li>
<li>类中的所有代码均在严格模式下执行</li>
<li>类的所有方法都是不可枚举的</li>
<li>类的所有方法都无法被当作构造函数使用</li>
<li>类的构造器必须使用 new 来调用<h3 id="类的语法："><a href="#类的语法：" class="headerlink" title="类的语法："></a>类的语法：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"><span class="title">constructor</span>（参数）&#123;</span><br><span class="line">属性值</span><br><span class="line">&#125;</span><br><span class="line">方法名（）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 构造函数，写属性</span></span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">type, name, age, sex</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.type = type;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">                <span class="built_in">this</span>.sex = sex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 方法</span></span><br><span class="line">            <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`【种类】：<span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>`</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`【名字】：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`【年龄】：<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`【性别】：<span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="类里面属性的获取和更改："><a href="#类里面属性的获取和更改：" class="headerlink" title="类里面属性的获取和更改："></a>类里面属性的获取和更改：</h3><p>可达到像普通对象一样直接获取，设置属性又不保证安全。 </p>
<h4 id="获取："><a href="#获取：" class="headerlink" title="获取："></a>获取：</h4><p>可定义一个方法  get 属性名（）{<br>}</p>
<h4 id="更改："><a href="#更改：" class="headerlink" title="更改："></a>更改：</h4><p>定义一个方法  set 属性名（参数）{<br>}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    val = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>._age = val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>._age)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态成员："><a href="#静态成员：" class="headerlink" title="静态成员："></a>静态成员：</h3><p>直接定义在类上的属性或方法，在类中用关键字static定义，不用创建实例对象就可以访问的属性，创建的实例对象不可以访问这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">            <span class="keyword">static</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="function"><span class="title">b</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    val = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>._age = val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">字段初始化器：</span><br><span class="line">可以将一些有固定值的属性直接写在构造函数外面。</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">            sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">            <span class="keyword">static</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="function"><span class="title">b</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    val = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>._age = val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><h6 id="如果两个类A和B，如果可以描述为：B-是-A，则，A和B形成继承关系则："><a href="#如果两个类A和B，如果可以描述为：B-是-A，则，A和B形成继承关系则：" class="headerlink" title="如果两个类A和B，如果可以描述为：B 是 A，则，A和B形成继承关系则："></a>如果两个类A和B，如果可以描述为：B 是 A，则，A和B形成继承关系则：</h6><ul>
<li>B继承自A</li>
<li>A派生B</li>
<li>B是A的子类</li>
<li>A是B的父类<br>如果A是B的父类，则B会自动拥有A中的所有实例成员。<h4 id="继承的关键字："><a href="#继承的关键字：" class="headerlink" title="继承的关键字："></a>继承的关键字：</h4>extends：继承，用于类的定义<br>super</li>
</ul>
<ul>
<li>直接当作函数调用，表示父类构造函数</li>
<li>如果当作对象使用，则表示父类的原型<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4></li>
<li>ES6要求，如果定义了constructor，并且该类是子类，则必须在constructor的第一行手动调用父类的构造函数</li>
<li>如果子类不写constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器<h4 id="【冷知识】"><a href="#【冷知识】" class="headerlink" title="【冷知识】"></a>【冷知识】</h4><h5 id="用JS制作抽象类"><a href="#用JS制作抽象类" class="headerlink" title="用JS制作抽象类"></a>用JS制作抽象类</h5>抽象类：一般是父类，不能通过该类创建对象<br>正常情况下，this的指向，this始终指向具体的类的对象</li>
</ul>
<p>getComputerStyle ： 可以获取dom元素的所有css样式<br>window.location.reload();可刷新页面</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3动画</title>
    <url>/135xyq.github.io/2021/12/31/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a><a href="http://css.doyoe.com/">动画</a></h1><hr>
<h2 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition: 过渡"></a>transition: 过渡</h2><p>（过渡对象，持续时间，变化函数（可选），延迟时间（可选））</p>
<h4 id="变化函数："><a href="#变化函数：" class="headerlink" title="变化函数："></a>变化函数：</h4><p>贝塞尔曲线cubic-bezier(<number>, <number>, <number>, <number>)：特定的贝塞尔曲线类型，1,3数值需在[0, 1]区间内</p>
<p><img src="beisaier.png" alt="贝塞尔曲线"><br>输入的四个数为P1,P2的坐标点</p>
<h2 id="animations：动画"><a href="#animations：动画" class="headerlink" title="animations：动画"></a>animations：动画</h2><h3 id="八个属性值："><a href="#八个属性值：" class="headerlink" title="八个属性值："></a>八个属性值：</h3><ul>
<li>&lt;’ animation-name ‘&gt;：<br>检索或设置对象所应用的动画名称</li>
<li>&lt;’ animation-duration ‘&gt;：<br>检索或设置对象动画的持续时间</li>
<li>&lt;’ animation-timing-function ‘&gt;：<br>检索或设置对象动画的过渡类型</li>
<li>&lt;’ animation-delay ‘&gt;：<br>检索或设置对象动画延迟的时间</li>
<li>&lt;’ animation-iteration-count ‘&gt;：<br>检索或设置对象动画的循环次数</li>
<li>&lt;’ animation-direction ‘&gt;：<br>检索或设置对象动画在循环中是否反向运动</li>
<li>&lt;’ animation-fill-mode ‘&gt;：<br>检索或设置对象动画时间之外的状态</li>
<li>&lt;’ animation-play-state ‘&gt;：<br>检索或设置对象动画的状态。</li>
</ul>
<h3 id="关键帧定义："><a href="#关键帧定义：" class="headerlink" title="关键帧定义："></a>关键帧定义：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes 自定义名字&#123;</span><br><span class="line">数字%（执行时间占比其中0%可变为from ，100%可变为to)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>steps（步数，start/ end）</li>
<li>start:保留下一帧状态，直到这一段动画时间结束</li>
<li>end:保留当前帧状态，直到这一段动画时间结束，最后一帧可能看不到，可加上forwords来弥补</li>
</ul>
<p><code>steps(1,start) === step-start</code><br><code>steps(1,end) === step-end </code></p>
<h3 id="scale-伸缩"><a href="#scale-伸缩" class="headerlink" title="scale:伸缩"></a>scale:伸缩</h3><p>可3d变化</p>
<p>伸缩的是此元素变化的坐标轴的刻度。可叠加操作<br>scale的坐标轴会随着旋转轴的旋转而旋转，但会保留影响，设置过的会保留效果。</p>
<h3 id="skew-倾斜"><a href="#skew-倾斜" class="headerlink" title="skew:倾斜"></a>skew:倾斜</h3><p>2d变化<br>倾斜的是此元素变化的坐标轴，还会拉伸坐标轴</p>
<p>可水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure>


<p>perspective：景深，我们视线距离浏览器的距离，只设置这一个并不会影响大小</p>
<p>transform-origin：旋转中心，可填三个值x , y, z</p>
<p>matrix:矩阵，transform的强大属性，可以完成各种变换</p>
<p><img src="/images/CSS3Images/%E5%8A%A8%E7%94%BB-%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5.jpg" alt="转换矩阵"></p>
<p>浏览器渲染过程</p>
<p>reflow:<br>改变窗口大小<br>改变文字大小<br>内容的改变，输入框输入文字<br>激活伪类，如:hover<br>操作class属性<br>脚本操作DOM<br>计算offsetWidth和offsetHeight<br>设置style属性<br>repaint：<br>repaint：如果只是改变某个元素的背景色、<br>文 字颜色、边框颜色，不影响它周围或内部布局的属性<br>repaint<br>repaint 速度快于 reflow  </p>
<p>像素里面有三个色点，三个在一个平面排列，里面每个像点代表三原色的每一个颜色，空间混色法</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的动态路由</title>
    <url>/135xyq.github.io/2022/01/01/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1&amp;watch/</url>
    <content><![CDATA[<h1 id="文章列表页逻辑"><a href="#文章列表页逻辑" class="headerlink" title="文章列表页逻辑"></a>文章列表页逻辑</h1><h2 id="路由跳转逻辑"><a href="#路由跳转逻辑" class="headerlink" title="路由跳转逻辑"></a>路由跳转逻辑</h2><p><img src="http://mdrs.yuanjin.tech/img/20210107140253.png" alt="image-20210107140253824"></p>
<h2 id="组件逻辑"><a href="#组件逻辑" class="headerlink" title="组件逻辑"></a>组件逻辑</h2><p><img src="http://mdrs.yuanjin.tech/img/20210107142310.png" alt="image-20210107142310757"></p>
<h3 id="BlogList"><a href="#BlogList" class="headerlink" title="BlogList"></a>BlogList</h3><p><img src="http://mdrs.yuanjin.tech/img/20210107153623.png" alt="image-20210107153623557"></p>
<h3 id="BlogCategory"><a href="#BlogCategory" class="headerlink" title="BlogCategory"></a>BlogCategory</h3><p><img src="http://mdrs.yuanjin.tech/img/20210107154531.png" alt="image-20210107154531659"></p>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>我们希望下面的地址都能够匹配到<code>Blog</code>组件</p>
<ul>
<li><code>/article</code>，显示全部文章</li>
<li><code>/article/cate/1</code>，显示分类<code>id</code>为<code>1</code>的文章</li>
<li><code>/article/cate/3</code>，显示分类<code>id</code>为<code>3</code>的文章</li>
<li>…</li>
</ul>
<p>第一种情况很简单，只需要将一个固定的地址匹配到<code>Blog</code>组件即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/article&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Blog&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Blog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但后面的情况则不同：匹配到<code>Blog</code>组件的地址中，有一部分是动态变化的，则需要使用一种特殊的表达方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/article/cate/:categoryId&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;CategoryBlog&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Blog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在地址中使用<code>:xxx</code>，来表达这一部分的内容是变化的，在<code>vue-router</code>中，将变化的这一部分称之为<code>params</code>，可以在<code>vue</code>组件中通过<code>this.$route.params</code>来获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问 /article/cate/3</span></span><br><span class="line"><span class="built_in">this</span>.$route.params <span class="comment">// &#123; categoryId: &quot;3&quot; &#125;</span></span><br><span class="line"><span class="comment">// 访问 /article/cate/1</span></span><br><span class="line"><span class="built_in">this</span>.$route.params <span class="comment">// &#123; categoryId: &quot;1&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态路由的导航"><a href="#动态路由的导航" class="headerlink" title="动态路由的导航"></a>动态路由的导航</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/article/cate/3&quot;&gt;to article of category 3&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">   name: &#x27;CategoryBlog&#x27;,</span><br><span class="line">   params: &#123;</span><br><span class="line">       categoryId: 3           </span><br><span class="line">   &#125;                    </span><br><span class="line">&#125;&quot;&gt;to article of category 3&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>除了使用<code>&lt;RouterLink&gt;</code>超链接导航外，<code>vue-router</code>还允许在代码中跳转页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&quot;跳转地址&quot;</span>); <span class="comment">// 普通跳转</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="comment">// 命名路由跳转</span></span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;Blog&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$router.go(-<span class="number">1</span>); <span class="comment">// 回退。类似于 history.go</span></span><br></pre></td></tr></table></figure>

<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>利用<code>watch</code>配置，可以直接观察某个数据的变化，变化时可以做一些处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 观察 this.$route 的变化，变化后，会调用该函数</span></span><br><span class="line">    $route(newVal, oldVal)&#123;</span><br><span class="line">      <span class="comment">// newVal：this.$route 新的值，等同 this.$route</span></span><br><span class="line">      <span class="comment">// oldVal：this.$route 旧的值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 完整写法</span></span><br><span class="line">    <span class="attr">$route</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newVal, oldVal</span>)</span>&#123;&#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span>, <span class="comment">// 是否监听该数据内部属性的变化，默认 false</span></span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span> <span class="comment">// 是否立即执行一次 handler，默认 false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 观察 this.$route.params 的变化，变化后，会调用该函数</span></span><br><span class="line">    [<span class="string">&quot;$route.params&quot;</span>](newVal, oldVal)&#123;</span><br><span class="line">      <span class="comment">// newVal：this.$route.params 新的值，等同 this.$route.params</span></span><br><span class="line">      <span class="comment">// oldVal：this.$route.params 旧的值</span></span><br><span class="line">    &#125;,</span><br><span class="line">  	<span class="comment">// 完整写法</span></span><br><span class="line">    [<span class="string">&quot;$route.params&quot;</span>]: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newVal, oldVal</span>)</span>&#123;&#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span>, <span class="comment">// 是否监听该数据内部属性的变化，默认 false</span></span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span> <span class="comment">// 是否立即执行一次 handler，默认 false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap响应网页和栅格系统</title>
    <url>/135xyq.github.io/2021/12/31/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E5%92%8C%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="bootstrap响应网页和栅格系统"><a href="#bootstrap响应网页和栅格系统" class="headerlink" title="bootstrap响应网页和栅格系统"></a>bootstrap响应网页和栅格系统</h1><h2 id="响应式网页具有的特点："><a href="#响应式网页具有的特点：" class="headerlink" title="响应式网页具有的特点："></a>响应式网页具有的特点：</h2><ol>
<li>网页宽度自动调整</li>
<li>少用绝对宽度</li>
<li>字体要使用rem（根节点的相对大小）、em作为单位</li>
<li>布局要使用浮动或弹性</li>
</ol>
<h2 id="媒体查询："><a href="#媒体查询：" class="headerlink" title="媒体查询："></a>媒体查询：</h2><p>@media 媒体类型 逻辑运算符（媒体特性）{<br>正常的CSS样式<br>}</p>
<h2 id="媒体类型："><a href="#媒体类型：" class="headerlink" title="媒体类型："></a>媒体类型：</h2><ul>
<li>all:所有设备</li>
<li>print：打印机设备</li>
<li>screen：彩色的电脑屏幕</li>
<li>speech：听觉设备</li>
</ul>
<h2 id="媒体特性："><a href="#媒体特性：" class="headerlink" title="媒体特性："></a>媒体特性：</h2><ul>
<li>min-width 最小宽度</li>
<li>width 宽度</li>
<li>max-width  最大宽度</li>
<li>height 高度</li>
<li>min-width 最小高度</li>
<li>max-width  最大高度</li>
<li>orientation  方向</li>
<li>landscape 横屏（宽度大于高度）</li>
<li>portrait  竖屏（高度大于宽度）</li>
<li>aspect-ratio  宽度比</li>
<li>-webkit-device-pixel-ratio 像素比（webkit内核专属）</li>
</ul>
<h2 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h2><ul>
<li>and  合并多个媒体查询（并且）</li>
<li>，   匹配某个媒体查询（或者）</li>
<li>not  对媒体查询结构取反</li>
<li>only  仅在媒体查询匹配成功后应用样式（防范老旧浏览器）</li>
</ul>
<p>CSS @规则：<br>@chartest  定义编码<br>@import   引入css文件<br>@font-face  自定义字体<br>@keyframes  animation里面的关键帧<br>@media    媒体查询</p>
<h2 id="栅格系统："><a href="#栅格系统：" class="headerlink" title="栅格系统："></a>栅格系统：</h2><p>X3.0使用的是浮动原理，X4.0使用的是弹性盒。</p>
<p>结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col- &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="设置最外层容器为container时（表示宽度会有所限制）："><a href="#设置最外层容器为container时（表示宽度会有所限制）：" class="headerlink" title="设置最外层容器为container时（表示宽度会有所限制）："></a>设置最外层容器为container时（表示宽度会有所限制）：</h3><ul>
<li>xl为超大屏。屏幕宽度&gt;=1200，容器的宽度固定为1140px，一行可以设置12个列。屏幕尺寸&lt;1200的时候，一行只能设置1列</li>
<li>lg为大屏。屏幕宽度&gt;=992px，容器的宽度固定为960px，一行可以设置12个列。屏幕尺寸&lt;992的时候，一行只能设置1列<br>md为中等屏。屏幕宽度&gt;=768px，容器的宽度固定为720px，一行可以设置12个列。屏幕尺寸&lt;768的时候，一行只能设置1列</li>
<li>sm为小屏。屏幕宽度&gt;=576px，容器的宽度固定为540px，一行可以设置12个列。屏幕尺寸&lt;576的时候，一行只能设置1列</li>
<li>col为超小屏。屏幕宽度&lt;576px，容器的宽度为auto，一行永远可以设置12列</li>
</ul>
<p>设置最外层容器为container-fluid时（表示宽度为100%）</p>
<p>等宽列：<br>设置col类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想换行，在从何处换行的元素后面加上一个元素设置class为w-100</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;w-100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的注入</title>
    <url>/135xyq.github.io/2022/01/01/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p><img src="/images/vue2/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%B3%A8%E5%85%A5.jpg" alt="image-20201110163548294"></p>
<p>vue会将以下配置注入到vue实例：</p>
<ul>
<li>data：和界面相关的数据</li>
<li>computed：通过已有数据计算得来的数据，</li>
<li>methods：方法</li>
</ul>
<blockquote>
<p>模板中可以使用vue实例中的成员</p>
</blockquote>
<p> // 对象或数组默认值必须从一个工厂函数获取</p>
<h2 id="虚拟DOM树"><a href="#虚拟DOM树" class="headerlink" title="虚拟DOM树"></a>虚拟DOM树</h2><p>直接操作真实的DOM会引发严重的效率问题，vue使用虚拟DOM（vnode）的方式来描述要渲染的内容</p>
<p>vnode是一个<strong>普通的</strong>JS对象，用于描述界面上应该有什么，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vnode = &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="literal">undefined</span>, <span class="attr">text</span>: <span class="string">&quot;第一个vue应用：Hello World&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的对象描述了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个标签名为h1的节点，它有一个子节点，该子节点是一个文本，内容为「第一个vue应用：Hello World」</span><br></pre></td></tr></table></figure>

<p><strong>vue模板并不是真实的DOM，它会被编译为虚拟DOM</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一个vue应用：&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>作者：&#123;&#123;author&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的模板会被编译为类似下面结构的虚拟DOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="string">&quot;h1&quot;</span>, <span class="attr">children</span>: [ &#123; <span class="attr">text</span>: <span class="string">&quot;第一个vue应用：Hello World&quot;</span> &#125; ] &#125;,</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="string">&quot;p&quot;</span>, <span class="attr">children</span>: [ &#123; <span class="attr">text</span>: <span class="string">&quot;作者：袁&quot;</span> &#125; ] &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟DOM树会最终生成为真实的DOM树</p>
<p>当数据变化后，将引发重新渲染，vue会比较新旧两棵vnode tree，找出差异，然后仅把差异部分应用到真实dom tree中</p>
<p><img src="/images/vue2/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%94%9F%E6%88%90dom%E6%A0%91.jpg" alt="image-20201106145409844"></p>
<p><strong>可见，在vue中，要得到最终的界面，必须要生成一个vnode tree</strong></p>
<p>vue通过以下逻辑生成vnode tree：</p>
<p><strong>注意：虚拟节点树必须是单根的</strong></p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>将生成的真实DOM树，放置到某个元素位置，称之为<strong>挂载</strong></p>
<p>挂载的方式：</p>
<ol>
<li>通过<code>el:&quot;css选择器&quot;</code>进行配置</li>
<li>通过<code>vue实例.$mount(&quot;css选择器&quot;)</code>进行配置</li>
</ol>
<h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p><img src="/images/vue2/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AE%8C%E6%95%B4%E9%80%BB%E8%BE%91.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的ref</title>
    <url>/135xyq.github.io/2022/01/01/%E5%BC%B9%E5%87%BA%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h1 id="使用css-module"><a href="#使用css-module" class="headerlink" title="使用css module"></a>使用css module</h1><p>需要将样式文件命名为<code>xxx.module.ooo</code></p>
<p><code>xxx</code>为文件名</p>
<p><code>ooo</code>为样式文件后缀名，可以是<code>css</code>、<code>less</code></p>
<h1 id="得到组件渲染的Dom"><a href="#得到组件渲染的Dom" class="headerlink" title="得到组件渲染的Dom"></a>得到组件渲染的Dom</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    获取某个组件渲染的Dom根元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentRootDom</span>(<span class="params">comp, props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(comp, &#123;props&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  vm.$mount();</span><br><span class="line">  <span class="keyword">return</span> vm.$el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="扩展vue实例"><a href="#扩展vue实例" class="headerlink" title="扩展vue实例"></a>扩展vue实例</h1><img src="http://mdrs.yuanjin.tech/img/20201203172154.jpg" alt="扩展vue实例" style="zoom:33%;" />

<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;para&quot;</span>&gt;</span>some paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">ref</span>=<span class="string">&quot;comp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>查看所有引用<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> ChildComp <span class="keyword">from</span> <span class="string">&quot;./ChildComp&quot;</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="javascript">      ChildComp</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取持有的所有引用</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs);</span></span><br><span class="line"><span class="javascript">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        	para: p元素（原生DOM）,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        	comp: ChildComp的组件实例</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        */</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>通过<code>ref</code>可以直接操作<code>dom</code>元素，甚至可能直接改动子组件，这些都不符合<code>vue</code>的设计理念。</p>
<p>除非迫不得已，否则不要使用<code>ref</code></p>
</blockquote>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的插槽</title>
    <url>/135xyq.github.io/2022/01/01/%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<p>在某些组件的模板中，有一部分区域需要父组件来指定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- message组件：一个弹窗消息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是消息内容，可以是一个文本，也可能是一段html，具体是什么不知道，需要父组件指定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="插槽的简单用法"><a href="#插槽的简单用法" class="headerlink" title="插槽的简单用法"></a>插槽的简单用法</h1><p>此时，就需要使用插槽来定制组件的功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- message组件：一个弹窗消息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- slot是vue的内置组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件App --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>App Message<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Message</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最终的结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-co r&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> </span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">div</span> <span class="attr">class</span>=<span class="string">&quot;app-message &gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &lt;p&gt;App Message&lt;/p&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">      &lt;a href=&quot;</span>&quot;&gt;</span>detai </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/vue2/%E6%8F%92%E6%A7%BD-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.jpg" alt="插槽"></p>
<h1 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h1><p>如果某个组件中需要父元素传递多个区域的内容，也就意味着需要提供多个插槽</p>
<p>为了避免冲突，就需要给不同的插槽赋予不同的名字</p>
<p>父组件中要使用 v-slot 指令，简写为 #</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Layout 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里，提供插槽，名为header --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里，提供插槽，名为default --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里，提供插槽，名为footer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件App --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/vue2/%E6%8F%92%E6%A7%BD-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.jpg" alt="具名插槽"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2搭建工程</title>
    <url>/135xyq.github.io/2022/01/01/%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>vue-cli: <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><p><code>vue-cli</code>是一个脚手架工具，用于搭建<code>vue</code>工程</p>
<p>它内部使用了<code>webpack</code>，并预置了诸多插件（<code>plugin</code>）和加载器（<code>loader</code>），以达到开箱即用的效果</p>
<p>除了基本的插件和加载器外，<code>vue-cli</code>还预置了：</p>
<ul>
<li>babel</li>
<li>webpack-dev-server</li>
<li>eslint</li>
<li>postcss</li>
<li>less-loader</li>
</ul>
<h1 id="SFC"><a href="#SFC" class="headerlink" title="SFC"></a>SFC</h1><p>单文件组件，Single File Component，即一个文件就包含了一个组件所需的全部代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 组件模板代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 组件配置</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	<span class="comment">/* 组件样式 */</span></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><p>当<code>vue-cli</code>进行<strong>打包</strong>时，会直接把组件中的模板转换为<code>render</code>函数，这叫做模板预编译</p>
<p>这样做的好处在于：</p>
<ol>
<li>运行时就不再需要编译模板了，提高了运行效率</li>
<li>打包结果中不再需要vue的编译代码，减少了打包体积</li>
</ol>
<img src="http://mdrs.yuanjin.tech/img/20201111155613.png" alt="image-20201111155613940" style="zoom:50%;" />

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>分析打包的结果</title>
    <url>/135xyq.github.io/2022/01/01/%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="分析打包结果"><a href="#分析打包结果" class="headerlink" title="分析打包结果"></a>分析打包结果</h1><p>由于<code>vue-cli</code>是利用<code>webpack</code>进行打包，我们仅需加入一个<code>webpack</code>插件<code>webpack-bundle-analyzer</code>即可分析打包结果</p>
<p>为了避免在开发环境中启动<code>webpack-bundle-analyzer</code>，我们仅需使用以下代码即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>)</span><br><span class="line">    .BundleAnalyzerPlugin;</span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 通过 configureWebpack 选项，可对 webpack 进行额外的配置</span></span><br><span class="line">  <span class="comment">// 该配置最终会和 vue-cli 的默认配置进行合并（webpack-merge）</span></span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="keyword">new</span> BundleAnalyzerPlugin()]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="优化公共库打包体积"><a href="#优化公共库打包体积" class="headerlink" title="优化公共库打包体积"></a>优化公共库打包体积</h1><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><p>CDN全称为Content Delivery Network，称之为内容分发网络</p>
<p>它的基本原理是：架设多台服务器，这些服务器定期从源站拿取资源保存本地，到让不同地域的用户能够通过访问最近的服务器获得资源</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210203133956.png" alt="img"></p>
<p>我们可以把项目中的所有静态资源都放到CDN上（收费），也可以利用现成免费的CDN获取公共库的资源</p>
<img src="http://mdrs.yuanjin.tech/img/20210203140030.png" alt="image-20210203140029967" style="zoom:50%;" />

<p>首先，我们需要告诉<code>webpack</code>不要对公共库进行打包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="attr">vue</span>: <span class="string">&quot;Vue&quot;</span>,</span><br><span class="line">      <span class="attr">vuex</span>: <span class="string">&quot;Vuex&quot;</span>,</span><br><span class="line">      <span class="string">&quot;vue-router&quot;</span>: <span class="string">&quot;VueRouter&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，在页面中手动加入<code>cdn</code>链接，这里使用<a href="https://www.bootcdn.cn/">bootcn</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vuex/3.5.1/vuex.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.4.7/vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于<code>vuex</code>和<code>vue-router</code>，使用这种传统的方式引入的话会自动成为<code>Vue</code>的插件，因此需要去掉<code>Vue.use(xxx)</code></p>
<p>我们可以使用下面的代码来进行兼容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.Vuex)&#123;</span><br><span class="line">  <span class="comment">// 没有使用传统的方式引入Vuex</span></span><br><span class="line">  Vue.use(Vuex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.VueRouter)&#123;</span><br><span class="line">  <span class="comment">// 没有使用传统的方式引入VueRouter</span></span><br><span class="line">  Vue.use(VueRouter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="启用现代模式"><a href="#启用现代模式" class="headerlink" title="启用现代模式"></a>启用现代模式</h2><p>为了兼容各种浏览器，<code>vue-cli</code>在内部使用了<code>@babel/present-env</code>对代码进行降级，你可以通过<code>.browserlistrc</code>配置来设置需要兼容的目标浏览器</p>
<p>这是一种比较<em>偷懒</em>的办法，因为对于那些使用现代浏览器的用户，它们也<em>被迫</em>使用了降级之后的代码，而降低的代码中包含了大量的<code>polyfill</code>，从而提升了包的体积</p>
<p>因此，我们希望提供两种打包结果：</p>
<ol>
<li>降级后的包（大），提供给旧浏览器用户使用</li>
<li>未降级的包（小），提供给现代浏览器用户使用</li>
</ol>
<p>除了应用<code>webpack</code>进行多次打包外，还可以利用<code>vue-cli</code>给我们提供的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue-cli-service build --modern</span><br></pre></td></tr></table></figure>



<h1 id="优化项目包体积"><a href="#优化项目包体积" class="headerlink" title="优化项目包体积"></a>优化项目包体积</h1><p>这里的项目包是指<code>src</code>目录中的打包结果</p>
<h2 id="页面分包"><a href="#页面分包" class="headerlink" title="页面分包"></a>页面分包</h2><p>默认情况下，<code>vue-cli</code>会利用<code>webpack</code>将<code>src</code>目录中的所有代码打包成一个<code>bundle</code></p>
<p>这样就导致访问一个页面时，需要加载所有页面的<code>js</code>代码</p>
<p>我们可以利用<code>webpack</code>对<code>动态import</code>的支持，从而达到把不同页面的代码打包到不同文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="string">&quot;@/views/Home&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;About&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span><span class="string">&quot;@/views/About&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="优化首屏响应"><a href="#优化首屏响应" class="headerlink" title="优化首屏响应"></a>优化首屏响应</h1><blockquote>
<p>首页白屏受很多因素的影响</p>
</blockquote>
<p><code>vue</code>页面需要通过<code>js</code>构建，因此在<code>js</code>下载到本地之前，页面上什么也没有</p>
<p>一个非常简单有效的办法，即在页面中先渲染一个小的加载中效果，等到<code>js</code>下载到本地并运行后，即会自动替换</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的数据共享</title>
    <url>/135xyq.github.io/2022/01/01/%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%ABvuex/</url>
    <content><![CDATA[<p><img src="http://mdrs.yuanjin.tech/img/20210126132906.png" alt="image-20210126132906004"></p>
<p>在<code>vue</code>中遇到<strong>共享数据</strong>，会带来下面的多个问题：</p>
<ul>
<li>如何保证数据的唯一性？<ul>
<li>如果数据不唯一，则会浪费大量的内存资源，降低运行效率</li>
<li>如果数据不唯一，就可能出现不统一的数据，难以维护</li>
</ul>
</li>
<li>某个组件改动数据后，如何让其他用到该数据的组件知道数据变化了？<ul>
<li>事件总线貌似可以解决该问题，但需要在组件中手动的维护监听，极其不方便，而且事件总线的目的在于「通知」，而不是「共享数据」</li>
</ul>
</li>
</ul>
<p>一种比较容易想到的方案，就是把所有的共享数据<strong>全部</strong>提升到根组件，然后通过属性不断下发，当某个组件需要修改数据时，又不断向上抛出事件，直到根组件完成对数据的修改。</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210126133905.png" alt="image-20210126133905451"></p>
<p>这种方案的缺陷也非常明显：</p>
<ul>
<li>需要编写大量的代码层层下发数据，很多组件被迫拥有了自己根本不需要的数据</li>
<li>需要编写大量的代码层层上抛事件，很多组件被迫注册了自己根本处理不了的事件</li>
</ul>
<p>基于上面的问题，我们可以简单的设置一个<strong>独立的数据仓库</strong>。</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210126140353.png" alt="image-20210126140353891"></p>
<ul>
<li><p>组件需要什么共享数据，可以自由的从仓库中获取，需要什么拿什么。</p>
</li>
<li><p>组件可以自由的改变仓库中的数据，仓库的数据变化后，会自动通知用到对应数据的组件更新</p>
</li>
</ul>
<p>要实现这一切，可以选择<code>vuex</code></p>
<h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>安装<code>vuex</code>后，可以通过下面的代码创建一个数据仓库，在大部分情况下，一个工程仅需创建一个数据仓库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">Vue.use(Vuex); <span class="comment">// 应用vuex插件</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 仓库的配置</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="comment">// 仓库的初始状态（数据）</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>仓库创建好后，你可以使用<code>store.state</code>来访问仓库中的数据</p>
<p>如果希望在<code>vue</code>中方便的使用仓库数据，需要将<code>vuex</code>作为插件安装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">Vue.use(Vuex); <span class="comment">// 安装Vuex插件</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  <span class="comment">// 仓库的配置</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="comment">// 仓库的初始状态（数据）</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store.js&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store, <span class="comment">// 向vue中注入仓库</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>之后，在<code>vue</code>组件中，可以通过实例的<code>$store</code>属性访问到仓库</p>
<p><code>Vuex</code>会自动将配置的状态数据设置为响应式数据，当数据变化时，依赖该数据的组件会自动渲染。</p>
<h1 id="数据的变更"><a href="#数据的变更" class="headerlink" title="数据的变更"></a>数据的变更</h1><p>尽管可以利用数据响应式的特点直接变更数据，但这样的做法在大型项目中会遇到问题</p>
<blockquote>
<p>如果有一天，你发现某个共享数据是错误的，而有一百多个组件都有可能变更过这块数据，你该如何知道是哪一步数据变更出现了问题？</p>
</blockquote>
<p>为了能够更好的跟踪数据的变化，<code>vuex</code>强烈建议使用<code>mutation</code>来更改数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  <span class="comment">// 仓库的配置</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="comment">// 仓库的初始状态（数据）</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个mutation是一个方法，它描述了数据在某种场景下的变化</span></span><br><span class="line"><span class="comment">     * increase mutation描述了数据在增加时应该发生的变化</span></span><br><span class="line"><span class="comment">     * 参数state为当前的仓库数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrease</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求n次幂</span></span><br><span class="line"><span class="comment">     * 该mutation需要一个额外的参数来提供指数</span></span><br><span class="line"><span class="comment">     * 我们把让数据产生变化时的附加信息称之为负荷（负载） payload</span></span><br><span class="line"><span class="comment">     * payload可以是任何类型，数字、字符串、对象均可</span></span><br><span class="line"><span class="comment">     * 在该mutation中，我们约定payload为一个数字，表示指数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">power</span>(<span class="params">state, payload</span>)</span>&#123;</span><br><span class="line">      state.count **= payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们有了<code>mutation</code>后，就不应该直接去改动仓库的数据了</p>
<p>而是通过<code>store.commit</code>方法提交一个<code>mutation</code>，具体做法是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;mutation的名字&quot;</span>, payload);</span><br></pre></td></tr></table></figure>

<p>现在，我们可以通过<code>vue devtools</code>观测到数据的变化了</p>
<p>**特别注意： **</p>
<ol>
<li><p><code>mutation</code>中不得出现异步操作</p>
<blockquote>
<p>在实际开发的规范中，甚至要求不得有副作用操作</p>
<p>副作用操作包括：</p>
<ul>
<li>异步</li>
<li>更改或读取外部环境的信息，例如<code>localStorage、location、DOM</code>等</li>
</ul>
</blockquote>
</li>
<li><p>提交<code>mutation</code>是数据改变的<strong>唯一原因</strong></p>
</li>
</ol>
<img src="http://mdrs.yuanjin.tech/img/20210129151639.png" alt="image-20210129151639301" style="zoom: 50%;" />

<h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>如果在<code>vuex</code>中要进行异步操作，需要使用<code>action</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; </span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrease</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">power</span>(<span class="params">state, payload</span>)</span>&#123;</span><br><span class="line">      state.count **= payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ctx: 类似于store的对象</span></span><br><span class="line"><span class="comment">     * payload: 本次异步操作的额外信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">asyncPower</span>(<span class="params">ctx, payload</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ctx.commit(<span class="string">&quot;power&quot;</span>, payload)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="http://mdrs.yuanjin.tech/img/20210129160320.png" alt="image-20210129160320025" style="zoom:50%;" />]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中响应式原理</title>
    <url>/135xyq.github.io/2022/01/01/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<blockquote>
<p>面试题：请阐述<code>vue2</code>响应式原理</p>
</blockquote>
<blockquote>
<p>vue官方阐述：<a href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>
</blockquote>
<p><strong>响应式数据的最终目标</strong>，是当对象本身或对象属性发生变化时，将会运行一些函数，最常见的就是render函数。</p>
<p>在具体实现上，vue用到了<strong>几个核心部件</strong>：</p>
<ol>
<li>Observer</li>
<li>Dep</li>
<li>Watcher</li>
<li>Scheduler</li>
</ol>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h1><p>Observer要实现的目标非常简单，就是把一个普通的对象转换为响应式的对象</p>
<p>为了实现这一点，Observer把对象的每个属性通过<code>Object.defineProperty</code>转换为带有<code>getter</code>和<code>setter</code>的属性，这样一来，当访问或设置属性时，<code>vue</code>就有机会做一些别的事情。</p>
<p><img src="/images/vue2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-%E5%8E%9F%E7%90%86.jpg" alt="数据响应"></p>
<p>Observer是vue内部的构造器，我们可以通过Vue提供的静态方法<code>Vue.observable( object )</code>间接的使用该功能。</p>
<p>在组件生命周期中，这件事发生在<code>beforeCreate</code>之后，<code>created</code>之前。</p>
<p>具体实现上，它会递归遍历对象的所有属性，以完成深度的属性转换。</p>
<p>由于遍历时只能遍历到对象的当前属性，因此无法监测到将来动态增加或删除的属性，因此<code>vue</code>提供了<code>$set</code>和<code>$delete</code>两个实例方法，让开发者通过这两个实例方法对已有响应式对象添加或删除属性。</p>
<p>对于数组，<code>vue</code>会更改它的隐式原型，之所以这样做，是因为vue需要监听那些可能改变数组内容的方法</p>
<img src="http://mdrs.yuanjin.tech/img/20210226154624.png" alt="image-20210226154624015" style="zoom:50%;" />

<p>总之，Observer的目标，就是要让一个对象，它属性的读取、赋值，内部数组的变化都要能够被vue感知到。</p>
<h1 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h1><p>这里有两个问题没解决，就是读取属性时要做什么事，而属性变化时要做什么事，这个问题需要依靠Dep来解决。</p>
<p>Dep的含义是<code>Dependency</code>，表示依赖的意思。</p>
<p><code>Vue</code>会为响应式对象中的每个属性、对象本身、数组本身创建一个<code>Dep</code>实例，每个<code>Dep</code>实例都有能力做以下两件事：</p>
<ul>
<li>记录依赖：是谁在用我</li>
<li>派发更新：我变了，我要通知那些用到我的人</li>
</ul>
<p>当读取响应式对象的某个属性时，它会进行依赖收集：有人用到了我</p>
<p>当改变某个属性时，它会派发更新：那些用我的人听好了，我变了</p>
<img src="http://mdrs.yuanjin.tech/img/20210226155852.png" alt="image-20210226155852964" style="zoom:50%;" />

<h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>这里又出现一个问题，就是Dep如何知道是谁在用我？</p>
<p>要解决这个问题，需要依靠另一个东西，就是Watcher。</p>
<p>当某个函数执行的过程中，用到了响应式数据，响应式数据是无法知道是哪个函数在用自己的</p>
<p>因此，vue通过一种巧妙的办法来解决这个问题</p>
<p>我们不要直接执行函数，而是把函数交给一个叫做watcher的东西去执行，watcher是一个对象，每个这样的函数执行时都应该创建一个watcher，通过watcher去执行</p>
<p>watcher会设置一个全局变量，让全局变量记录当前负责执行的watcher等于自己，然后再去执行函数，在函数的执行过程中，如果发生了依赖记录<code>dep.depend()</code>，那么<code>Dep</code>就会把这个全局变量记录下来，表示：有一个watcher用到了我这个属性</p>
<p>当Dep进行派发更新时，它会通知之前记录的所有watcher：我变了</p>
<img src="http://mdrs.yuanjin.tech/img/20210226161404.png" alt="image-20210226161404327" style="zoom:50%;" />

<p>每一个<code>vue</code>组件实例，都至少对应一个<code>watcher</code>，该<code>watcher</code>中记录了该组件的<code>render</code>函数。</p>
<p><code>watcher</code>首先会把<code>render</code>函数运行一次以收集依赖，于是那些在render中用到的响应式数据就会记录这个watcher。</p>
<p>当数据变化时，dep就会通知该watcher，而watcher将重新运行render函数，从而让界面重新渲染同时重新记录当前的依赖。</p>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>现在还剩下最后一个问题，就是Dep通知watcher之后，如果watcher执行重运行对应的函数，就有可能导致函数频繁运行，从而导致效率低下</p>
<p>试想，如果一个交给watcher的函数，它里面用到了属性a、b、c、d，那么a、b、c、d属性都会记录依赖，于是下面的代码将触发4次更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.a = <span class="string">&quot;new data&quot;</span>;</span><br><span class="line">state.b = <span class="string">&quot;new data&quot;</span>;</span><br><span class="line">state.c = <span class="string">&quot;new data&quot;</span>;</span><br><span class="line">state.d = <span class="string">&quot;new data&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样显然是不合适的，因此，watcher收到派发更新的通知后，实际上不是立即执行对应函数，而是把自己交给一个叫调度器的东西</p>
<p>调度器维护一个执行队列，该队列同一个watcher仅会存在一次，队列中的watcher不是立即执行，它会通过一个叫做<code>nextTick</code>的工具方法，把这些需要执行的watcher放入到事件循环的微队列中，nextTick的具体做法是通过<code>Promise</code>完成的</p>
<blockquote>
<p>nextTick 通过 <code>this.$nextTick</code> 暴露给开发者</p>
<p>nextTick 的具体处理方式见：<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97</a></p>
</blockquote>
<p>也就是说，当响应式数据变化时，<code>render</code>函数的执行是异步的，并且在微队列中</p>
<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><p><img src="http://mdrs.yuanjin.tech/img/20210226163936.png" alt="image-20210226163936839"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新增的数组API</title>
    <url>/135xyq.github.io/2021/12/31/%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84API/</url>
    <content><![CDATA[<h1 id="数组增强"><a href="#数组增强" class="headerlink" title="数组增强"></a>数组增强</h1><h2 id="新增数组API"><a href="#新增数组API" class="headerlink" title="新增数组API"></a>新增数组API</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>Array.of(…args): 使用指定的数组项创建一个新数组</li>
<li>Array.from(arg): 通过给定的类数组 或 可迭代对象 创建一个新的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>find(callback): 用于查找满足条件的第一个元素</li>
<li>findIndex(callback)：用于查找满足条件的第一个元素的下标</li>
<li>fill(data)：用指定的数据填充满数组所有的内容</li>
<li>copyWithin(target, start?, end?): 在数组内部完成复制<ul>
<li>target：开始改变数组位置</li>
<li>start？：复制的开始位置（默认为0）</li>
<li>end？：复制的结束位置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr.copyWithin(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr1.copyWithin(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr2.copyWithin(<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>includes(data)：判断数组中是否包含某个值，使用Object.is匹配</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>bom</tag>
      </tags>
  </entry>
  <entry>
    <title>AMD和CMD</title>
    <url>/135xyq.github.io/2022/01/20/%E6%A8%A1%E5%9D%97%E5%8C%96-AMD%E5%92%8CCMD/</url>
    <content><![CDATA[<h2 id="浏览器端模块化的难题"><a href="#浏览器端模块化的难题" class="headerlink" title="浏览器端模块化的难题"></a>浏览器端模块化的难题</h2><p><strong>CommonJS的工作原理</strong></p>
<p>当使用<code>require(模块路径)</code>导入一个模块时，node会做以下两件事情（不考虑模块缓存）：</p>
<ol>
<li>通过模块路径找到本机文件，并读取文件内容</li>
<li>将文件中的代码放入到一个函数环境中执行，并将执行后module.exports的值作为require函数的返回结果</li>
</ol>
<p>正是这两个步骤，使得CommonJS在node端可以良好的被支持</p>
<p>可以认为，<strong>CommonJS是同步的</strong>，必须要等到加载完文件并执行完代码后才能继续向后执行</p>
<p><strong>当浏览器遇到CommonJS</strong></p>
<p>当想要把CommonJS放到浏览器端时，就遇到了一些挑战</p>
<ol>
<li>浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能</li>
<li>如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准</li>
</ol>
<p><strong>新的规范</strong></p>
<p>基于以上两点原因，浏览器无法支持模块化</p>
<p>可这并不代表模块化不能在浏览器中实现</p>
<p>要在浏览器中实现模块化，只要能解决上面的两个问题就行了</p>
<p>解决办法其实很简单：</p>
<ol>
<li>远程加载JS浪费了时间？做成异步即可，加载完成后调用一个回调就行了</li>
<li>模块中的代码需要放置到函数中执行？编写模块时，直接放函数中就行了</li>
</ol>
<p>基于这种简单有效的思路，出现了AMD和CMD规范，有效的解决了浏览器模块化的问题。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>全称是Asynchronous Module Definition，即异步模块加载机制</p>
<p>require.js实现了AMD规范</p>
<p>在AMD中，导入和导出模块的代码，都必须放置在define函数中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([依赖的模块列表], <span class="function"><span class="keyword">function</span>(<span class="params">模块名称列表</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//模块内部的代码</span></span><br><span class="line">    <span class="keyword">return</span> 导出的内容</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>全称是Common Module Definition，公共模块定义规范</p>
<p>sea.js实现了CMD规范</p>
<p>在CMD中，导入和导出模块的代码，都必须放置在define函数中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//模块内部的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中混入和组件递归</title>
    <url>/135xyq.github.io/2022/01/01/%E6%B7%B7%E5%85%A5%E5%92%8C%E7%BB%84%E4%BB%B6%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>有的时候，许多组件有着类似的功能，这些功能代码分散在组件不同的配置中。</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210105161811.png" alt="image-20210105161811637"></p>
<p>于是，我们可以把这些配置代码抽离出来，利用<strong>混入</strong>融合到组件中。</p>
<p><img src="http://mdrs.yuanjin.tech/img/20210105162109.png" alt="image-20210105162109015"></p>
<p>具体的做法非常简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽离的公共代码</span></span><br><span class="line"><span class="keyword">const</span> common = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;common created&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用comp1，将会得到：</span></span><br><span class="line"><span class="comment"> * common created</span></span><br><span class="line"><span class="comment"> * comp1 created 1 2 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> comp1 = &#123;</span><br><span class="line">  <span class="attr">mixins</span>: [common] <span class="comment">// 之所以是数组，是因为可以混入多个配置代码</span></span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;comp1 created&quot;</span>, <span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cn.vuejs.org/v2/guide/mixins.html">官网</a></p>
<h2 id="组件递归"><a href="#组件递归" class="headerlink" title="组件递归"></a>组件递归</h2><p>递归：在组建内部使用自己<br>可以使用name来配置组件的名字，配置完成就可以使用了</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块化</title>
    <url>/135xyq.github.io/2022/01/20/%E6%A8%A1%E5%9D%97%E5%8C%96-ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="ES6模块化简介"><a href="#ES6模块化简介" class="headerlink" title="ES6模块化简介"></a>ES6模块化简介</h2><p>ECMA组织参考了众多社区模块化标准，终于在2015年，随着ES6发布了官方的模块化标准，后成为ES6模块化</p>
<h3 id="ES6模块化具有以下的特点"><a href="#ES6模块化具有以下的特点" class="headerlink" title="ES6模块化具有以下的特点"></a>ES6模块化具有以下的特点</h3><ol>
<li>使用依赖<strong>预声明</strong>的方式导入模块<ol>
<li>依赖延迟声明<ol>
<li>优点：某些时候可以提高效率</li>
<li>缺点：无法在一开始确定模块依赖关系（比较模糊）</li>
</ol>
</li>
<li>依赖预声明<ol>
<li>优点：在一开始可以确定模块依赖关系</li>
<li>缺点：某些时候效率较低</li>
</ol>
</li>
</ol>
</li>
<li>灵活的多种导入导出方式</li>
<li>规范的路径表示法：所有路径必须以./或../开头</li>
</ol>
<h2 id="基本导入导出"><a href="#基本导入导出" class="headerlink" title="基本导入导出"></a>基本导入导出</h2><h3 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h3><p><strong>注意：这一部分非模块化标准</strong></p>
<p>目前，浏览器使用以下方式引入一个ES6模块文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;入口文件&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="模块的基本导出和导入"><a href="#模块的基本导出和导入" class="headerlink" title="模块的基本导出和导入"></a>模块的基本导出和导入</h3><p>ES6中的模块导入导出分为两种：</p>
<ol>
<li>基本导入导出</li>
<li>默认导入导出</li>
</ol>
<p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96/ES6%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.jpg"></p>
<h3 id="基本导出"><a href="#基本导出" class="headerlink" title="基本导出"></a>基本导出</h3><p>类似于 <code>exports.xxx = xxxx</code></p>
<p>基本导出可以有多个，每个必须有名称</p>
<p>基本导出的语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> 声明表达式</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;xie&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;具名符号&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure>

<p>由于基本导出必须具有名称，所以要求导出内容必须跟上<strong>声明表达式</strong>或<strong>具名符号</strong></p>
<h3 id="基本导入"><a href="#基本导入" class="headerlink" title="基本导入"></a>基本导入</h3><p>由于使用的是<strong>依赖预加载</strong>，因此，导入任何其他模块，导入代码必须放置到所有代码之前</p>
<p>对于基本导出，如果要进行导入，使用下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;导入的符号列表&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">import</span> &#123; name, fn, fn1, a &#125; <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name, a);</span><br><span class="line">fn();</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<p>注意以下细节：</p>
<ul>
<li>导入时，可以通过关键字<code>as</code>对导入的符号进行重命名</li>
<li>导入时使用的符号是常量，不可修改</li>
<li>可以使用*号导入所有的基本导出，形成一个对象</li>
<li>如果仅仅只是想让某个模块的代码执行一遍不使用任何导出则可以使用 <code>import &quot;模块路径&quot; </code></li>
</ul>
<h2 id="默认导入导出"><a href="#默认导入导出" class="headerlink" title="默认导入导出"></a>默认导入导出</h2><p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96/ES6%E6%A8%A1%E5%9D%97%E5%8C%96-%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.jpg"></p>
<h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>每个模块，除了允许有多个基本导出之外，还允许有一个默认导出</p>
<p>默认导出类似于CommonJS中的<code>module.exports</code>，由于只有一个，因此无需具名</p>
<p>具体的语法是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 默认导出的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;xie&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;默认导出的数据 <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span><br></pre></td></tr></table></figure>

<p>由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句</p>
<h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>需要想要导入一个模块的默认导出，需要使用下面的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 接收变量名 <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name())</span><br></pre></td></tr></table></figure>

<p>类似于CommonJS中的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 接收变量名 = <span class="built_in">require</span>(<span class="string">&quot;模块路径&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>由于默认导入时变量名是自行定义的，因此没有别名一说</p>
<p>如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 接收默认导出的变量, &#123;接收基本导出的变量&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">import</span> name, &#123; fn &#125; <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>注：如果使用*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性default存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.default)</span><br></pre></td></tr></table></figure>

<h2 id="ES6模块化的其他细节"><a href="#ES6模块化的其他细节" class="headerlink" title="ES6模块化的其他细节"></a>ES6模块化的其他细节</h2><h3 id="1-尽量导出不可变值"><a href="#1-尽量导出不可变值" class="headerlink" title="1. 尽量导出不可变值"></a>1. <strong>尽量导出不可变值</strong></h3><p>当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）</p>
<p>因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生</p>
<h3 id="2-可以使用无绑定的导入用于执行一些初始化代码"><a href="#2-可以使用无绑定的导入用于执行一些初始化代码" class="headerlink" title="2. 可以使用无绑定的导入用于执行一些初始化代码"></a>2. <strong>可以使用无绑定的导入用于执行一些初始化代码</strong></h3><p>如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-可以使用绑定再导出，来重新导出来自另一个模块的内容"><a href="#3-可以使用绑定再导出，来重新导出来自另一个模块的内容" class="headerlink" title="3. 可以使用绑定再导出，来重新导出来自另一个模块的内容"></a>3. <strong>可以使用绑定再导出，来重新导出来自另一个模块的内容</strong></h3><p>有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;绑定的标识符&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96/ES6%E6%A8%A1%E5%9D%97%E5%8C%96-%E6%B7%B7%E5%90%88%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>用户登录的逻辑</title>
    <url>/135xyq.github.io/2022/01/01/%E7%99%BB%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="用户模块逻辑示意图"><a href="#用户模块逻辑示意图" class="headerlink" title="用户模块逻辑示意图"></a>用户模块逻辑示意图</h1><p>路由总体示意图</p>
<p><img src="/images/vue2/%E7%99%BB%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86-%E8%B7%AF%E7%94%B1%E6%80%BB%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="image-20210130141625925"></p>
<p>鉴权守卫逻辑示意图</p>
<p><img src="/images/vue2/%E7%99%BB%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86-%E9%89%B4%E6%9D%83%E5%AE%88%E5%8D%AB.jpg" alt="image-20210130144001709"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p><a href="https://cn.vuejs.org/v2/api/#watch">watch配置</a></p>
<p><a href="https://cn.vuejs.org/v2/api/#vm-watch">Vue.prototype.$watch</a></p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p><a href="https://vuex.vuejs.org/zh/guide/state.html#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapState</a></p>
<p><a href="https://vuex.vuejs.org/zh/guide/getters.html">getters</a></p>
<p><a href="https://vuex.vuejs.org/zh/guide/getters.html#mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapGetters</a></p>
<p><a href="https://vuex.vuejs.org/zh/guide/modules.html">modules</a></p>
<p><a href="https://vuex.vuejs.org/zh/api/#watch">watch</a></p>
<h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><p><a href="https://router.vuejs.org/api/#exact-path">exact-path</a></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">导航守卫</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的组件事件</title>
    <url>/135xyq.github.io/2022/01/01/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>在样式中可以用 ‘~@’定位到src目录<br>在script中用‘@’可定位到src目录</p>
<ol>
<li><p><strong>全局样式</strong></p>
</li>
<li><p><strong>v-if 和 v-show</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-v-if&v-show.jpg" alt="image-20201113133827438"></h2><p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-v-if&v-show1.jpg" alt="image-20201113134051281"><br><strong>面试题：v-if 和 v-show 有什么区别？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-if能够控制是否生成vnode，也就间接控制了是否生成对应的dom。当v-if为true时，会生成对应的vnode，并生成对应的dom元素；当其为false时，不会生成对应的vnode，自然不会生成任何的dom元素。</span><br><span class="line">v-show始终会生成vnode，也就间接导致了始终生成dom。它只是控制dom的display属性，当v-show为true时，不做任何处理；当其为false时，生成的dom的display属性为none。</span><br><span class="line">使用v-if可以有效的减少树的节点和渲染量，但也会导致树的不稳定；而使用v-show可以保持树的稳定，但不能减少树的节点和渲染量。</span><br><span class="line">因此，在实际开发中，显示状态变化频繁的情况下应该使用v-show，以保持树的稳定；显示状态变化较少时应该使用v-if，以减少树的节点和渲染量。</span><br></pre></td></tr></table></figure></li>
<li><p><strong>组件事件</strong></p>
</li>
</ol>
<img src="http://mdrs.yuanjin.tech/img/20201113134557.png" alt="image-20201113134557175" style="zoom:40%;" />

<p>抛出事件：子组件在某个时候发生了一件事，但自身无法处理，于是通过事件的方式通知父组件处理</p>
<p>事件参数：子组件抛出事件时，传递给父组件的数据</p>
<p>注册事件：父组件申明，当子组件发生某件事的时候，自身将做出一些处理</p>
<p><a href="/images/vue2/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6.jpg">事件</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2组件</title>
    <url>/135xyq.github.io/2022/01/01/%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>组件的出现是为了实现以下两个目标：</p>
<ol>
<li>降低整体复杂度，提升代码的可读性和可维护性</li>
<li>提升局部代码的可复用性</li>
</ol>
<p>绝大部分情况下，一个组件就是页面中某个区域，组件包含该区域的：</p>
<ul>
<li><p>功能（JS代码）</p>
</li>
<li><p>内容（模板代码）</p>
</li>
<li><p>样式（CSS代码）</p>
<blockquote>
<p>要在组件中包含样式，需要构建工具的支撑</p>
</blockquote>
</li>
</ul>
<h2 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h2><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>组件是根据一个普通的配置对象创建的，所以要开发一个组件，只需要写一个配置对象即可</p>
<p>该配置对象和vue实例的配置是<strong>几乎一样</strong>的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件配置对象</span></span><br><span class="line"><span class="keyword">var</span> myComp = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`....`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，组件配置对象和vue实例有以下几点差异：</p>
<ul>
<li>无<code>el</code></li>
<li><code>data</code>必须是一个函数，该函数返回的对象作为数据</li>
<li>由于没有<code>el</code>配置，组件的虚拟DOM树必须定义在<code>template</code>或<code>render</code>中</li>
</ul>
<h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><p>注册组件分为两种方式，一种是<strong>全局注册</strong>，一种是<strong>局部注册</strong></p>
<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>一旦全局注册了一个组件，整个应用中任何地方都可以使用该组件</p>
<img src="http://mdrs.yuanjin.tech/img/2020-02-18-10-24-44.png" style="zoom:50%;" />

<p>全局注册的方式是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：组件名称，将来在模板中使用组件时，会使用该名称</span></span><br><span class="line"><span class="comment">// 参数2：组件配置对象</span></span><br><span class="line"><span class="comment">// 该代码运行后，即可在模板中使用组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;my-comp&#x27;</span>, myComp)</span><br></pre></td></tr></table></figure>

<p>在模板中，可以使用组件了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-comp</span>&gt;</span><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>但在一些工程化的大型项目中，很多组件都不需要全局使用。<br>比如一个登录组件，只有在登录的相关页面中使用，如果全局注册，将导致构建工具无法优化打包<br><strong>因此，除非组件特别通用，否则不建议使用全局注册</strong></p>
</blockquote>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册就是哪里要用到组件，就在哪里注册</p>
<img src="http://mdrs.yuanjin.tech/img/2020-02-18-10-28-45.png" style="zoom:50%;" />

<p>局部注册的方式是，在要使用组件的组件或实例中加入一个配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是另一个要使用my-comp的组件</span></span><br><span class="line"><span class="keyword">var</span> otherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="comment">// 属性名为组件名称，模板中将使用该名称</span></span><br><span class="line">    <span class="comment">// 属性值为组件配置对象</span></span><br><span class="line">    <span class="string">&quot;my-comp&quot;</span>: myComp</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;!-- 该组件的其他内容 --&gt;</span></span><br><span class="line"><span class="string">      &lt;my-comp&gt;&lt;/my-comp&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用组件"><a href="#应用组件" class="headerlink" title="应用组件"></a>应用组件</h2><p>在模板中使用组件特别简单，把组件名当作HTML元素名使用即可。</p>
<p>但要注意以下几点：</p>
<ol>
<li><strong>组件必须有结束</strong></li>
</ol>
<p>组件可以自结束，也可以用结束标记结束，但必须要有结束</p>
<p>下面的组件使用是错误的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>组件的命名</strong></li>
</ol>
<p>无论你使用哪种方式注册组件，组件的命名需要遵循规范。</p>
<p>组件可以使用<code>kebab-case 短横线命名法</code>，也可以使用<code>PascalCase 大驼峰命名法</code></p>
<p>下面两种命名均是可以的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> otherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="string">&quot;my-comp&quot;</span>: myComp,  <span class="comment">// 方式1</span></span><br><span class="line">    <span class="attr">MyComp</span>: myComp <span class="comment">//方式2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，使用<code>小驼峰命名法 camelCase</code>也是可以识别的，只不过不符合官方要求的规范</p>
</blockquote>
<p>使用<code>PascalCase</code>方式命名还有一个额外的好处，即可以在模板中使用两种组件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> otherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="attr">MyComp</span>: myComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComp</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>因此，在使用组件时，为了方便，往往使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComp = &#123;</span><br><span class="line">  <span class="comment">//组件配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OtherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    MyComp <span class="comment">// ES6速写属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组件树"><a href="#组件树" class="headerlink" title="组件树"></a>组件树</h2><p>一个组件创建好后，往往会在各种地方使用它。它可能多次出现在vue实例中，也可能出现在其他组件中。</p>
<p>于是就形成了一个组件树</p>
<img src="http://mdrs.yuanjin.tech/img/2020-02-18-11-00-58.png" style="zoom:50%;" />

<h2 id="向组件传递数据"><a href="#向组件传递数据" class="headerlink" title="向组件传递数据"></a>向组件传递数据</h2><p>大部分组件要完成自身的功能，都需要一些额外的信息</p>
<p>比如一个头像组件，需要告诉它头像的地址，这就需要在使用组件时向组件传递数据</p>
<p>传递数据的方式有很多种，最常见的一种是使用<strong>组件属性 component props</strong></p>
<p>首先在组件中申明可以接收哪些属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComp = &#123;</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line">  <span class="comment">// 和vue实例一样，使用组件时也会创建组件的实例</span></span><br><span class="line">  <span class="comment">// 而组件的属性会被提取到组件实例中，因此可以在模板中使用</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;p1&#125;&#125;, &#123;&#123;p2&#125;&#125;, &#123;&#123;p3&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用组件时，向其传递属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OtherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    MyComp</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;my-comp :p1=&quot;a&quot; :p2=&quot;2&quot; p3=&quot;3&quot;/&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：在组件中，属性是只读的，绝不可以更改，这叫做单向数据流</strong></p>
<img src="http://mdrs.yuanjin.tech/img/2020-02-18-11-13-19.png" style="zoom:50%;" />

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的组件生命周期</title>
    <url>/135xyq.github.io/2022/01/01/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h1><p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-1.jpg"></p>
<p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-2.jpg"></p>
<h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><blockquote>
<p>不要死记硬背，要根据具体情况灵活处理</p>
</blockquote>
<h2 id="加载远程数据"><a href="#加载远程数据" class="headerlink" title="加载远程数据"></a>加载远程数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">news</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.news = <span class="keyword">await</span> getNews();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接操作DOM"><a href="#直接操作DOM" class="headerlink" title="直接操作DOM"></a>直接操作DOM</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">containerWidth</span>:<span class="number">0</span>,</span><br><span class="line">    	<span class="attr">containerHeight</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.containerWidth = <span class="built_in">this</span>.$refs.container.clientWidth;</span><br><span class="line">    <span class="built_in">this</span>.containerHeight = <span class="built_in">this</span>.$refs.container.containerHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动和清除计时器"><a href="#启动和清除计时器" class="headerlink" title="启动和清除计时器"></a>启动和清除计时器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">timer</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     ... </span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);               </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的组件通信</title>
    <url>/135xyq.github.io/2022/01/01/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>面试题：vue组件之间有哪些通信方式？</p>
<h1 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h1><blockquote>
<p>绝大部分<code>vue</code>本身提供的通信方式，都是父子组件通信</p>
</blockquote>
<h2 id="prop"><a href="#prop" class="headerlink" title="prop"></a><code>prop</code></h2><p>最常见的组件通信方式之一，由父组件传递到子组件</p>
<h2 id="event"><a href="#event" class="headerlink" title="event"></a><code>event</code></h2><p>最常见的组件通信方式之一，当子组件发生了某些事，可以通过<code>event</code>通知父组件</p>
<h2 id="style和class"><a href="#style和class" class="headerlink" title="style和class"></a><code>style</code>和<code>class</code></h2><p>父组件可以向子组件传递<code>style</code>和<code>class</code>，它们会合并到子组件的根元素中</p>
<p><strong>示例</strong></p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;HelloWorld</span><br><span class="line">      style=&quot;color:red&quot;</span><br><span class="line">      class=&quot;hello&quot;</span><br><span class="line">      msg=&quot;Welcome to Your Vue.js App&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &quot;./components/HelloWorld.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;world&quot; style=&quot;text-align:center&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HelloWorld&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello world&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red; text-aling:center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Your Vue.js App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><code>attribute</code></h2><p>如果父组件传递了一些属性到子组件，但子组件并没有声明这些属性，则它们称之为<code>attribute</code>，这些属性会直接附着在子组件的根元素上</p>
<blockquote>
<p>不包括<code>style</code>和<code>class</code>，它们会被特殊处理</p>
</blockquote>
<p><strong>示例</strong></p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 除 msg 外，其他均为 attribute --&gt;</span><br><span class="line">    &lt;HelloWorld</span><br><span class="line">      data-a=&quot;1&quot;</span><br><span class="line">      data-b=&quot;2&quot;</span><br><span class="line">      msg=&quot;Welcome to Your Vue.js App&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &quot;./components/HelloWorld.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HelloWorld&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // 得到： &#123; &quot;data-a&quot;: &quot;1&quot;, &quot;data-b&quot;: &quot;2&quot; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-a</span>=<span class="string">&quot;1&quot;</span> <span class="attr">data-b</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Your Vue.js App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件可以通过<code>inheritAttrs: false</code>配置，禁止将<code>attribute</code>附着在子组件的根元素上，但不影响通过<code>$attrs</code>获取</p>
<h2 id="natvie修饰符"><a href="#natvie修饰符" class="headerlink" title="natvie修饰符"></a><code>natvie</code>修饰符</h2><p>在注册事件时，父组件可以使用<code>native</code>修饰符，将事件注册到子组件的根元素上</p>
<p><strong>示例</strong></p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;HelloWorld @click.native=&quot;handleClick&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &quot;./components/HelloWorld.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      console.log(1);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>渲染结果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 点击该 div，会输出 1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a><code>$listeners</code></h2><p>子组件可以通过<code>$listeners</code>获取父组件传递过来的所有事件处理函数</p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h2><p>后续章节讲解</p>
<h2 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title="sync修饰符"></a><code>sync</code>修饰符</h2><p>和<code>v-model</code>的作用类似，用于双向绑定，不同点在于<code>v-model</code>只能针对一个数据进行双向绑定，而<code>sync</code>修饰符没有限制</p>
<p>示例</p>
<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;button @click=&quot;$emit(`update:num1`, num1 - 1)&quot;&gt;-&lt;/button&gt;</span><br><span class="line">      &#123;&#123; num1 &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;$emit(`update:num1`, num1 + 1)&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;button @click=&quot;$emit(`update:num2`, num2 - 1)&quot;&gt;-&lt;/button&gt;</span><br><span class="line">      &#123;&#123; num2 &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;$emit(`update:num2`, num2 + 1)&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;num1&quot;, &quot;num2&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Numbers :num1.sync=&quot;n1&quot; :num2.sync=&quot;n2&quot; /&gt;</span><br><span class="line">    &lt;!-- 等同于 --&gt;</span><br><span class="line">    &lt;Numbers</span><br><span class="line">      :num1=&quot;n1&quot;</span><br><span class="line">      @update:num1=&quot;n1 = $event&quot;</span><br><span class="line">      :num2=&quot;n2&quot;</span><br><span class="line">      @update:num2=&quot;n2 = $event&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Numbers from &quot;./components/Numbers.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Numbers,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      n1: 0,</span><br><span class="line">      n2: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a><code>$parent</code>和<code>$children</code></h2><p>在组件内部，可以通过<code>$parent</code>和<code>$children</code>属性，分别得到当前组件的父组件和子组件实例</p>
<h2 id="slots和-scopedSlots"><a href="#slots和-scopedSlots" class="headerlink" title="$slots和$scopedSlots"></a><code>$slots</code>和<code>$scopedSlots</code></h2><p>后续章节讲解</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h2><p>父组件可以通过<code>ref</code>获取到子组件的实例</p>
<h1 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h1><h2 id="Provide和Inject"><a href="#Provide和Inject" class="headerlink" title="Provide和Inject"></a><code>Provide</code>和<code>Inject</code></h2><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父级组件提供 &#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">var</span> Provider = &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件注入 &#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo) <span class="comment">// =&gt; &quot;bar&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详见：<a href="https://cn.vuejs.org/v2/api/#provide-inject">https://cn.vuejs.org/v2/api/?#provide-inject</a></p>
<h2 id="router"><a href="#router" class="headerlink" title="router"></a><code>router</code></h2><p>如果一个组件改变了地址栏，所有监听地址栏的组件都会做出相应反应</p>
<p>最常见的场景就是通过点击<code>router-link</code>组件改变了地址，<code>router-view</code>组件就渲染其他内容</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><code>vuex</code></h2><p>适用于大型项目的数据仓库</p>
<h2 id="store模式"><a href="#store模式" class="headerlink" title="store模式"></a><code>store</code>模式</h2><p>适用于中小型项目的数据仓库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  <span class="attr">loginUser</span>: ...,</span><br><span class="line">  <span class="attr">setting</span>: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compA</span></span><br><span class="line"><span class="keyword">const</span> compA = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">loginUser</span>: store.loginUser</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compB</span></span><br><span class="line"><span class="keyword">const</span> compB = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">setting</span>: store.setting,</span><br><span class="line">      <span class="attr">loginUser</span>: store.loginUser</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="eventbus"><a href="#eventbus" class="headerlink" title="eventbus"></a><code>eventbus</code></h2><p>组件通知事件总线发生了某件事，事件总线通知其他监听该事件的所有组件运行某个函数</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的继承 枚举和数组介绍</title>
    <url>/135xyq.github.io/2021/12/31/%E7%BB%A7%E6%89%BF_%E6%9E%9A%E4%B8%BE_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="继承-枚举-数组"><a href="#继承-枚举-数组" class="headerlink" title="继承 枚举 数组"></a>继承 枚举 数组</h1><hr>
<h3 id="弊端：两个对象的原型会指向同一个内存空间，会一起改变"><a href="#弊端：两个对象的原型会指向同一个内存空间，会一起改变" class="headerlink" title="弊端：两个对象的原型会指向同一个内存空间，会一起改变"></a>弊端：两个对象的原型会指向同一个内存空间，会一起改变</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        Father.prototype.lastNmae = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">            Target.prototype = Origin.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        inherit(Son, Father);</span><br><span class="line">        <span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以让son和father有相同的原型，互相之间更改相关联</span></span><br></pre></td></tr></table></figure>

<h3 id="弊端：两个对象的原型会指向同一个内存空间，会一起改变-1"><a href="#弊端：两个对象的原型会指向同一个内存空间，会一起改变-1" class="headerlink" title="弊端：两个对象的原型会指向同一个内存空间，会一起改变"></a>弊端：两个对象的原型会指向同一个内存空间，会一起改变</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        Father.prototype.lastNmae = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">            Target.prototype = Origin.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        inherit(Son, Father);</span><br><span class="line">        Son.prototype.sex = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line">结果为son和father都可以访问sex属性为male</span><br></pre></td></tr></table></figure>
<h3 id="圣杯模式：解决互相影响的问题"><a href="#圣杯模式：解决互相影响的问题" class="headerlink" title="圣杯模式：解决互相影响的问题"></a>圣杯模式：解决互相影响的问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        Father.prototype.lastName = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            F.prototype = Origin.prototype;</span><br><span class="line">            Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">        &#125;</span><br><span class="line">        inherit(Son, Father);</span><br><span class="line">        <span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line">    </span><br><span class="line">son和father有相同的原型，但son的更改对于father没有影响</span><br><span class="line">此时son的constuctor指向Father（）</span><br><span class="line">    Father.prototype.lastName = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            F.prototype = Origin.prototype;</span><br><span class="line">            Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">        Target.prototype.constuctor = Target;<span class="comment">//使Target产生的对象的constuctor指向Target（）</span></span><br><span class="line">        &#125;</span><br><span class="line">        inherit(Son, Father);</span><br><span class="line">        <span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure>

<p>命名空间：用对象解决变量重名，模块化开发。</p>
<h4 id="属性的表示方法："><a href="#属性的表示方法：" class="headerlink" title="属性的表示方法："></a>属性的表示方法：</h4><p>obj.属性名<br>obj.[“属性名”]  </p>
<h3 id="遍历枚举"><a href="#遍历枚举" class="headerlink" title="遍历枚举"></a>遍历枚举</h3><h4 id="遍历对象的属性："><a href="#遍历对象的属性：" class="headerlink" title="遍历对象的属性："></a>遍历对象的属性：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（ <span class="keyword">var</span> 变量名 <span class="keyword">in</span> 对象名）&#123;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">            <span class="attr">weight</span>: <span class="number">75</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(prop);</span><br><span class="line">        &#125;</span><br><span class="line">        可以遍历对象的属性名</span><br></pre></td></tr></table></figure>
<p>在枚举中调用对象属性不能用  对象名.属性名   ,可以用对象名[属性名]</p>
<p>A  instanceof B  看A对象的原型链上有没有 B的原型</p>
<p>typeof可能返回的类型：</p>
<ul>
<li>string    </li>
<li>object  </li>
<li>undefined  </li>
<li>function  </li>
<li>number  </li>
<li>boolean</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol>
<li>函数预编译过程 this - &gt; window</li>
<li>全局作用域里 this -&gt; window</li>
<li>call / apply 可以改变函数运行时的this指向</li>
<li>obj.func();  func() 里面的this指向obj<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;222&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> a = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">            <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> fun = a.say;</span><br><span class="line">        fun(); <span class="comment">//222</span></span><br><span class="line">        a.say(); <span class="comment">//111</span></span><br><span class="line">        <span class="keyword">var</span> b = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;333&quot;</span>,</span><br><span class="line">            <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">                fun();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b.say(a.say); <span class="comment">//222</span></span><br><span class="line">        b.say = a.say;</span><br><span class="line">        b.say(); <span class="comment">//333</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">arguments</span>.callee() ;可以找到函数的引用名</span><br><span class="line">        <span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(<span class="number">100</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">        <span class="comment">//用立即执行函数通过递归求100的阶乘</span></span><br></pre></td></tr></table></figure>
<h3 id="浅层克隆（引用值不独立，原始值独立）"><a href="#浅层克隆（引用值不独立，原始值独立）" class="headerlink" title="浅层克隆（引用值不独立，原始值独立）"></a>浅层克隆（引用值不独立，原始值独立）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//克隆函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin,target</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> target = target || &#123;&#125;; <span class="comment">//避免用户不传新的对象</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">                target[prop] = origin[prop];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="深层克隆（递归）"><a href="#深层克隆（递归）" class="headerlink" title="深层克隆（递归）"></a>深层克隆（递归）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deepjClone</span>(<span class="params">origin,target</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> target = target || &#123;&#125;,</span><br><span class="line">                toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">                arrStr = <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prigin.hasOfwnPropertyJ(prop))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(origin[prop] !== <span class="string">&quot;null&quot;</span> &amp;&amp; <span class="keyword">typeof</span>(origin[prop] == <span class="string">&#x27;object&#x27;</span>))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(toStr.call(origin[prop] == arrStr))&#123;</span><br><span class="line">                            target[prop] = origin[prop];</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            target[prop] = origin[prop];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    deepjClone(origin[prop],target[prop]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    target[prop] = origin[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><h4 id="数组字面量：var-数组名"><a href="#数组字面量：var-数组名" class="headerlink" title="数组字面量：var 数组名  = [ ];"></a>数组字面量：<code>var 数组名  = [ ];</code></h4><h4 id="构造方法：-var-数组名-new-Array-参数"><a href="#构造方法：-var-数组名-new-Array-参数" class="headerlink" title="构造方法： var 数组名 =  new Array(参数); "></a>构造方法： <code>var 数组名 =  new Array(参数); </code></h4><p>参数个数为1时代表数组的长度（只能为整数），个数大于1时代表数组的具体内容。</p>
<p>数组的所有方法全来自 Array.prototype</p>
<p>数组可以越界读取数据（undefined）</p>
<h3 id="数组的方法："><a href="#数组的方法：" class="headerlink" title="数组的方法："></a>数组的方法：</h3><h4 id="1-改变原数组："><a href="#1-改变原数组：" class="headerlink" title="1. 改变原数组："></a>1. 改变原数组：</h4><ul>
<li>push : 在数组最后面添加内容（可一次添加多个）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [];</span><br><span class="line">        arr.push(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li>
<li>pop:剪切出数组最后一位<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">        arr.pop();</span><br><span class="line"><span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure></li>
<li>unshift:在数组最前面加内容(可一次添加多个)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        arr.unshift(<span class="number">0</span>);</span><br><span class="line">数组为：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
<li>shift:剪切数组最前面的内容<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        arr.shift();</span><br><span class="line">数组为[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
<li>reverse:数组逆序<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        arr.reverse();</span><br><span class="line">数组为[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
<li>sort：将数组内容排序(按ASCII码排序)</li>
</ul>
<h5 id="正常使用："><a href="#正常使用：" class="headerlink" title="正常使用："></a>正常使用：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">数组名.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a , b </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  变量名；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ol>
<li>必须写俩形参</li>
<li>看返回值： <ol>
<li>返回值为负数：前一个数放在前面</li>
<li>返回值为正数：后一个数放在前面</li>
<li>返回值为0时：顺序不动<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        arr.sort();</span><br><span class="line">   数组为[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line">        arr.sort().reverse();</span><br><span class="line">   逆序</span><br><span class="line">   数组为：[<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>] </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">        arr.sort();</span><br><span class="line">   数组为：[<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">        arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">   顺序</span><br><span class="line">   数组为：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">        arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">   逆序</span><br><span class="line">   数组为：[<span class="number">10</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">   升序：</span><br><span class="line">   <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">        arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;);</span><br><span class="line">   </span><br><span class="line">   降序</span><br><span class="line">   <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">        arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<ul>
<li>splice:数组切片(可在任意位置添加内容)<br>数组名.splice(从第几位开始，截取的长度，在切口处添加新的数据)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line">        arr.splice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">数组内容为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line">        arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">数组内容为：[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">        arr.splice(<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">数组内容为：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-不改变原数组："><a href="#2-不改变原数组：" class="headerlink" title="2.不改变原数组："></a>2.不改变原数组：</h4></li>
<li>concat() :连接两个数组<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">        arr2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">        arr = arr1.concat(arr2);</span><br><span class="line">arr : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></li>
<li>slice : 截取<br>数组.slice(截取开始位置，截取结束位置)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">var</span> arr = arr1.slice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">arr:[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">var</span> arr = arr1.slice(<span class="number">1</span>);</span><br><span class="line">arr:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
<li>join：将数组各位连接起来<br>数组名.join(字符串)；<br>无参数默认为用 , 连接<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">var</span> arr = arr1.join(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">arr：<span class="string">&quot;1!2!3!4&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>split:将字符串按照某一规则拆分成数组,与join互逆<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// arr2 = [5, 6, 7, 8];</span></span><br><span class="line">        <span class="comment">// var arr = arr1.concat(arr2);</span></span><br><span class="line">        <span class="comment">// var arr = arr1.slice(1);</span></span><br><span class="line">        <span class="keyword">var</span> str = arr1.join(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> arr = str.split(<span class="string">&quot;!&quot;</span>); </span><br><span class="line">arr: [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>]</span><br></pre></td></tr></table></figure>
类数组：像数组的对象<br>属性要为索引（数字）属性，必须有length属性，最好加上push<br>arguments是个类数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;length&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;push&quot;</span>: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">    <span class="string">&quot;splice&quot;</span>: <span class="built_in">Array</span>.prototype.splice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在try里面的发生错误，不会执行错误后的try里的代码</p>
<p><code>e.name:错误名称</code><br><code>e.message:错误信息</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">输出为：a  e  d</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">&quot;:&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">可打印出出错信息</span><br></pre></td></tr></table></figure>
<h4 id="Error-name的六种值对应的信息："><a href="#Error-name的六种值对应的信息：" class="headerlink" title="Error.name的六种值对应的信息："></a>Error.name的六种值对应的信息：</h4><ol>
<li>EvalError : eval()的使用与定义不一致</li>
<li>RangeError：数值越界</li>
<li>ReferenceError：非法或不能识别的引用数值</li>
<li>SyntaxError：发生语法解析错误</li>
<li>TypeError：操作数类型错误</li>
<li>URIError：URI处理函数使用不当</li>
</ol>
<h4 id="es5-0严格模式："><a href="#es5-0严格模式：" class="headerlink" title="es5.0严格模式："></a>es5.0严格模式：</h4><p>不再兼容es3的一些不规则语法，使用全新的es5规范（不会对不兼容严格模式的浏览器产生影响）</p>
<p>“use strict”;来启动es5.0严格模式（写在逻辑最顶端）<br>可以使用全局严格模式<br>也可以使用局部函数内严格模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">对象名</span>)</span>&#123;</span><br><span class="line">代码体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将with里面的代码的作用域链最顶端改为新给出的对象（降低效率）</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>网络的基本知识</title>
    <url>/135xyq.github.io/2021/12/31/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><hr>
<p>WWW(World Wide Web)</p>
<p>冯诺依曼计算机：<br>运算器，存储器，控制器，输入设备，输出设备</p>
<p>IP地址：网络ID + 主机ID</p>
<p>域名经过DNS解析 为IP地址</p>
<p>127.0.0.1 访问本机<br>0.0.0.0  不知道IP地址，访问本机</p>
<p>五层网络模型：<br>应用层，运输层，网络层，数据链路层，物理层</p>
<p>发送文件，大量数据要用POST<br>GET请求： GET /path?.. = ..&amp;..=.. HTTP1.1 ,        请求的参数都在URL里 ，</p>
<p>POST请求：</p>
<p>请求：Request：</p>
<ul>
<li>请求头</li>
<li>数据体</li>
<li>请求方式url版本协议</li>
</ul>
<p>响应：Response：</p>
<ul>
<li>响应头</li>
<li>数据体</li>
<li>协议版本   状态码 message</li>
</ul>
<h3 id="Get和Post请求方式的区别："><a href="#Get和Post请求方式的区别：" class="headerlink" title="Get和Post请求方式的区别："></a>Get和Post请求方式的区别：</h3><ol>
<li>是基于什么前提的？如果什么前提都没有，不使用任何规范，只考虑语法和理论上的HTTP协议：<br>GET和POST几乎没有什么区别，只有名字不一样。</li>
<li>如果是基于RFC规范的：<ul>
<li>理论上：get和post具有相同语法，但是有不同的语义。get是用来获取数据的，post是用来发送数据的，其它方面没有区别。</li>
<li>实现上：各种浏览器，就是这个规范的实现者。常见的那些不同：get的数据在URL是可见的，post请求是不显示在URL中的。get请求是有长度限制的，post长度的无限的。get请求的数据可以收藏为书签，post请求到的不可以收藏为书签。get请求后，按后退按钮、刷新按钮无影响，post数据会被重新提交。get编码类型：application/x-www-form-url,post的编码类型有很多：encodeapplication/x-www-form-urlencoded    multipart/form-data。get的历史参数会被保留在浏览器里，post的不会保存在浏览器中。get值允许ASCII，post没有编码限制，允许发二进制。get与post相比get的安全性较差，因为所发的数据是URL的一部分。</li>
</ul>
</li>
</ol>
<h3 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><ol>
<li><p>如果我们⽤JS的变量来存数据，那么在⻚⾯关闭的时候，数据就消失了。</p>
</li>
<li><p>保持登录状态是怎么做到的呢？</p>
<p> 按照正常的HTTP协议来说，是做不到的。<br>因为HTTP协议，上下⽂⽆关协议。</p>
</li>
<li><p>所以说前端⻚⾯上，有可以持久化存储数据的东⻄。⼀旦登录成功，我就记载在这个⾥⾯。</p>
</li>
</ol>
<p>Cookie是有限制的。</p>
<p>Cookie是存在浏览器⾥的，不是存在某个⻚⾯上的。是可以⻓期存储的。Cookie即使是保存在浏览器⾥，也是存放在不同的域名下的。</p>
<ol>
<li><p>初始状态：没有登录</p>
</li>
<li><p>访问百度的登录，输⼊⽤户名，密码。</p>
</li>
<li><p>如果⽤户名和密码是正确的。百度的后端会向这个域名下，设置⼀个Cookie。写⼊⽤户的基本信息（加密的）。</p>
</li>
<li><p>以后每⼀次向百度发送请求，浏览器都会⾃动带上这些Cookie。</p>
</li>
<li><p>服务端（后端）看到了带有ID的cookie，就可以解析这个加密的ID，来获取到这个⽤户本身的ID。</p>
</li>
<li><p>如果能获取到本身的ID，那么就证明这个⽤户已经登录过了。所以后端可以继续保留⽤户的信息。</p>
</li>
</ol>
<p><strong>缺点</strong>：如果某个坏⼈，复制了我浏览器⾥的cookie，他就可以在他的电脑上登录我的账号了。</p>
<p>XSS注⼊攻击。浏览器 </p>
<h4 id="数据存在Session上也有缺点："><a href="#数据存在Session上也有缺点：" class="headerlink" title="数据存在Session上也有缺点："></a>数据存在Session上也有缺点：</h4><p>如果⽤户量⾮常⼤，上亿的⽤户。</p>
<p>在⽤户量很⼤的时候，服务器端很耗资源的。</p>
<p>因为后端可能不⽌⼀台服务器，⽤户的登录信息，⼀般只存在⼀台服务器上。</p>
<p>因为⽤户的登录操作，在哪台机器上执⾏的，就⼀般存在哪台机器上。</p>
<p>需要通过反向代理。（轮询，IP哈希。）</p>
<h3 id="B-S结构-C-S结构"><a href="#B-S结构-C-S结构" class="headerlink" title="B/S结构    C/S结构"></a>B/S结构    C/S结构</h3><p>Client/Server——Client只负责内容的展示，Server负责提供内容。</p>
<p>Browser/Server——Browser只负责内容的展示，Server负责提供内容。</p>
<p>⻚⾯的本质是什么？<br>⻚⾯的本质就是⼀个字符串。带有HTML格式的字符串。</p>
<p>浏览器 向服务器 请求⼀个⻚⾯的本质是什么？</p>
<p>（1）<a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>（2）服务器接收到这个请求后，服务器想要把这个⻚⾯的内容（HTML格式的字符串）返回</p>
<p>给浏览器。</p>
<p>（3）⻚⾯的字符串存在哪⾥呢？存在HTML⽂件⾥。例如：index.html </p>
<p>（4）服务器端要读取⽂件。</p>
<p>（5）将读取出来的内容返回给浏览器。</p>
<p>最后返回的是⼀个字符串，这个字符串的来源可能是⽂件，可能是缓存，可能来⾃于数据库。</p>
<p>服务器：严格的说，服务器是⼀台计算机，这台计算机，只提供服务。（不是⽤户⽤的）</p>
<p>但是，我们常说的这个服务器，指的是服务容器，不是服务器。</p>
<p>服务容器：是⼀个程序。程序可以监听⼀个端⼝。读取⽂件，并且返回。</p>
<p>如果我们想通过访问服务器（服务容器）的⽅式，来访问我们⾃⼰写的⻚⾯。</p>
<p>我们就得装⼀个服务容器的程序。</p>
<p>向后端发出请求：</p>
<ol>
<li>在浏览器中直接输入网址（无法用代码控制）</li>
<li>location.href = url; 可以发出网络请求，但是页面会发生跳转。（页面跳转）</li>
<li>带有src属性的标签，请求是可以发出的，服务端是可以处理也是可以返回的，但是返回之后能否被应用，还要看浏览器。（页面无法处理返回结果）</li>
<li>带有href属性的标签，请求是可以发出的，服务端是可以处理也是可以返回的，但是返回之后能否被应用，还要看浏览器。（页面无法处理返回结果）</li>
<li>带有action属性的标签，例如form表单，也可以向后端发出请求。但是form表单发出请求之后，也会页面跳转。（页面会跳转）</li>
<li>ajax请求</li>
</ol>
<p><strong>要素；请求方式，url</strong></p>
<h3 id="跨域访问资源"><a href="#跨域访问资源" class="headerlink" title="跨域访问资源"></a>跨域访问资源</h3><p>哪些东⻄属于资源？</p>
<p>js⽂件算吗？js⽂件肯定是算资源的，但是js⽂件是允许被跨域请求的。</p>
<p>css⽂件，jpg,png等。src属性的资源都是可以被跨域请求的。href资源⼤部分都是可以被跨域请求的。</p>
<h5 id="哪些资源算跨域请求的资源？"><a href="#哪些资源算跨域请求的资源？" class="headerlink" title="哪些资源算跨域请求的资源？"></a>哪些资源算跨域请求的资源？</h5><ol>
<li><p>后端接⼝的数据。</p>
</li>
<li><p>其它域的cookie </p>
</li>
<li><p>其它域的缓存</p>
</li>
</ol>
<h5 id="什么是其它的域？怎么样算跨域？"><a href="#什么是其它的域？怎么样算跨域？" class="headerlink" title="什么是其它的域？怎么样算跨域？"></a>什么是其它的域？怎么样算跨域？</h5><p>⻚⾯本身：有协议（http/https）,域名，端⼝</p>
<p>要请求的数据：<a href="http://www.baidu.com/">http://www.baidu.com:80</a></p>
<p>协议，域名，端⼝这三个，有任意⼀个不⼀样就算跨域。</p>
<p>跨域这个⾏为，发⽣在哪⾥？</p>
<p>答案：</p>
<ol>
<li><p>即使跨域了（协议，域名，端⼝号有不⼀样的），请求也可以发出。</p>
</li>
<li><p>服务器端也是可以接收的。</p>
</li>
<li><p>服务器端也是可以正常处理的。</p>
</li>
<li><p>服务器端也是可以正常返回数据。</p>
</li>
<li><p>浏览器也能接收到这些数据。</p>
</li>
<li><p>接收到之后，发现当前⻚⾯的域和请求的域不同，所以判定为跨域。</p>
</li>
<li><p>我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会把结果传递给我们的代码。</p>
</li>
</ol>
<p>虽然跨域了，但是我们依然需要这个数据，怎么办？</p>
<p>解决跨域问题：</p>
<ol>
<li>后端（别⼈家的）配合我们进⾏跨域。</li>
</ol>
<p> pan.baidu.com ——&gt; zhidao.baidu.com</p>
<pre><code>1）JSONP（正常的情况，返回的数据都是JSON格式。JSONP是⼀种特殊的格式。）
2）后端设置Access-Control-Allow-Origin属性以⽀持跨域。（聊天机器⼈课讲，因为需要nodejs）
</code></pre>
<ol start="2">
<li><p>后端不配合我们进⾏跨域。</p>
<p> 3）iframe（只能显示，不能控制）</p>
<p> 4）通过后端代理（⾃⼰的后端）（后⾯聊天机器⼈讲，因为需要nodejs）</p>
</li>
</ol>
<p>readyState ：<br>状态4代表请求完成，已经接收到数据</p>
<p>jsonp跨域，只能使用get方法，如果我们设置的是post方法，jQuery会自动转为get方法</p>
<p>jQuery会先判断是否同源，如果同源，那么设置的是get就是get，设置的是post就是post<br>不是同源的话，就都改为get(跨域)</p>
<p>script标签，虽然可以引用其他域的资源，浏览器不限制，但是，浏览器会将返回的内容当做js代码执行。</p>
<p>jsonp原理：<br>前端：</p>
<ol>
<li><p>判断请求与当前页面的域是是否同源，如果同源则发送Ajax，没有跨域</p>
</li>
<li><p>如果不同源，生成一个script标签</p>
</li>
<li><p>生成一个随机的callback名字</p>
</li>
<li><p>设置script标签的src设置为要请求的接口</p>
</li>
<li><p>将callback作为参数拼接在后面<br> 后端：</p>
</li>
<li><p>后端接收到请求后，开始准备要返回的数据</p>
</li>
<li><p>后端拼接数据，将要返回的数据用callback的值和括号包裹起来。</p>
</li>
<li><p>将内容返回</p>
</li>
<li><p>浏览器接收到内容，会当做js代码来执行</p>
</li>
<li><p>从而执行方法，这样我们就接收到了后端返回给我们的对象。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>定义指令</title>
    <url>/135xyq.github.io/2022/01/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="定义指令"><a href="#定义指令" class="headerlink" title="定义指令"></a>定义指令</h1><h2 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令名称为：mydirec1</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;mydirec1&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 指令配置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令名称为：mydirec2</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;mydirec2&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 指令配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之后，所有的组件均可以使用<code>mydirec1</code>和<code>mydirec2</code>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 某个组件代码 --&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyComp v-mydirec1=&quot;js表达式&quot; /&gt;</span><br><span class="line">    &lt;div v-mydirec2=&quot;js表达式&quot;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;img v-mydirec1=&quot;js表达式&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="局部定义"><a href="#局部定义" class="headerlink" title="局部定义"></a>局部定义</h2><p>局部定义是指在某个组件中定义指令，和局部注册组件类似。</p>
<p>定义的指令仅在该组件中有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 某个组件代码 --&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyComp v-mydirec1=&quot;js表达式&quot; /&gt;</span><br><span class="line">    &lt;div v-mydirec2=&quot;js表达式&quot;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;img v-mydirec1=&quot;js表达式&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 定义指令</span><br><span class="line">  directives: &#123;</span><br><span class="line">    // 指令名称：mydirec1</span><br><span class="line">    mydirec1: &#123;</span><br><span class="line">      // 指令配置</span><br><span class="line">    &#125;,</span><br><span class="line">    // 指令名称：mydirec2</span><br><span class="line">    mydirec2: &#123;</span><br><span class="line">      // 指令配置</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>和全局注册组件一样，为了让指令更加通用，通常我们会把指令的配置提取到其他模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 某个组件代码 --&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyComp v-mydirec1=&quot;js表达式&quot; /&gt;</span><br><span class="line">    &lt;div v-mydirec2=&quot;js表达式&quot;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;img v-mydirec1=&quot;js表达式&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 导入当前组件需要用到的指令配置对象</span><br><span class="line">  import mydirec1 from &quot;@/directives/mydirec1&quot;;</span><br><span class="line">  import mydirec2 from &quot;@/directives/mydirec2&quot;;</span><br><span class="line">	export default &#123;</span><br><span class="line">    // 定义指令</span><br><span class="line">    directives: &#123;</span><br><span class="line">      mydirec1,</span><br><span class="line">      mydirec2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="指令配置对象"><a href="#指令配置对象" class="headerlink" title="指令配置对象"></a>指令配置对象</h1><p>没有配置的指令，就像没有配置的组件一样，毫无意义</p>
<p><code>vue</code>支持在指令中配置一些<strong>钩子函数</strong>，在适当的时机，<code>vue</code>会调用这些钩子函数并传入适当的参数，以便开发者完成自己想做的事情。</p>
<p>常用的钩子函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令配置对象</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 被绑定元素插入父节点时调用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 所在组件的 VNode 更新时调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">查看更多的钩子函数</a></p>
</blockquote>
<p>每个钩子函数在调用时，<code>vue</code>都会向其传递一些参数，其中最重要的是前两个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令配置对象</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// el 是被绑定元素对应的真实DOM</span></span><br><span class="line">    <span class="comment">// binding 是一个对象，描述了指令中提供的信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bingding-对象"><a href="#bingding-对象" class="headerlink" title="bingding 对象"></a>bingding 对象</h2><p><img src="/images/vue2/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6-bingding%E5%AF%B9%E8%B1%A1.jpg" alt="自定义组件"></p>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">查看更多bingding对象的属性</a></p>
</blockquote>
<h1 id="配置简化"><a href="#配置简化" class="headerlink" title="配置简化"></a>配置简化</h1><p>比较多的时候，在配置自定义指令时，我们都会配置两个钩子函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, bingding</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">el, bingding</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在元素绑定和更新时，都能运行到钩子函数</p>
<p>如果这两个钩子函数实现的功能相同，可以直接把指令配置简化为一个单独的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">el, bingding</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 该函数会被同时设置到bind和update中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>利用上述知识，可满足大部分自定义指令的需求</p>
<p>更多的自定义指令用法见<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官网</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程期末知识点总结</title>
    <url>/135xyq.github.io/2021/12/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="网络编程知识点总结"><a href="#网络编程知识点总结" class="headerlink" title="网络编程知识点总结"></a>网络编程知识点总结</h1><h2 id="套接字地址，通用形式"><a href="#套接字地址，通用形式" class="headerlink" title="套接字地址，通用形式"></a>套接字地址，通用形式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span>  <span class="comment">/*保存地址的结构*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sa_len; <span class="comment">/*总长度*/</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*实际更长：地址值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="互联网地址，互联网风格"><a href="#互联网地址，互联网风格" class="headerlink" title="互联网地址，互联网风格"></a>互联网地址，互联网风格</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	<span class="keyword">unit8_t</span> sin_len;  <span class="comment">/*总长度*/</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family; <span class="comment">/*地址类型*/</span></span><br><span class="line">	<span class="keyword">in_port_t</span>  sin_port; <span class="comment">/*协议端口号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>；/*<span class="title">IP</span>地址*/</span></span><br><span class="line"><span class="class">	<span class="title">sin_zero</span>[8]； /*未使用（设置为0）*/</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="两种传输服务的套接字类型"><a href="#两种传输服务的套接字类型" class="headerlink" title="两种传输服务的套接字类型"></a>两种传输服务的套接字类型</h2><p>UDP:不可靠的数据报<br>TCP：可靠的、面向字节流的</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="客户端服务端之间没有连接"><a href="#客户端服务端之间没有连接" class="headerlink" title="客户端服务端之间没有连接"></a>客户端服务端之间没有连接</h4><ul>
<li>发送数据前不握手</li>
<li>发送方式显式的将IP目的地址和端口 # 附加到每个数据包</li>
<li>接受方从收到的数据包中提取发送方的IP地址和端口号</li>
</ul>
<h4 id="UDP传输的数据可能丢失或接受顺序错误"><a href="#UDP传输的数据可能丢失或接受顺序错误" class="headerlink" title="UDP传输的数据可能丢失或接受顺序错误"></a>UDP传输的数据可能丢失或接受顺序错误</h4><h4 id="简单的UDP程序"><a href="#简单的UDP程序" class="headerlink" title="简单的UDP程序"></a>简单的UDP程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINELEN 128</span></span><br><span class="line"><span class="comment">/* 1) initialize sockaddr_in structure */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serverin, <span class="number">0</span>, <span class="keyword">sizeof</span>(serverin));</span><br><span class="line">serverin.sin_family = AF_INET;</span><br><span class="line">serverin.sin_addr.s_addr = inet_addr(SERVER_HOST_ADDR);</span><br><span class="line">serverin.sin_port = htons(SERVER_PORT);</span><br><span class="line"><span class="comment">/* 2) Create a socket */</span></span><br><span class="line"><span class="keyword">if</span> ((clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">err(<span class="number">1</span>, “create socket<span class="string">&quot;);</span></span><br><span class="line"><span class="string">/* 3) formulate a request */</span></span><br><span class="line"><span class="string">char buf[LINELEN+1];</span></span><br><span class="line"><span class="string">int nchars; /* char count read in buf */</span></span><br><span class="line"><span class="string">fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line"><span class="string">buf[LINELEN] = &#x27;\0&#x27;; /* insure null-terminated */</span></span><br><span class="line"><span class="string">nchars = strlen(buf);</span></span><br><span class="line"><span class="string">/* 4) send the request */</span></span><br><span class="line"><span class="string">(void) sendto(clientSocket, buf, nchars, 0, </span></span><br><span class="line"><span class="string">(struct sockaddr *)&amp;serverin, sizeof(serverin));</span></span><br><span class="line"><span class="string">/* 5) receive the reply */</span></span><br><span class="line"><span class="string">if (recv(clientSocket, buf, sizeof(buf), 0) &lt; 0)</span></span><br><span class="line"><span class="string">err(1, &quot;</span>recv socket<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/* 6) handle the response */</span></span><br><span class="line"><span class="string">fputs(buf, stdout);</span></span><br><span class="line"><span class="string">fflush(stdout);</span></span><br></pre></td></tr></table></figure>


<h3 id="创建UDP和TCP通信端点sockfd"><a href="#创建UDP和TCP通信端点sockfd" class="headerlink" title="创建UDP和TCP通信端点sockfd"></a>创建UDP和TCP通信端点sockfd</h3><p><a href="https://www.jianshu.com/p/066d99da7cbd">socket详解</a></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;sockfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;sockfd = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="FD-ZERO、FD-SET、FD-CLR、FD-ISSET"><a href="#FD-ZERO、FD-SET、FD-CLR、FD-ISSET" class="headerlink" title="FD_ZERO、FD_SET、FD_CLR、FD_ISSET"></a><a href="https://www.cnblogs.com/skyofbitbit/p/3654466.html">FD_ZERO、FD_SET、FD_CLR、FD_ISSET</a></h2><ol>
<li>FD_ZERO(fd_set * fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</li>
<li>FD_SET(fd_set * fdset);用于在文件描述符集合中增加一个新的文件描述符。</li>
<li>FD_CLR(fd_set * fdset);用于在文件描述符集合中删除一个文件描述符。</li>
<li>FD_ISSET(int fd,fd_set * fdset);用于测试指定的文件描述符是否在该集合中。</li>
</ol>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a><a href="https://www.cnblogs.com/skyofbitbit/p/3654466.html">select</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readset, fd_set *writeset,fd_set* exceptset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="nfds"><a href="#nfds" class="headerlink" title="nfds"></a>nfds</h3><p>需要检查的文件描述字个数（即检查到fd_set的第几位），数值应该比三组fd_set中所含的最大fd值更大，一般设为三组fd_set中所含的最大 fd值加1（如在readset,writeset,exceptset中所含最大的fd为5，则nfds=6，因为fd是从0开始的）。设这个值是为提高效率，使函数不必检查fd_set的所有1024位。</p>
<h3 id="readset"><a href="#readset" class="headerlink" title="readset"></a>readset</h3><p>用来检查可读性的一组文件描述字。</p>
<h3 id="writeset"><a href="#writeset" class="headerlink" title="writeset"></a>writeset</h3><p>用来检查可写性的一组文件描述字。</p>
<h3 id="exceptset"><a href="#exceptset" class="headerlink" title="exceptset"></a>exceptset</h3><p>用来检查是否有异常条件出现的文件描述字。(注：错误不包括在异常条件之内)</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</p>
<h2 id="ai-family"><a href="#ai-family" class="headerlink" title="ai_family"></a>ai_family</h2><p>ai_family参数指定调用者期待返回的套接口地址结构的类型。它的值包括三种：AF_INET，AF_INET6和AF_UNSPEC。如果指定AF_INET，那么函数九不能返回任何IPV6相关的地址信息；如果仅指定了AF_INET6，则就不能返回任何IPV4地址信息。AF_UNSPEC则意味着函数返回的是适用于指定主机名和服务名且适合任何协议族的地址</p>
<h2 id="ntohs-将一个无符号短整型数从网络字节顺序转换为主机字节顺序。"><a href="#ntohs-将一个无符号短整型数从网络字节顺序转换为主机字节顺序。" class="headerlink" title="ntohs:将一个无符号短整型数从网络字节顺序转换为主机字节顺序。"></a>ntohs:将一个无符号短整型数从网络字节顺序转换为主机字节顺序。</h2><h2 id="htonl-将主机数转换成无符号长整形的网络字节顺序。"><a href="#htonl-将主机数转换成无符号长整形的网络字节顺序。" class="headerlink" title="htonl:将主机数转换成无符号长整形的网络字节顺序。"></a>htonl:将主机数转换成无符号长整形的网络字节顺序。</h2><h2 id="htons-htons是将整型变量从主机字节顺序转变成网络字节顺序，-就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。"><a href="#htons-htons是将整型变量从主机字节顺序转变成网络字节顺序，-就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。" class="headerlink" title="htons:htons是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。"></a>htons:htons是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</h2><h2 id="ntohl-ntohl-指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序，-ntohl-返回一个以主机字节顺序表达的数。"><a href="#ntohl-ntohl-指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序，-ntohl-返回一个以主机字节顺序表达的数。" class="headerlink" title="ntohl:ntohl()指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序， ntohl()返回一个以主机字节顺序表达的数。"></a>ntohl:ntohl()指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序， ntohl()返回一个以主机字节顺序表达的数。</h2><h2 id="FTP使用TCP传输而不是UDP"><a href="#FTP使用TCP传输而不是UDP" class="headerlink" title="FTP使用TCP传输而不是UDP"></a>FTP使用TCP传输而不是UDP</h2><h2 id="如果没有错误产生，则accept-返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID-SOCKET错误，应用程序可通过调用WSAGetLastError-来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。"><a href="#如果没有错误产生，则accept-返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID-SOCKET错误，应用程序可通过调用WSAGetLastError-来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。" class="headerlink" title="如果没有错误产生，则accept()返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID_SOCKET错误，应用程序可通过调用WSAGetLastError()来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。"></a>如果没有错误产生，则accept()返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID_SOCKET错误，应用程序可通过调用WSAGetLastError()来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。</h2><h2 id="调用fork的返回值"><a href="#调用fork的返回值" class="headerlink" title="调用fork的返回值"></a>调用fork的返回值</h2><ol>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果出现错误，fork返回一个负值；</li>
</ol>
<h2 id="listen只能由TCP服务器程序调用"><a href="#listen只能由TCP服务器程序调用" class="headerlink" title="listen只能由TCP服务器程序调用"></a><a href="https://www.cnblogs.com/love-yh/p/7518552.html">listen</a>只能由TCP服务器程序调用</h2><h2 id="recvfrom-中-buflen不能为0"><a href="#recvfrom-中-buflen不能为0" class="headerlink" title="recvfrom 中 buflen不能为0"></a><a href="http://blog.sina.com.cn/s/blog_4171e80d01000asy.html">recvfrom</a> 中 buflen不能为0</h2><h2 id="ssize-t-read-int-fd-void-buf-size-t-count-成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移"><a href="#ssize-t-read-int-fd-void-buf-size-t-count-成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移" class="headerlink" title="ssize_t read(int fd, void * buf, size_t count);成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移"></a>ssize_t read(int fd, void * buf, size_t count);成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移</h2><h2 id="size-t-write-int-fd-const-void-buf-size-t-count-write-会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write-会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。"><a href="#size-t-write-int-fd-const-void-buf-size-t-count-write-会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write-会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。" class="headerlink" title="size_t write (int fd,const void * buf,size_t count);write()会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。"></a>size_t write (int fd,const void * buf,size_t count);write()会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。</h2><h2 id="servname-、nodename、hints"><a href="#servname-、nodename、hints" class="headerlink" title="servname 、nodename、hints"></a><a href="https://www.cnblogs.com/LubinLew/p/POSIX-getaddrinfo.html">servname 、nodename、hints</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> nodename, <span class="comment">/* host 或者IP地址 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> servname, <span class="comment">/* 十进制端口号 或者常用服务名称如&quot;ftp&quot;、&quot;http&quot;等 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct addrinfo *<span class="keyword">restrict</span> hints, <span class="comment">/* 获取信息要求设置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    struct addrinfo **<span class="keyword">restrict</span> res)</span></span>; <span class="comment">/* 获取信息结果 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a><a href="https://blog.csdn.net/networkhunter/article/details/100218945">pthread</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span></span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_attr_setschedpolicy(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> policy);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据与跨域</title>
    <url>/135xyq.github.io/2022/01/01/%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>vue cli: <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<p>axios: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p>
<p>mockjs：<a href="http://mockjs.com/">http://mockjs.com/</a></p>
</blockquote>
<h1 id="远程获取数据的意义"><a href="#远程获取数据的意义" class="headerlink" title="远程获取数据的意义"></a>远程获取数据的意义</h1><img src="http://mdrs.yuanjin.tech/img/20201204145137.png" alt="image-20201204145137500" style="zoom:40%;" />

<h1 id="开发环境有跨域问题"><a href="#开发环境有跨域问题" class="headerlink" title="开发环境有跨域问题"></a>开发环境有跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;后端测试服务器: ajax 跨域：http://test-data:3000/api/news</span><br><span class="line">后端测试服务器-&gt;&gt;浏览器: JSON数据</span><br><span class="line">rect rgb(224,74,74)</span><br><span class="line">Note right of 浏览器: 浏览器阻止数据移交</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="生产环境没有跨域问题"><a href="#生产环境没有跨域问题" class="headerlink" title="生产环境没有跨域问题"></a>生产环境没有跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;服务器: http://www.my-site.com/</span><br><span class="line">服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;服务器: ajax：http://www.my-site.com/api/news</span><br><span class="line">服务器-&gt;&gt;浏览器: JSON数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;静态资源服务器: http://www.my-site.com/</span><br><span class="line">静态资源服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;数据服务器: ajax 跨域：http://api.my-site.com/api/news</span><br><span class="line">数据服务器-&gt;&gt;浏览器: [允许www.my-site.com]JSON数据</span><br></pre></td></tr></table></figure>

<h1 id="解决开发环境的跨域问题"><a href="#解决开发环境的跨域问题" class="headerlink" title="解决开发环境的跨域问题"></a>解决开发环境的跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: ajax：http://localhost:8080/api/news</span><br><span class="line">前端开发服务器-&gt;&gt;后端测试服务器: 代理请求：http://test-data:3000/api/news</span><br><span class="line">后端测试服务器-&gt;&gt;前端开发服务器: JSON数据</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: JSON数据</span><br></pre></td></tr></table></figure>

<h1 id="为什么要Mock数据"><a href="#为什么要Mock数据" class="headerlink" title="为什么要Mock数据"></a>为什么要Mock数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: ajax：http://localhost:8080/api/news</span><br><span class="line">前端开发服务器-&gt;&gt;后端测试服务器: 代理请求：http://test-data:3000/api/news</span><br><span class="line">后端测试服务器-&gt;&gt;前端开发服务器: 404 （后端正在开发中）</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 404</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 浏览器</span><br><span class="line">participant MockJS</span><br><span class="line">participant 前端开发服务器</span><br><span class="line">activate MockJS</span><br><span class="line">Note left of MockJS: 定义ajax拦截规则</span><br><span class="line">deactivate MockJS</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;MockJS: ajax：http://localhost:8080/api/news</span><br><span class="line">MockJS-&gt;&gt;浏览器: 模拟的JSON数据</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中虚拟节点</title>
    <url>/135xyq.github.io/2022/01/01/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>面试题：请你阐述一下对vue虚拟dom的理解</p>
<ol>
<li><p>什么是虚拟dom？</p>
<p>虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构</p>
<p>在vue中，每个组件都有一个<code>render</code>函数，每个<code>render</code>函数都会返回一个虚拟dom树，这也就意味着每个组件都对应一棵虚拟DOM树</p>
</li>
</ol>
<p><img src="/images/vue2/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9-%E8%99%9A%E6%8B%9FDOM.jpg" alt="虚拟dom"></p>
<ol start="2">
<li><p>为什么需要虚拟dom？</p>
<p>在<code>vue</code>中，渲染视图会调用<code>render</code>函数，这种渲染不仅发生在组件创建时，同时发生在视图依赖的数据更新时。如果在渲染时，直接使用真实<code>DOM</code>，由于真实<code>DOM</code>的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。</p>
<p>因此，<code>vue</code>在渲染时，使用虚拟dom来替代真实dom，主要为解决渲染效率的问题。</p>
</li>
<li><p>虚拟dom是如何转换为真实dom的？</p>
<p>在一个组件实例首次被渲染时，它先生成虚拟dom树，然后根据虚拟dom树创建真实dom，并把真实dom挂载到页面中合适的位置，此时，每个虚拟dom便会对应一个真实的dom。</p>
<p>如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一个新的虚拟dom树，用新树和旧树对比，通过对比，vue会找到最小更新量，然后更新必要的虚拟dom节点，最后，这些更新过的虚拟节点，会去修改它们对应的真实dom</p>
<p>这样一来，就保证了对真实dom达到最小的改动。</p>
</li>
</ol>
<p><img src="/images/vue2/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9-%E6%9B%B4%E6%96%B0.jpg"></p>
<ol start="4">
<li><p>模板和虚拟dom的关系</p>
<p>vue框架中有一个<code>compile</code>模块，它主要负责将模板转换为<code>render</code>函数，而<code>render</code>函数调用后将得到虚拟dom。</p>
<p>编译的过程分两步：</p>
<ol>
<li>将模板字符串转换成为<code>AST</code></li>
<li>将<code>AST</code>转换为<code>render</code>函数</li>
</ol>
<p>如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。</p>
<p>如果是在<code>vue-cli</code>的默认配置下，编译发生在打包时，这称之为模板预编译。</p>
<p>编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，<code>vue-cli</code>在打包时会排除掉<code>vue</code>中的<code>compile</code>模块，以减少打包体积</p>
<p>模板的存在，仅仅是为了让开发人员更加方便的书写界面代码</p>
<p><strong>vue最终运行的时候，最终需要的是render函数，而不是模板，因此，模板中的各种语法，在虚拟dom中都是不存在的，它们都会变成虚拟dom的配置</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中计算属性</title>
    <url>/135xyq.github.io/2022/01/01/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>面试题：计算属性和方法有什么区别？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算属性本质上是包含getter和setter的方法</span><br><span class="line">当获取计算属性时，实际上是在调用计算属性的getter方法。vue会收集计算属性的依赖，并缓存计算属性的返回结果。只有当依赖变化后才会重新进行计算。</span><br><span class="line">方法没有缓存，每次调用方法都会导致重新执行。</span><br><span class="line">计算属性的getter和setter参数固定，getter没有参数，setter只有一个参数。而方法的参数不限。</span><br><span class="line">由于有以上的这些区别，因此计算属性通常是根据已有数据得到其他数据，并在得到数据的过程中不建议使用异步、当前时间、随机数等副作用操作。</span><br><span class="line">实际上，他们最重要的区别是含义上的区别。计算属性含义上也是一个数据，可以读取也可以赋值；方法含义上是一个操作，用于处理一些事情。</span><br></pre></td></tr></table></figure>



<p>完整的计算属性书写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="attr">propName</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// getter</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// setter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只包含getter的计算属性简写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">propName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>父组件为影响子组件的最外层结构</p>
<p><img src="/images/vue2/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%AF%B9%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BD%B1%E5%93%8D.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的解构 符号 异步处理</title>
    <url>/135xyq.github.io/2021/12/31/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="解构-符号-异步处理"><a href="#解构-符号-异步处理" class="headerlink" title="解构 符号 异步处理"></a>解构 符号 异步处理</h1><hr>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>将数组或对象的某一属性提取到变量中(可以互相嵌套使用)<br>可以给结构出来的变量赋默认值（变量名 = 默认值）</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><h4 id="解构剩余参数："><a href="#解构剩余参数：" class="headerlink" title="解构剩余参数："></a>解构剩余参数：</h4><p>将剩余的所有参数都敢放到一个数组或对象中（使用展开运算符）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> [nn1, ...arr1] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(nn1, arr1)</span><br><span class="line"><span class="comment">// 将第一个结构出来，其他放到arr1 数组中</span></span><br></pre></td></tr></table></figure>
<h4 id="同名解构（变量名要和属性名一致）"><a href="#同名解构（变量名要和属性名一致）" class="headerlink" title="同名解构（变量名要和属性名一致）"></a>同名解构（变量名要和属性名一致）</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><ul>
<li>先定义再解构变量：（{变量名，…..} = 对象名）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xyq&#x27;</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&#x27;河南&#x27;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;驻马店&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name, age;</span><br><span class="line"></span><br><span class="line">(&#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">&#125; = obj);</span><br><span class="line"><span class="built_in">console</span>.log(name, age)</span><br></pre></td></tr></table></figure></li>
<li>直接解构 ： let / const / var  {变量名} = 对象名<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xyq&#x27;</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&#x27;河南&#x27;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;驻马店&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    sex,</span><br><span class="line">    age,</span><br><span class="line">    address</span><br><span class="line">&#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(t, sex, age, address)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="异名解构"><a href="#异名解构" class="headerlink" title="异名解构"></a>异名解构</h4><p>{属性名：变量名}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将name解构成变量t</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">age</span>: t</span><br><span class="line">&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, t)</span><br></pre></td></tr></table></figure>

<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>{属性名：{属性名}}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        city</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = obj;</span><br><span class="line"><span class="comment">// 此时address为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(city)</span><br></pre></td></tr></table></figure>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><h4 id="模拟对象"><a href="#模拟对象" class="headerlink" title="模拟对象"></a>模拟对象</h4><p>数组可以看成特殊的对象，可以参考对象的异名解构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    <span class="number">0</span>: n1,</span><br><span class="line">    <span class="number">1</span>: n2,</span><br><span class="line">&#125; = arr;</span><br><span class="line"><span class="built_in">console</span>.log(n1, n2);</span><br></pre></td></tr></table></figure>

<h4 id="数组自己的结构"><a href="#数组自己的结构" class="headerlink" title="数组自己的结构"></a>数组自己的结构</h4><p>[变量名，，，，，变量名],按顺序结构数组，不想结构的对象用空格空出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> [n1, n2, , n4, ] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(n1, n2, n4)</span><br></pre></td></tr></table></figure>

<h3 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用于函数参数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    method = <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    url = <span class="string">&quot;/&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax()</span><br></pre></td></tr></table></figure>

<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>对象的属性名一定是一个字符串</p>
<h3 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h3><p>符号是ES6新增的一个数据类型，它通过使用函数 <code>Symbol(符号描述)</code> 来创建</p>
<p>符号设计的初衷，是为了给对象设置私有属性</p>
<p>私有属性：只能在对象内部使用，外面无法使用</p>
<p>符号具有以下特点：</p>
<ul>
<li>没有字面量</li>
<li>使用 typeof 得到的类型是 symbol</li>
<li><strong>每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同</strong></li>
<li>符号可以作为对象的属性名存在，这种属性称之为符号属性<ul>
<li>开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问</li>
<li>符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性</li>
<li>Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性</li>
<li>ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号</li>
</ul>
</li>
<li>符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换</li>
</ul>
<h3 id="共享符号"><a href="#共享符号" class="headerlink" title="共享符号"></a>共享符号</h3><p>根据某个符号名称（符号描述）能够得到同一个符号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;符号名/符号描述&quot;</span>)  <span class="comment">//获取共享符号</span></span><br></pre></td></tr></table></figure>

<h3 id="知名符号"><a href="#知名符号" class="headerlink" title="知名符号"></a>知名符号</h3><p>知名符号是一些具有特殊含义的共享符号，通过 Symbol 的静态属性得到</p>
<p>ES6 延续了 ES5 的思想：减少魔法，暴露内部实现！</p>
<p>因此，ES6 用知名符号暴露了某些场景的内部实现</p>
<ol>
<li>Symbol.hasInstance</li>
</ol>
<p>该符号用于定义构造函数的静态成员，它将影响 instanceof 的判定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line">A[<span class="built_in">Symbol</span>.hasInstance](obj) <span class="comment">// Function.prototype[Symbol.hasInstance]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>[扩展] Symbol.isConcatSpreadable</li>
</ol>
<p>该知名符号会影响数组的 concat 方法</p>
<ol start="3">
<li>[扩展] Symbol.toPrimitive</li>
</ol>
<p>该知名符号会影响类型转换的结果</p>
<ol start="4">
<li>[扩展] Symbol.toStringTag</li>
</ol>
<p>该知名符号会影响 Object.prototype.toString 的返回值</p>
<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JS运行的环境称之为宿主环境。</p>
<h4 id="执行栈："><a href="#执行栈：" class="headerlink" title="执行栈："></a>执行栈：</h4><p>  call stack，一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。</p>
<p>JS引擎永远执行的是执行栈的最顶部。</p>
<h4 id="异步函数："><a href="#异步函数：" class="headerlink" title="异步函数："></a>异步函数：</h4><p>某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。</p>
<h4 id="浏览器宿主环境中包含5个线程："><a href="#浏览器宿主环境中包含5个线程：" class="headerlink" title="浏览器宿主环境中包含5个线程："></a>浏览器宿主环境中包含5个线程：</h4><ol>
<li>JS引擎：负责执行执行栈的最顶部代码</li>
<li>GUI线程：负责渲染页面 </li>
<li>事件监听线程：负责监听各种事件</li>
<li>计时线程：负责计时</li>
<li>网络线程：负责网络通信</li>
</ol>
<p>当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当JS引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。</p>
<p>JS引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。</p>
<p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p>
<ul>
<li>宏任务（队列）：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列</li>
<li>微任务（队列）：MutationObserver，Promise产生的回调进入微队列</li>
</ul>
<h4 id="MutationObserver用于监听某个DOM对象的变化"><a href="#MutationObserver用于监听某个DOM对象的变化" class="headerlink" title="MutationObserver用于监听某个DOM对象的变化"></a>MutationObserver用于监听某个DOM对象的变化</h4><p>当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。</p>
<p>###异步处理的通用模型</p>
<p>ES官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。</p>
<p>值得注意的是，为了兼容旧系统，ES6 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 API，使用该API，会让异步处理更加的简洁优雅。</p>
<p>理解该 API，最重要的，是理解它的异步模型</p>
<ol>
<li>ES6 将某一件可能发生异步操作的事情，分为两个阶段：<strong>unsettled</strong> 和 <strong>settled</strong></li>
</ol>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg"></p>
<ul>
<li>unsettled： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</li>
<li>settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</li>
</ul>
<p>事情总是从 未决阶段 逐步发展到 已决阶段的。并且，未决阶段拥有控制何时通向已决阶段的能力。</p>
<ol start="2">
<li>ES6将事情划分为三种状态： pending、resolved、rejected</li>
</ol>
<ul>
<li>pending: 挂起，处于未决阶段，则表示这件事情还在挂起（最终的结果还没出来）</li>
<li>resolved：已处理，已决阶段的一种状态，表示整件事情已经出现结果，并是一个可以按照正常逻辑进行下去的结果</li>
<li>rejected：已拒绝，已决阶段的一种状态，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</li>
</ul>
<p>既然未决阶段有权力决定事情的走向，因此，未决阶段可以决定事情最终的状态！</p>
<p>我们将 把事情变为resolved状态的过程叫做：<strong>resolve</strong>，推向该状态时，可能会传递一些数据</p>
<p>我们将 把事情变为rejected状态的过程叫做：<strong>reject</strong>，推向该状态时，同样可能会传递一些数据，通常为错误信息</p>
<p><strong>始终记住，无论是阶段，还是状态，是不可逆的！</strong></p>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg"></p>
<ol start="3">
<li>当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。</li>
</ol>
<ul>
<li>resolved状态：这是一个正常的已决状态，后续处理表示为 thenable</li>
<li>rejected状态：这是一个非正常的已决状态，后续处理表示为 catchable</li>
</ul>
<p>后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</p>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86%E7%8A%B6%E6%80%81.jpg"></p>
<ol start="4">
<li>整件事称之为Promise</li>
</ol>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-Promise.jpg"></p>
<h3 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h3><h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 未决阶段的处理</span></span><br><span class="line">    <span class="comment">// 通过调用resolve函数将Promise推向已决阶段的resolved状态</span></span><br><span class="line">    <span class="comment">// 通过调用reject函数将Promise推向已决阶段的rejected状态</span></span><br><span class="line">    <span class="comment">// resolve和reject均可以传递最多一个参数，表示推向状态的数据</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pro.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span></span><br><span class="line">    <span class="comment">//data为状态数据</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span></span><br><span class="line">    <span class="comment">//err为状态数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol>
<li>未决阶段的处理函数是同步的，会立即执行</li>
<li>thenable和catchable函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列</li>
<li>pro.then可以只添加thenable函数，pro.catch可以单独添加catchable函数</li>
<li>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable捕获</li>
<li>一旦状态推向了已决阶段，无法再对状态做任何更改</li>
<li><strong>Promise并没有消除回调，只是让回调变得可控</strong></li>
</ol>
<h3 id="Promise的串联"><a href="#Promise的串联" class="headerlink" title="Promise的串联"></a>Promise的串联</h3><p>当后续的Promise需要用到之前的Promise的处理结果时，需要Promise的串联</p>
<h4 id="Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则："><a href="#Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则：" class="headerlink" title="Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则："></a>Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则：</h4><ol>
<li>如果当前的Promise是未决的，得到的新的Promise是挂起状态</li>
<li>如果当前的Promise是已决的，会运行相应的后续处理函数，并将后续处理函数的结果（返回值）作为resolved状态数据，应用到新的Promise中；如果后续处理函数发生错误，则把返回值作为rejected状态数据，应用到新的Promise中。</li>
</ol>
<p><strong>后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态</strong></p>
<p>如果前面的Promise的后续处理，返回的是一个Promise，则返回的新的Promise状态和后续处理返回的Promise状态保持一致。</p>
<h3 id="Promise的其他api"><a href="#Promise的其他api" class="headerlink" title="Promise的其他api"></a>Promise的其他api</h3><h4 id="原型成员-实例成员"><a href="#原型成员-实例成员" class="headerlink" title="原型成员 (实例成员)"></a>原型成员 (实例成员)</h4><ul>
<li>then：注册一个后续处理函数，当Promise为resolved状态时运行该函数</li>
<li>catch：注册一个后续处理函数，当Promise为rejected状态时运行该函数</li>
<li>finally：[ES2018]注册一个后续处理函数（无参），当Promise为已决时运行该函数</li>
</ul>
<h4 id="构造函数成员-（静态成员）"><a href="#构造函数成员-（静态成员）" class="headerlink" title="构造函数成员 （静态成员）"></a>构造函数成员 （静态成员）</h4><ul>
<li><p>resolve(数据)：该方法返回一个resolved状态的Promise，传递的数据作为状态数据</p>
<ul>
<li>特殊情况：如果传递的数据是Promise，则直接返回传递的Promise对象</li>
</ul>
</li>
<li><p>reject(数据)：该方法返回一个rejected状态的Promise，传递的数据作为状态数据</p>
</li>
<li><p>all(iterable)：这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。</p>
</li>
<li><p>race(iterable)：当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象</p>
</li>
</ul>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>async 和 await 是 ES2016 新增两个关键字，它们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>目的是简化在函数的返回值中对Promise的创建</p>
<p>async 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><strong>await关键字必须出现在async函数中！！！！</strong></p>
<p>await用在某个表达式之前，如果表达式是一个Promise，则得到的是thenable中的状态数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> test1();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        test1().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = data;</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果await的表达式不是Promise，则会将其使用Promise.resolve包装后按照规则运行</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的路由</title>
    <url>/135xyq.github.io/2022/01/01/%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p>vue-router官网：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p>
<img src="http://mdrs.yuanjin.tech/img/20201202170037.png" alt="image-20201202170037391" style="zoom:50%;" />

<ol>
<li><p><strong>如何根据地址中的路径选择不同的组件？</strong></p>
</li>
<li><p><strong>把选择的组件放到哪个位置？</strong></p>
</li>
<li><p><strong>如何无刷新的切换组件？</strong></p>
</li>
</ol>
<h1 id="路由插件"><a href="#路由插件" class="headerlink" title="路由插件"></a>路由插件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure>

<p>路由插件的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter); <span class="comment">// Vue.use(插件)  在Vue中使用插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 路由配置</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [ <span class="comment">// 路由规则</span></span><br><span class="line">    <span class="comment">// 当匹配到路径 /foo 时，渲染 Foo 组件</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">    <span class="comment">// 当匹配到路径 /bar 时，渲染 Bar 组件</span></span><br><span class="line">  	&#123; <span class="attr">path</span>: <span class="string">&#x27;/bar&#x27;</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公共区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面区域 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- vue-router 匹配到的组件会渲染到这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h1><p>路由模式决定了：</p>
<ol>
<li>路由从哪里获取访问路径</li>
<li>路由如何改变访问路径</li>
</ol>
<p><code>vue-router</code>提供了三种路由模式：</p>
<ol>
<li><p>hash：默认值。路由从浏览器地址栏中的hash部分获取路径，改变路径也是改变的hash部分。该模式兼容性最好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/#/blog  --&gt;  /blog</span><br><span class="line">http://localhost:8081/about#/blog  --&gt; /blog</span><br></pre></td></tr></table></figure></li>
<li><p>history：路由从浏览器地址栏的<code>location.pathname</code>中获取路径，改变路径使用的H5的<code>history api</code>。该模式可以让地址栏最友好，但是需要浏览器支持<code>history api</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/#/blog  --&gt;  /</span><br><span class="line">http://localhost:8081/about#/blog  --&gt; /about</span><br><span class="line">http://localhost:8081/blog  --&gt; /blog</span><br></pre></td></tr></table></figure></li>
<li><p>abstract：路由从内存中获取路径，改变路径也只是改动内存中的值。这种模式通常应用到非浏览器环境中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">内存： /			--&gt;   /</span><br><span class="line">内存： /about	--&gt; /about</span><br><span class="line">内存： /blog	  --&gt; /blog</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p><code>vue-router</code>提供了全局的组件<code>RouterLink</code>，它的渲染结果是一个<code>a</code>元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mode:hash 生成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/blog&quot;</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mode:history 生成 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 为了避免刷新页面，vue-router实际上为它添加了点击事件，并阻止了默认行为，在事件内部使用hitory api更改路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="http://mdrs.yuanjin.tech/img/20201203150453.png" alt="image-20201203150453332" />

<img src="http://mdrs.yuanjin.tech/img/20201203150918.png" alt="image-20201203150918219" style="zoom:50%;" />

<h2 id="激活状态"><a href="#激活状态" class="headerlink" title="激活状态"></a>激活状态</h2><p>默认情况下，<code>vue-router</code>会用 <strong>当前路径</strong> 匹配 <strong>导航路径</strong> ：</p>
<ul>
<li>如果当前路径是以导航路径开头，则算作匹配，会为导航的a元素添加类名<code>router-link-active</code></li>
<li>如果当前路径完全等于导航路径，则算作精确匹配，会为导航的a元素添加类名<code>router-link-exact-active</code></li>
</ul>
<p>例如，当前访问的路径是<code>/blog</code>，则：</p>
<table>
<thead>
<tr>
<th>导航路径</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>router-link-active</td>
</tr>
<tr>
<td>/blog</td>
<td>router-link-active   router-link-exact-active</td>
</tr>
<tr>
<td>/about</td>
<td>无</td>
</tr>
<tr>
<td>/message</td>
<td>无</td>
</tr>
</tbody></table>
<p>可以为组件<code>RouterLink</code>添加bool属性<code>exact</code>，将匹配规则改为：必须要精确匹配才能添加匹配类名<code>router-link-active</code></p>
<p>例如，当前访问的路径是<code>/blog</code>，则：</p>
<table>
<thead>
<tr>
<th>导航路径</th>
<th>exact</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/blog</td>
<td>false</td>
<td>router-link-active   router-link-exact-active</td>
</tr>
<tr>
<td>/about</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/message</td>
<td>true</td>
<td>无</td>
</tr>
</tbody></table>
<p>例如，当前访问的路径是<code>/blog/detail/123</code>，则：</p>
<table>
<thead>
<tr>
<th>导航路径</th>
<th>exact</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/blog</td>
<td>false</td>
<td>router-link-active</td>
</tr>
<tr>
<td>/about</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/message</td>
<td>true</td>
<td>无</td>
</tr>
</tbody></table>
<p>另外，可以通过<code>active-class</code>属性更改匹配的类名，通过<code>exact-active-class</code>更改精确匹配的类名</p>
<h1 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h1><p>使用命名路由可以解除系统与路径之间的耦合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [ <span class="comment">// 路由规则</span></span><br><span class="line">    <span class="comment">// 当匹配到路径 /foo 时，渲染 Foo 组件</span></span><br><span class="line">    &#123; <span class="attr">name</span>:<span class="string">&quot;foo&quot;</span>, <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">    <span class="comment">// 当匹配到路径 /bar 时，渲染 Bar 组件</span></span><br><span class="line">  	&#123; <span class="attr">name</span>:<span class="string">&quot;bar&quot;</span>, <span class="attr">path</span>: <span class="string">&#x27;/bar&#x27;</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 向to属性传递路由信息对象 RouterLink会根据你传递的信息以及路由配置生成对应的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name:&#x27;foo&#x27; &#125;&quot;</span>&gt;</span>go to foo<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>运动 正则</title>
    <url>/135xyq.github.io/2021/12/31/%E8%BF%90%E5%8A%A8_%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<h1 id="运动-正则"><a href="#运动-正则" class="headerlink" title="运动 正则"></a>运动 正则</h1><hr>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>offsetLeft：当前位置距离左边界距离<br>多物体运动：要给每个物体单独设置自己的定时器<br>回调机制：执行完主题函数再</p>
<p>JSON是一种传输数据的格式（以对象为样板，本质上就是对象（json的属性名要变成字符串样式），但用途有区别，对象就是本地用的，json是用来传输的）</p>
<h4 id="JSON-stringify-json-—-gt-string"><a href="#JSON-stringify-json-—-gt-string" class="headerlink" title="JSON.stringify(); json — &gt; string"></a>JSON.stringify(); json — &gt; string</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line">   返回结果为</span><br><span class="line"><span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;xyq\&quot;,\&quot;age\&quot;:20&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON-parse-string-—-gt-json"><a href="#JSON-parse-string-—-gt-json" class="headerlink" title="JSON.parse();  string — &gt; json"></a>JSON.parse();  string — &gt; json</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(obj) </span><br><span class="line">        <span class="built_in">JSON</span>.parse(json)</span><br><span class="line">返回值为：</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>dom树深度优先原则</p>
<h2 id="异步加载JS"><a href="#异步加载JS" class="headerlink" title="异步加载JS"></a>异步加载JS</h2><h3 id="js加载的缺点："><a href="#js加载的缺点：" class="headerlink" title="js加载的缺点："></a>js加载的缺点：</h3><ul>
<li>加载工具方法没必要阻塞文档，过得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。</li>
<li>有些工具方法需要按需加载，用到再加载，不用不加载。</li>
</ul>
<h3 id="javascript-异步加载-的-三种方案"><a href="#javascript-异步加载-的-三种方案" class="headerlink" title="javascript 异步加载 的 三种方案"></a>javascript 异步加载 的 三种方案</h3><ol>
<li>defer 异步加载，但要等到dom文档全部解析完才会被执行。只有IE能用。可以在script内写语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;tools.js&quot;</span> defer=<span class="string">&quot;defer&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>async 异步加载，加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。</li>
</ol>
<p>1和2 执行时不阻塞页面<br>3. 创建script，插入到DOM中，加载完毕后callBack。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">        script.src = <span class="string">&quot;demo.js&quot;</span>;</span><br><span class="line">        <span class="built_in">document</span>.head.appendChild(script);<span class="comment">//执行这一行时js才开始执行</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">        script.src = <span class="string">&quot;demo.js&quot;</span>;</span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//会等js文件下载完之后在执行</span></span><br><span class="line">            语句; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="js加载时间"><a href="#js加载时间" class="headerlink" title="js加载时间"></a>js加载时间</h3><ol>
<li><p>创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。</p>
</li>
<li><p>遇到link外部css，创建线程加载，并继续解析文档。</p>
</li>
<li><p>遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</p>
</li>
<li><p>遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。<br>对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）</p>
</li>
<li><p>遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</p>
</li>
<li><p>当文档解析完成，document.readyState = ‘interactive’。</p>
</li>
<li><p>文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;</p>
</li>
<li><p>document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</p>
</li>
<li><p>当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。</p>
</li>
<li><p>从此，以异步响应方式处理用户输入、网络事件等。</p>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp">正则表达式</a></h2><p>多行字符串（更清晰，通过 \ 将一行的结束符转义）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> test = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">        &lt;div&gt;&lt;/div&gt;\</span></span><br><span class="line"><span class="string">        &lt;span&gt;&lt;/span&gt;\</span></span><br><span class="line"><span class="string">        &quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式两种创建方式："><a href="#正则表达式两种创建方式：" class="headerlink" title="正则表达式两种创建方式："></a>正则表达式两种创建方式：</h3><ol>
<li><p>直接量(var 变量名  = / 字符串 /属性（可不写）  )<br>var reg = /abc/;</p>
</li>
<li><p>new RegExp(var 变量名 = new RegExp(“规则” ，”属性（可不写）”);)</p>
<p> <code>var reg = new RegExp(&quot;abc&quot;);</code></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ ]:表达式（里面填符合要求的范围）</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/[ab][cd][d]/g</span>;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        str.match(reg)</span><br><span class="line">        返回值：</span><br><span class="line">    	[<span class="string">&quot;bcd&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^放在表达式里表示 非（除了）</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> reg = <span class="regexp">/[^a]/</span>;<span class="comment">//匹配第一位不是a的字符串</span></span><br><span class="line">         <span class="keyword">var</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">         str.match(reg)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">（条件 | 条件 |条件）：可表示范围</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/(abc|bcd)/g</span>;</span><br><span class="line">        可匹配是abc 或 bcd 的字符串</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>\n : 与第n子表达式个完全一样的匹配条件（n必须为具体的数字）</p>
<p>var reg = /(\w)\1\1\1/g;   //匹配4个完全一样的字符串（例如 “aaaa”）</p>
<p>var reg = /(\w)\1(\w)\2/g; //可匹配AABB样式的字符串  </p>
<h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4><p>方括号用于查找某个范围内的字符：<br>| 表达式 | 描述  |<br>| :—  | :————— |<br>| [abc]  | 查找方括号之间的任何字符。|<br>| [^abc] | 查找任何不在方括号之间的字符。|<br>| [0-9] | 查找任何从 0 至 9 的数字。|<br>| [a-z] | 查找任何从小写 a 到小写 z 的字符。|<br>| [A-Z] | 查找任何从大写 A 到大写 Z 的字符。|<br>| [A-z] | 查找任何从大写 A 到小写 z 的字符。|<br>| [adgk] | 查找给定集合内的任何字符。|<br>| [^adgk] | 查找给定集合外的任何字符。|<br>| (red|blue|green) | 查找任何指定的选项。|<br>|</p>
<h4 id="元字符（Metacharacter）"><a href="#元字符（Metacharacter）" class="headerlink" title="元字符（Metacharacter）"></a>元字符（Metacharacter）</h4><p>是拥有特殊含义的字符：<br>| 元字符 | 描述 |<br>| :—- | :—- |<br>|.查找单个字符，除了换行和行结束符.<br>| \w |     [ 0 - 9A-z_]查找单词字符。<br>| \W | 查找非单词字符。<br>| \d |    [ 0 - 9]查找数字。<br>| \D | 查找非数字字符。<br>| \s | 查找空白字符。<br>| \S | 查找非空白字符。<br>| \b | 匹配单词边界。<br>| \B | 匹配非单词边界。<br>| \0 | 查找 NUL 字符。<br>| \n | 查找换行符。<br>| \f | 查找换页符。<br>| \r | 查找回车符。<br>| \t | 查找制表符。<br>| \v | 查找垂直制表符。<br>| \x | xx查找以八进制数 xxx 规定的字符。<br>| \x | dd查找以十六进制数 dd 规定的字符。<br>| \u | xxxx查找以十六进制数 xxxx 规定的 Unicode 字符。<br>|</p>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><table>
<thead>
<tr>
<th align="left">量词</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n+</td>
<td align="left">匹配任何包含至少一个 n 的字符串。</td>
</tr>
<tr>
<td align="left">n*</td>
<td align="left">匹配任何包含零个或多个 n 的字符串。</td>
</tr>
<tr>
<td align="left">n?</td>
<td align="left">匹配任何包含零个或一个 n 的字符串。</td>
</tr>
<tr>
<td align="left">n{X}</td>
<td align="left">匹配包含 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td align="left">n{X,Y}</td>
<td align="left">匹配包含 X 至 Y 个 n 的序列的字符串。</td>
</tr>
<tr>
<td align="left">n{X,}</td>
<td align="left">匹配包含至少 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td align="left">n$</td>
<td align="left">匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td align="left">^n</td>
<td align="left">匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td align="left">?=n</td>
<td align="left">匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td align="left">?!n</td>
<td align="left">匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td>globalRegExp</td>
<td>对象是否具有标志 g</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>ignoreCaseRegExp</td>
<td>对象是否具有标志 i</td>
<td>。1</td>
<td>4</td>
</tr>
<tr>
<td>lastIndex</td>
<td>一个整数，标示开始下一次匹配的字符位</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>multilineRegExp</td>
<td>对象是否具有标志 m</td>
<td>。1</td>
<td>4</td>
</tr>
<tr>
<td>source</td>
<td>正则表达式的源文本。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>编译正则表达式。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>exec</td>
<td>检索字符串中指定的值。返回找到的值，并确定其位置。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>test</td>
<td>检索字符串中指定的值。返回 true 或 false。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td>search</td>
<td>检索与正则表达式相匹配的值。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>match</td>
<td>找到一个或多个正则表达式的匹配。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>replace</td>
<td>替换与正则表达式匹配的子串。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>split</td>
<td>把字符串分割为字符串数组。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">打印结果为ba</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(str.replace(reg, <span class="string">&quot;b&quot;</span>));    </span><br><span class="line">打印结果为bb                      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/(\w)\1(\w)\2/g</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(str.replace(reg, <span class="string">&quot;$2$2$1$1&quot;</span>)); <span class="comment">//可以通过 $n 获取第n 个子表达式的匹配条件</span></span><br><span class="line">打印结果为bbaa</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;the-first-name&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">$, $<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">        &#125;))</span><br><span class="line">打印结果为theFirstName</span><br></pre></td></tr></table></figure>


<p>正则表达式默认为贪婪匹配（总是往最大的方向去匹配）<br>取消贪婪匹配（匹配最短）（在每个量词后面加上一个 ？）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/a&#123;3,5&#125;?/g</span>;</span><br><span class="line">        <span class="keyword">var</span> reg1 = <span class="regexp">/a&#123;3,5&#125;/g</span>;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&quot;aaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line">        <span class="built_in">console</span>.log(str.match(reg1));</span><br><span class="line"></span><br><span class="line">打印结果为：</span><br><span class="line">[<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aaa&quot;</span>]</span><br><span class="line">[<span class="string">&quot;aaaaa&quot;</span>, <span class="string">&quot;aaaaa&quot;</span>, <span class="string">&quot;aaaaa&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(?!\d+$)(?![A-z]+$)[0-9A-z]&#123;8,16&#125;$/</span>;</span><br><span class="line">匹配密码<span class="number">8</span> - <span class="number">16</span>位不能只有数字或字母</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3选择器</title>
    <url>/135xyq.github.io/2021/12/31/%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="选择器："><a href="#选择器：" class="headerlink" title="选择器："></a>选择器：</h1><hr>
<h2 id="关系选择器："><a href="#关系选择器：" class="headerlink" title="关系选择器："></a>关系选择器：</h2><ul>
<li><p> + ：下一个满足条件的兄弟元素节点。<br><code>div + P&#123;&#125;  //选出div的兄弟节点并且是p标签</code></p>
</li>
<li><p>~ ： 后面的满足条件的所有兄弟节点<br><code>div ~ p&#123;&#125;  //选出div兄弟节点中所有的p节点</code></p>
</li>
</ul>
<h2 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h2><ul>
<li>[attribute~=”value”] 选择器选取属性值包含指定词的元素。</li>
<li>[attribute|=”value”] 选择器用于选取指定属性以指定值开头的元素。</li>
<li>[attribute^=”value”] 选择器用于选取指定属性以指定值开头的元素。</li>
<li>[attribute$=”value”] 选择器用于选取指定属性以指定值结尾的元素。</li>
<li>[attribute*=”value”] 选择器选取属性值包含指定词的元素。</li>
<li>::placeholer  选择带placeholeder元素</li>
<li>::selection   设置页面字体选中后的状态</li>
</ul>
<h2 id="伪类选择器："><a href="#伪类选择器：" class="headerlink" title="伪类选择器："></a>伪类选择器：</h2><p>当前元素的状态（全部是当前元素的限制条件,想操作谁就选谁）</p>
<ul>
<li>:not  不是什么什么</li>
<li>:root 根目录选择器（HTML下是html标签）</li>
<li>:target 选择被锚点标记之后的元素</li>
</ul>
<h3 id="要考虑其他元素（要关注其他元素）："><a href="#要考虑其他元素（要关注其他元素）：" class="headerlink" title="要考虑其他元素（要关注其他元素）："></a>要考虑其他元素（要关注其他元素）：</h3><ul>
<li>:first-child 第一个子元素</li>
<li>:last-child 最后一个子元素</li>
<li>:only-child  仅有一个子元素</li>
<li>:nth-child(n) 第n 个子元素 （可写计算公式 ，n从0开始查数）CSS从1开始查数 </li>
<li>:nth-last-child(n) 第n 个子元素,倒着数 （可写计算公式）</li>
</ul>
<h3 id="不用考虑其他元素-不关注其他类型元素-："><a href="#不用考虑其他元素-不关注其他类型元素-：" class="headerlink" title="不用考虑其他元素(不关注其他类型元素)："></a>不用考虑其他元素(不关注其他类型元素)：</h3><ul>
<li>:first-of-type  当前类型的第一个</li>
<li>:last-of-type  当前类型的最后一个</li>
<li>:only-of-type  当前类型的仅有一个</li>
<li>:nth-of-type  当前类型的第n个</li>
<li>:nth-of-last-type  当前类型的第n个，倒着查</li>
<li>:empty     元素内容为空</li>
<li>:checked  元素被选中状态</li>
<li>:disabled  被禁用的</li>
<li>:ready-only  只能读,不能写的<br>:ready-write  可读可写的</li>
</ul>
<p>当给html和body设置高度为100%后，再给里面的元素高度设置100%可充满整个页面。</p>
<h3 id="border："><a href="#border：" class="headerlink" title="border："></a>border：</h3><h4 id="border-radious"><a href="#border-radious" class="headerlink" title="border-radious :"></a>border-radious :</h4><p>(左上，右上，右下，左下)<br>（上，上，下，下 / 左，右，右，左）不常用 </p>
<p>可写为border-top-left-radious:左上角<br>用正方形画四分之一圆：一个角的值等于正方形的边长</p>
<h4 id="box-shadow："><a href="#box-shadow：" class="headerlink" title="box-shadow："></a>box-shadow：</h4><p>普通写法：<br>（inset（内阴影默认为外阴影（不写）），水平偏移量（正是向右，负是向左），垂直偏移量（正值向下，负值向上），阴影模糊程度（基于原边框向两侧同时模糊），传播距离（可选）（在四个方向上同时增大阴影的大小），颜色）。</p>
<p>可设置多个box-shadow值，先写的在上面，重复的会加重颜色。</p>
<p>阴影在背景颜色是上面，在文字的下面</p>
<h4 id="border-image："><a href="#border-image：" class="headerlink" title="border-image："></a>border-image：</h4><p><code>border-image-source:url()  引入图片</code></p>
<ul>
<li>border-image-slice：(1-5个参数，前四个参数只能为数值，不能带px表示图片的分割方式，最后一个参数填上fill会把内容区也填充)</li>
</ul>
<ul>
<li>border-image-ouset  向外延伸多少<br>border-image-width  图片显示的宽度（为1表示完全填充，默认为1）</li>
<li>border-image-repeat  默认为stretch将被分割的图像使用拉伸的方式来填充满边框图像区域。</li>
<li>repeat：将被分割的图像使用重复平铺的方式来填充满边框图像区域。当图像碰到边界时，如果超过则被截断。</li>
<li>round：与 repeat 关键字类似。不同在于，当背景图像不能以整数次平铺时，会根据情况缩放图像。</li>
<li>space： 与 repeat 关键字类似。不同在于，当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。</li>
</ul>
<h4 id="background："><a href="#background：" class="headerlink" title="background："></a>background：</h4><h5 id="渐变两种生成方法："><a href="#渐变两种生成方法：" class="headerlink" title="渐变两种生成方法："></a>渐变两种生成方法：</h5><ul>
<li>linear-gradient()线性渐变，</li>
<li>radial-gradient()径向渐变，当成一个图片来看待</li>
</ul>
<h5 id="background"><a href="#background" class="headerlink" title="background"></a>background</h5><ul>
<li>background-image ： 可以添加多个背景图片，多url</li>
<li>background-origin:图片的起始位置（结束位置无法确定），<ul>
<li>border-box；从边框开始，</li>
<li>padding-box：从padding开始(默认值)</li>
<li>content-box:从content开始 </li>
</ul>
</li>
<li>background-clip:图片的截断部分，从哪开始以外部分都不显示，<ul>
<li>border-box：（默认值），</li>
<li>padding-box：,content-box:，text（除了文字展示范围内展示图片（只在文字下面展示），以外区域不展示图片，只在webkit下可以用，需配合谷歌特有属性 </li>
</ul>
</li>
<li>-webkit-text-fill-color:transparent使用，用完之后文字会变成背景的一部分，这时候在设置阴影，阴影会显示在文字的前面，可以适当设置阴影的透明度来缓冲效果）</li>
<li>background-attchent:<ul>
<li>fixed：背景图像相对于视口（viewport）固定，当范围超出原来容器就不会再显示了。；</li>
<li>scroll：背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身，但会随元素的祖先元素或窗体一起滚动。（默认值）；</li>
<li>local：背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容</li>
</ul>
</li>
<li>background-repeat: 可以填两个值代表水平和垂直方向，   <ul>
<li>repeat-x：背景图像在横向上平铺;</li>
<li>repeat-y：背景图像在纵向上平铺;</li>
<li>repeat：背景图像在横向和纵向平铺;</li>
<li>no-repeat：背景图像不平铺(默认值);</li>
<li>round：当背景图像不能以整数次平铺时，会根据情况缩放图像。;</li>
<li>space：当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。</li>
</ul>
</li>
<li>background-size:</li>
<li>background-position:定位开始位置参考图片的起始位置（background-origin）    </li>
</ul>
<h4 id="渐变："><a href="#渐变：" class="headerlink" title="渐变："></a>渐变：</h4><p><code>linear-gradient(方向(可选，默认为自下到上 to bottom,to top right ：到右上)，起始颜色，结束颜色)</code></p>
<p><a href="http://css.doyoe.com/">参考</a></p>
<p>border-color的默认值等于color         </p>
<h4 id="Text："><a href="#Text：" class="headerlink" title="Text："></a>Text：</h4><ul>
<li>text-shadow：（水平偏移，垂直偏移，模糊值，颜色 ）</li>
<li>-webkit-text-stroke:描边（宽度，颜色）</li>
</ul>
<p>调用外部的字体包：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>:  字体的名称;</span><br><span class="line"><span class="attribute">src</span>:<span class="built_in">url</span>() /*地址*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>user-select: none; /*禁止文字被复制*/</code></p>
<h4 id="box"><a href="#box" class="headerlink" title="box:"></a>box:</h4><p>IE6混杂模式的盒模型<br>box-width = width;<br>触发方式：box-sizing = border-box;</p>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow:"></a>overflow:</h4><ul>
<li>hidden(溢出部分隐藏);</li>
<li>scroll(溢出之后出现滚动条) ;</li>
<li>auto(溢出之后出现滚动条，更标准)，<br>可单独设置x,y轴（overflow）</li>
</ul>
<h4 id="resize-必须配合overflow来使用，不然没效果"><a href="#resize-必须配合overflow来使用，不然没效果" class="headerlink" title="resize: 必须配合overflow来使用，不然没效果"></a>resize: 必须配合overflow来使用，不然没效果</h4><ul>
<li>none：不允许用户调整元素大小。</li>
<li>both：用户可以调节元素的宽度和高度。</li>
<li>horizontal：用户可以调节元素的宽度。</li>
<li>vertical：用户可以调节元素的高度。</li>
</ul>
<h3 id="弹性盒模型：flex"><a href="#弹性盒模型：flex" class="headerlink" title="弹性盒模型：flex"></a>弹性盒模型：flex</h3><h4 id="弹性盒"><a href="#弹性盒" class="headerlink" title="弹性盒"></a>弹性盒</h4><p>flex-shrink:计算要计算加权，而且压缩的部分是盒子的内容区。</p>
<p>压缩大小 = 自己真实内容区 * flex-shrink / 所有元素（真实内容区 * flex-shrink）的总和  * 要压缩的总范围。</p>
<p>只设置 flex-basis 或flex-basis &gt; width代表元素的最小宽度，会随内容区增大；<br>设置width后，并且width &gt; flex-basis，width表示元素的最大宽度，则flex-basis &lt; realwidth &lt; width。</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程经济学期末复习</title>
    <url>/135xyq.github.io/2022/01/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="软件工程经济学知识点总结"><a href="#软件工程经济学知识点总结" class="headerlink" title="软件工程经济学知识点总结"></a>软件工程经济学知识点总结</h1><p><a href="https://blog.csdn.net/qq_45808923/article/details/122382500">公式正常版</a></p>
<h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><ul>
<li>选择：20分</li>
<li>判断：20分</li>
<li>计算：20分</li>
<li>综合：25分</li>
<li>论述：15分</li>
</ul>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="工程经济性："><a href="#工程经济性：" class="headerlink" title="工程经济性："></a>工程经济性：</h3><p>生产性工程项目的直接目的是<strong>盈利</strong></p>
<p>非生产性工程项目的直接目的虽不是经济性的,但建设和运行中也必须重视成本。</p>
<p>一切工程都具有经济性。就工程与经济的关系而言,工程是手段,经济才是目的。</p>
<p>工程经济系统的载体——<strong>建设项目</strong></p>
<h3 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h3><p>是对一个工程从概念设想到正式运营的全过程（具体工作包括：投资机会研究、初步可行性研究、最终可行性研究、勘察设计、招标、采购、施工、试运行等）进行管理。</p>
<p>关注“工程—经济系统”的<strong>可持续性</strong>、<strong>可协调性</strong>、<strong>可补偿性</strong></p>
<h3 id="工程分析的基本方法"><a href="#工程分析的基本方法" class="headerlink" title="工程分析的基本方法"></a>工程分析的基本方法</h3><ol>
<li>费用效益分析法：通过项目的投入（即费用）和产出（即效益）的定量对比分析，考察工程项目的<br>费用、效益状况，研究建设项目的经济性。</li>
<li>费用效果分析法：耗费采用货币计量，效果采用非货币计量的定量分析方法 。</li>
<li>预测法：在科学地把握项目的发展规律基础上，描述项目未来建设和运营中的诸多经济要素，以及对相关主体带来的影响，预先度量项目的费用和效益或效果 </li>
<li>价值工程方法： 在剖析功能（效用）的基础上，追踪影响价值的功能，通过功能定义、分析、评 价，系统地认识功能结构，提示完善功能设计、降低费用和提高价值的途径。</li>
<li>系统分析法：对项目的考察不局限在一方面或几个方面，要做全面综合评价，进行系统分析。</li>
</ol>
<h3 id="工程分析的基本原则"><a href="#工程分析的基本原则" class="headerlink" title="工程分析的基本原则"></a>工程分析的基本原则</h3><h4 id="经济效益原则：基本原则"><a href="#经济效益原则：基本原则" class="headerlink" title="经济效益原则：基本原则"></a>经济效益原则：基本原则</h4><p>有用的产出与投入的对比关系</p>
<h5 id="经济效益是一个比较的概念"><a href="#经济效益是一个比较的概念" class="headerlink" title="经济效益是一个比较的概念"></a>经济效益是一个比较的概念</h5><ul>
<li>绝对量的比较 —— 净效益 = 效益 - 耗费</li>
<li>相对量的比较 —— 效益耗费比 = 效益/耗费</li>
<li>净效益耗费比 = 净效益/耗费 </li>
</ul>
<h5 id="经济效益分类"><a href="#经济效益分类" class="headerlink" title="经济效益分类"></a>经济效益分类</h5><ul>
<li>有形效益和无形效益</li>
<li>直接效益和相关效益</li>
<li>宏观效益和微观效益</li>
<li>短期效益和长期效益</li>
</ul>
<h4 id="可持续发展原则"><a href="#可持续发展原则" class="headerlink" title="可持续发展原则"></a>可持续发展原则</h4><ol>
<li>首先要注意资源的可持续利用</li>
<li>其次应注意项目和生态—社会系统的协调和优化</li>
<li>再次要在在长远和全局的角度来分析问题、研究问题</li>
</ol>
<h4 id="资源合理配置和有效使用原则"><a href="#资源合理配置和有效使用原则" class="headerlink" title="资源合理配置和有效使用原则"></a>资源合理配置和有效使用原则</h4><p>科学地、合理地 解决工程项目的“资源稀缺性”与人们日益增长的 需要之间的矛盾。</p>
<p>恰当遴选方案，慎重投资决策，努力实现资源的合理配置和有效使用，使资源的边际收益最大化和系统整体优化。</p>
<h2 id="第二章-资金的时间价值"><a href="#第二章-资金的时间价值" class="headerlink" title="第二章 资金的时间价值"></a>第二章 资金的时间价值</h2><h3 id="社会再生产过程"><a href="#社会再生产过程" class="headerlink" title="社会再生产过程"></a>社会再生产过程</h3><ul>
<li>购买阶段:货币(货币资本) -&gt; 劳动与生产资料(生产资本)</li>
<li>生产阶段:劳动与生产资料(生产资本) -&gt; 商品(商品资本)</li>
<li>销售阶段:商品(商品资本) -&gt; 货币(货币资本)</li>
</ul>
<h3 id="资金时间价值"><a href="#资金时间价值" class="headerlink" title="资金时间价值"></a>资金时间价值</h3><p>资金在社会再生产过程中随着时间推移而产生的<strong>增值</strong>叫资金的时间价值。</p>
<h4 id="资金时间价值的实质"><a href="#资金时间价值的实质" class="headerlink" title="资金时间价值的实质"></a>资金时间价值的实质</h4><p>劳动作用于生产资料创造的新价值，即生产阶段由于劳动的作用，使得商品资本超过生产资本的余额。</p>
<h4 id="资金时间价值的客观性"><a href="#资金时间价值的客观性" class="headerlink" title="资金时间价值的客观性"></a>资金时间价值的客观性</h4><p>资金时间价值产生于客观存在的社会再生产，是社会再生产规律的客观反映，因而具有客观性。</p>
<h3 id="单利和复利"><a href="#单利和复利" class="headerlink" title="单利和复利"></a>单利和复利</h3><h4 id="单利"><a href="#单利" class="headerlink" title="单利"></a>单利</h4><p>就是仅对初始本金计息，不对计算期内产生的利息计算利息的计息方法。</p>
<p>$$F = P(1+ni)$$</p>
<h4 id="复利"><a href="#复利" class="headerlink" title="复利"></a>复利</h4><p>在计息时不仅要考虑初始本金的利息，还要考虑期间所产生利息的利息。</p>
<p>$$F = P(1+i)^n$$</p>
<h3 id="资金的等值运算"><a href="#资金的等值运算" class="headerlink" title="资金的等值运算"></a>资金的等值运算</h3><ul>
<li><p>P:现值<br>绝对概念：0时点上的资金价值<br>相对概念：确定的某时点的之前任一时点的资金价值</p>
</li>
<li><p>F:终值<br>绝对概念：计算期期末的资金价值<br>相对概念：确定的某一时点之后任一时点的资金价值</p>
</li>
<li><p>A:年金<br>狭义：连续发生在每年年末且绝对数值相等的现金流序列<br>广义：连续地发生在每期期末且绝对数值相等的现金流序列</p>
</li>
<li><p>i:期利率</p>
</li>
<li></li>
<li><p>n:时间</p>
</li>
</ul>
<h4 id="一次支付终值公式"><a href="#一次支付终值公式" class="headerlink" title="一次支付终值公式"></a>一次支付终值公式</h4><p>条件：已知P、i、n,求终值F</p>
<p>$$F = P(1+i)^n = P(F/P,i,n)$$</p>
<p>$(1+i)^n$  为一次支付终值系数,$(F/P,i,n)$</p>
<h4 id="一次支付现值公式"><a href="#一次支付现值公式" class="headerlink" title="一次支付现值公式"></a>一次支付现值公式</h4><p>条件：已知F、i、n,求终值P</p>
<p>$$P = F(1+i)^{-n} = F(P/F,i,n)$$</p>
<p>$(1+i)^{-n}$  为一次支付现值系数,$(P/F,i,n)$</p>
<p>例：</p>
<blockquote>
<p>某公司测试工程师年工资总额按照15%的比例递增，8年后能确保工资总支出为1000万元，试计算现在工资总支出为多少？<br>    P＝1000（P／F，15%，8）<br>      ＝ 326.9（万元）</p>
</blockquote>
<h4 id="年金终值公式"><a href="#年金终值公式" class="headerlink" title="年金终值公式"></a>年金终值公式</h4><p>条件：已知A、i、n,求终值F</p>
<p>$F  = A + A(1+i) + A(1+i)^2 + ··· + A(1+i)^{n-2} + A(1+i)^{n-1}$<br>    $= A[a+(1+i) + (1+i)^2 + ··· + (1+i)^{n-1}]$<br>    $= A[(1+i)^{n - 1}] / i$<br>    $= A(F/A,i,n)$</p>
<p>$[(1+i)^{n - 1}] / i$ 为年金终值系数,$(F/A,i,n)$</p>
<p>例：</p>
<blockquote>
<p>某人从事软件开发工作，当年年初开始连续5年，每年缴纳72000元住房公积金，按规定在第七年末可一次提取公积金总额。若投资收益率为15%。问：此人到时可获得本利多少？<br>F＝72000（F／A，15%,5）（F／P，15%，2）<br>  ＝72000×6.7423×1.3225<br>  ＝64.2（万元）</p>
</blockquote>
<h4 id="偿债基金公式"><a href="#偿债基金公式" class="headerlink" title="偿债基金公式"></a>偿债基金公式</h4><p>条件：已知F、i、n，求年金A<br>与年金终值公式互为逆运算</p>
<p>$$ A = Fi / [(1+i)^n - 1] = F(A/F,i,n)$$</p>
<p>$i / [(1+i)^n - 1]$为债偿基金系数,$(A/F,i,n)$</p>
<h4 id="资金回收公式"><a href="#资金回收公式" class="headerlink" title="资金回收公式"></a>资金回收公式</h4><p>条件：已知P、i、n;求年金A</p>
<p>$ F = P(1+i)^n $<br>$ F = A[(1+i)^n - 1] / i$</p>
<p>$ P(1+i)^n  = A[(1+i)^n - 1] / i$<br>$ A = Pi(1+i)^n / [(1+i)^n - 1] = P(A/P,i,n)$</p>
<p>$i(1+i)^n / [(1+i)^n - 1]$为资金回收系数$(A/P,i,n)$</p>
<h4 id="年金现值公式"><a href="#年金现值公式" class="headerlink" title="年金现值公式"></a>年金现值公式</h4><p>条件：已知A、i、n;求现值P</p>
<p>$ F = P(1+i)^n $<br>$ F = A[(1+i)^n - 1] / i$</p>
<p>$ P(1+i)^n  = A[(1+i)^n - 1] / i$<br>$ P = A[(1+i)^n - 1] / [i(1+i)^n] = A(P/A,i,n)$</p>
<p>$ P = A[(1+i)^n - 1] / [i(1+i)^n] $为年金现值系数，$(P/A,i,n)$</p>
<p>例：</p>
<blockquote>
<p>在深圳买房按揭贷款600万元，按揭期间10年，按揭期间内等额偿还本息。若年利率8%，问每年应还款多少，每年偿还的利息是多少？<br>A＝P（A／P，i，n）<br>＝600×（A／P，8%，10）<br>＝89.4（万元）</p>
</blockquote>
<h5 id="永久年金"><a href="#永久年金" class="headerlink" title="永久年金"></a>永久年金</h5><p>当$n\rightarrow \infty$使，称为永久年金，<br>$$ P = A/i$$</p>
<blockquote>
<p>某人计划用购房的方式解决住房问题。房价50万元。某人只有12万元资金，余款需贷款解决，贷款年利率4%，在未来10年内等额偿还。若基准折现率5%，问某人购房总支出相当于现在一次性付款多少？<br>A＝P（A／P，i，n）<br>＝（50-12）×（A／P，4%，10）<br>＝4.68（万元）<br>P＝A/i<br>  ＝4.68÷5%<br>  ＝93.6（万元）</p>
</blockquote>
<h3 id="名义利率和实际利率"><a href="#名义利率和实际利率" class="headerlink" title="名义利率和实际利率"></a>名义利率和实际利率</h3><h4 id="名义利率"><a href="#名义利率" class="headerlink" title="名义利率"></a>名义利率</h4><p>年利率为r，一年计息m次，当m≠1时，称r为名义利率。<br>所谓名义利率即非实际计息的利率。</p>
<h4 id="实际利率"><a href="#实际利率" class="headerlink" title="实际利率"></a>实际利率</h4><p>期利率为$r/m$。对资金计息不以r为利率标准，而在每个计息期间却以$r/m$为利率标准计息。<br>实际利率即实际上以年为计息周期的利率</p>
<p>$$i = (1＋r/m)^m－1$$</p>
<h2 id="第三章-建设项目评价的基本经济要素"><a href="#第三章-建设项目评价的基本经济要素" class="headerlink" title="第三章 建设项目评价的基本经济要素"></a>第三章 建设项目评价的基本经济要素</h2><h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><ul>
<li>名词角度解释：投资就是为了获得未来期望收益而预先垫付的资本。</li>
<li>动词角度解释：是维持建设项目存在的基础。通过投资为项目经济性运营—生产经营—搭建平台，以支撑其作为投资者及其他相关各方获益方式的存在。在项目的存续期间，资本一直存在于项目中。项目终结时，被投资者回收。</li>
</ul>
<p><strong>投资是被项目占用的资源。</strong></p>
<h4 id="投资分类"><a href="#投资分类" class="headerlink" title="投资分类"></a>投资分类</h4><ol>
<li>直接投资和间接投资</li>
<li>短期投资和长期投资</li>
<li>初创投资和后续投资</li>
</ol>
<h5 id="直接投资和间接投资"><a href="#直接投资和间接投资" class="headerlink" title="直接投资和间接投资"></a>直接投资和间接投资</h5><ul>
<li>直接投资:用于经营性资产——建设项目的投资，以期通过投资人对资产运营管理而获利。</li>
<li>间接投资:又称证券投资，是指用于金融资产的 投资，以期通过对金融产品的操作而获益。</li>
</ul>
<h5 id="短期投资和长期投资"><a href="#短期投资和长期投资" class="headerlink" title="短期投资和长期投资"></a>短期投资和长期投资</h5><ul>
<li>短期投资:能够随时变现、持有时间不超过一年的投资。主要指对现金、应收账款、存货、短期 有价证券等的投资，长期有价证券如能随时变现 亦可用于短期投资。</li>
<li>长期投资:不可能或不准备在一年内变现的投资，主要指对厂房、机器设备等固定资产和对专 利权、商标权等无形资产的投资，也包括股权投 资、债券投资和其他投资。</li>
</ul>
<h4 id="建设项目投资构成"><a href="#建设项目投资构成" class="headerlink" title="建设项目投资构成"></a>建设项目投资构成</h4><p><img src="https://img-blog.csdnimg.cn/b100a93872354de39d5f51a7cdf2c3ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/e3212e7b047144bea8175aa83882c4cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="固定资产"><a href="#固定资产" class="headerlink" title="固定资产"></a>固定资产</h5><p>固定资产是项目赖以运营获利的基本条件。其在使用过程中因磨损而性能不断劣化，价值量逐渐贬损。为维持项目的基本生产运营——获利条件，在项目投产运营后用折旧的方式对其贬值的价值量予以弥补。**<strong>在项目终了时，固定资产的残值被回收。</strong></p>
<p><strong>固定资产原值=固定资产净值+固定资产折旧</strong></p>
<h5 id="流动资金"><a href="#流动资金" class="headerlink" title="流动资金"></a>流动资金</h5><p>流动资金是指项目投产运营后，为维持项目正常生产运营所占用的全部周转资金。它是在生产期 内为了保持生产经营的永续性和连续状态而垫付的资金。<br>流动资金在生产经营期间被项目长期占用，在<strong>项目终了时被全额回收。</strong></p>
<h3 id="折旧和摊销"><a href="#折旧和摊销" class="headerlink" title="折旧和摊销"></a>折旧和摊销</h3><p>折旧（摊销）是固定（其他）资产价值磨损的<strong>补偿金</strong>。</p>
<p>将固定（其他）资产因磨损而失去的价值逐渐转移到产品成本中去，而后再从产品销售收入中回收的财务处理方法。这种通过计入产品成本而回收的资产的转移价值称为折旧费。</p>
<h4 id="线性折旧法"><a href="#线性折旧法" class="headerlink" title="线性折旧法"></a>线性折旧法</h4><p>各期提的折旧额是相等的，是一种平均计算方法。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ol>
<li>平均年限法</li>
<li>工作量法</li>
</ol>
<h5 id="平均年限法"><a href="#平均年限法" class="headerlink" title="平均年限法"></a>平均年限法</h5><p>$$ D = K_0R$$<br>$$ R = (1 - f_s) / N$$</p>
<p>$D$—年折旧额，$K_0$—原值，$R$—折旧率，$f_s$—净残值率，$N$—折旧年限</p>
<h5 id="工作量法"><a href="#工作量法" class="headerlink" title="工作量法"></a>工作量法</h5><p>$$ D = SR$$<br>$$R＝K_0（1 - f_s）/ S $$</p>
<p>$S$-工作量，$D$—年折旧额，$K_0$—原值，$R$—折旧率，$f_s$—净残值率，</p>
<p>例：</p>
<blockquote>
<p>机房服务器原值120万元，折旧年限20 年。预计净残值为4.8万元，试计算该设备年、月折旧额。<br>R =（1－fs）/T<br>  =（1-4.8/120）/20<br>D = K0<em>R<br>  = 120</em>（1-4.8/120）/20</p>
</blockquote>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p><strong>成本反映了项目对劳动的消耗</strong></p>
<p>成本是为了获得未来收益而付出的代价。<br>是指以货币形式表现的消耗在产品（服务）中的<strong>物化劳动价值</strong>和<strong>活劳动价值</strong>之和。<br>成本是使产品（服务）得以实现而消耗的生产力要素。所以成本必须在商品销售中得到补偿，得以维持再生产过程 。</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><h5 id="1-要素成本"><a href="#1-要素成本" class="headerlink" title="1. 要素成本"></a>1. 要素成本</h5><ul>
<li>外购原材料</li>
<li>外购燃料、动力</li>
<li>工资及福利</li>
<li>固定资产折旧</li>
<li>修理费</li>
<li>无形资产及其他资产摊销</li>
<li>利息支出</li>
<li>其他费用</li>
</ul>
<h5 id="2-经营成本"><a href="#2-经营成本" class="headerlink" title="2. 经营成本"></a>2. 经营成本</h5><p>经营成本是<strong>付现</strong>的成本。</p>
<p>非现金支出的项目不包含在经营成本中。</p>
<p>经营成本 = 总成本 - 折旧费 - 摊销费 - 财务费用<br>或<br>经营成本 = 外购原材料、燃料、动力费 + 工资及福利 + 修理费 + 其他费用</p>
<h5 id="3-机会成本"><a href="#3-机会成本" class="headerlink" title="3. 机会成本"></a>3. 机会成本</h5><p>又称择一成本，择机代价。是指在经济决策过程中，因选择某一方案而放弃其余方案所付出的代价或丧失的潜在利益。</p>
<p>机会成本的概念确立在资源稀缺性基本原理的框架下。基于资源的稀缺性，项目或企业中的某种资源常常有多种用途，即有多种使用的“机会”。而任何一个投放机会的选定必然意味着其他所有机会即被放弃，并因而放弃与之相伴的潜在收益。那么在该选定机会上的所付出的代价，即机会成本，就是诸多其他投资机会中可能收益的最大值——最佳替代用途价值。</p>
<h5 id="4-沉没成本"><a href="#4-沉没成本" class="headerlink" title="4. 沉没成本"></a>4. 沉没成本</h5><p>沉没成本是发生在<strong>决策之前</strong>，与决策问题无关的费用</p>
<p>沉没成本发生在决策以前，是决策事项的历史成本，不论对目前的决策事项做何抉择，它都是一笔“已然”状态的支出，因而对目前的决策不构成影响。所以在进行方案优选时，对沉没成本不予考虑。</p>
<h3 id="税收及分类"><a href="#税收及分类" class="headerlink" title="税收及分类"></a>税收及分类</h3><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ol>
<li>关税</li>
<li>增值税</li>
<li>营业税</li>
<li>流转税附加</li>
<li>消费税</li>
<li>资源税</li>
<li>企业所得税</li>
</ol>
<h5 id="增值税"><a href="#增值税" class="headerlink" title="增值税"></a>增值税</h5><p>增值税是指以应税产品所增加的价值，即增值额为征税对象的一种税。增值额就是一个生产环节的销售收入额，扣除同期消耗了的外购原材料、燃料动力和计入成本的包装物金额后的数额。<br>增值税纳税主体是在我国境内销售货物或者提供加工修理修配劳务以及进口货物的单位和个人。<br>增值税实行价外征收，根据发票注明税金进行税款抵扣的制度。即</p>
<p>增值税额 = 销项税额 - 进项税额 = 销售额（不含税）× 增值税率－进项额（不含税）× 增值税率</p>
<p>例： </p>
<blockquote>
<p>某项目年产电子产品2.3万件，销售价格为15400元，外购原材料15748万元m，燃料动力为2052万元。产品征收增值税，税率为17%。问：该项目每年缴纳的增值税金为多少？<br>销项税 = 销售额（不含税）×增值税率<br>        =[销售额（含税）/（1+增值税率）]×增值税率<br>        =[2.3×15400（1+17%）]×17%<br>        =5146.5万元<br>进项税=进项额（不含税）×增值税率<br>        =[进项额（含税）/（1+增值税率）]×增值税率<br>        =[（15748+2052/（1+17%）]×17%<br>        =2586.32万元<br>增值税 = 销项税 - 进项税<br> = 5146.5 - 2586.32<br> = 2560.18 万元</p>
</blockquote>
<h5 id="企业所得税"><a href="#企业所得税" class="headerlink" title="企业所得税"></a>企业所得税</h5><p>企业所得税是对在我国境内的企业和其他取得收入组织的应税所得开征的一个税种。<br>在境内的企业和其他取得应税收入的组织，不论出资人国籍身份、企业形态统一适用《企业所得税法》。个人独资企业、合伙企业不适用本法。<br>企业所得税的税率为25％</p>
<p>企业所得税 = (营业收入 - 总成本 - 营业税金 - 前一季度亏损) × 所得税税率</p>
<h3 id="利润"><a href="#利润" class="headerlink" title="利润"></a>利润</h3><p>利润是反映劳动净成果的效益类指标，包括营业利润、投资净收益以及营业外收支净额。</p>
<p>营业利润=营业收入－总成本－营业税及附加</p>
<p>投资净收益是投资收益扣除投资损失后的余额。</p>
<p>营业外收支净额指营业外收入减去营业外支出后的数额。</p>
<p>利润总额＝营业利润＋投资净收益＋营业外收支净额</p>
<p>净利润＝利润总额－所得税</p>
<h2 id="第四章-建设项目的经济性评价指标体系"><a href="#第四章-建设项目的经济性评价指标体系" class="headerlink" title="第四章 建设项目的经济性评价指标体系"></a>第四章 建设项目的经济性评价指标体系</h2><p>建设项目的经济性评价指标体系——能够客观衡量项目经济效益状况的标尺。</p>
<ul>
<li>盈利能力指标：净现值、内部收益率、投资 回收期等</li>
<li>偿债能力指标：利息备付率、偿债备付率等</li>
<li>财务生存（可持续）能力指标：项目投资计划累计净现金流量</li>
</ul>
<h3 id="评价指标按经济性质可以分为"><a href="#评价指标按经济性质可以分为" class="headerlink" title="评价指标按经济性质可以分为"></a>评价指标按经济性质可以分为</h3><ol>
<li>时间型指标：投资回收期、借款偿还期</li>
<li>价值型指标：净现值、净年值等</li>
<li>效率型指标： 内部收益率、净现值率、投资收益率、资本金利润率等</li>
</ol>
<h4 id="投资会回收期"><a href="#投资会回收期" class="headerlink" title="投资会回收期"></a>投资会回收期</h4><p>投资回收期，也称<strong>返本期</strong>，是从项目投资开始（第0年）算起，用项目投产后的收益回收全部投资所需的时间长度。一般以年为单位计</p>
<h5 id="静态投资回收期"><a href="#静态投资回收期" class="headerlink" title="静态投资回收期"></a>静态投资回收期</h5><p>不考虑资金的时间价值因素的投资回收期。</p>
<p>$P_t$ — 投资回收期<br>$CI$  —现金流入量<br>$CO$  —现金流出量<br>$(CI - CO)_t$  —第t年的净现金流量<br>$T$   —累积净现金流量首次为非负值所对应的年份</p>
<p>$$\sum_{t=0}^{P_t}(CI - CO)_t = 0$$</p>
<p>$$P_t = T - 1 +  \frac{第(T - 1)年净现金流累计值的绝对值}{第T年的现金流}$$</p>
<p>如果投资在期初一次投入，且每年的净收益固定不变，则可表示为：</p>
<p>$$ P_t = \frac{K}{R}$$</p>
<p>$K$ —投资总额<br>$R$ —年收益</p>
<h5 id="动态投资回收期"><a href="#动态投资回收期" class="headerlink" title="动态投资回收期"></a>动态投资回收期</h5><p>考虑资金时间价值因素的投资回收期。</p>
<p>$NCF_t$ —第t年的净现金流量<br>$T$   —累积净现金流量现值首次为非负值所对应的年份</p>
<p>$$\sum_{t=0}^{P_t}NCF_t(1+i_c)^{-t} = 0 $$</p>
<p>$$P_t = T - 1 +  \frac{第(T - 1)年净现金流现值累计值的绝对值}{第T年的现金流的现值}$$</p>
<p>例：</p>
<blockquote>
<p>某方案的年净现金流如下表，已知基准折现率为10%，试求方案的投资回收期。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NCF</td>
<td align="center">-100</td>
<td align="center">20</td>
<td align="center">30</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NCF</td>
<td align="center">-100</td>
<td align="center">20</td>
<td align="center">30</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">NCF累计</td>
<td align="center">-100</td>
<td align="center">-80</td>
<td align="center">-50</td>
<td align="center">10</td>
<td align="center">70</td>
<td align="center">130</td>
</tr>
<tr>
<td align="center">NCF折现</td>
<td align="center">-100</td>
<td align="center">18.18</td>
<td align="center">24.79</td>
<td align="center">45.08</td>
<td align="center">40.98</td>
<td align="center">37.26</td>
</tr>
<tr>
<td align="center">折现累计</td>
<td align="center">-100</td>
<td align="center">-81.82</td>
<td align="center">-57.02</td>
<td align="center">-11.95</td>
<td align="center">29.03</td>
<td align="center">66.29</td>
</tr>
</tbody></table>
<p>静态投资回收期：Pt =4-1+50/60=3.8（年）<br>动态投资回收期：Pt =5-1+11.95/40.98=4.29（年）</p>
<h5 id="投资回收期的评价"><a href="#投资回收期的评价" class="headerlink" title="投资回收期的评价"></a>投资回收期的评价</h5><ul>
<li>优点：概念明确,简单易算；既反映方案的盈利性又反映方案的风险。</li>
<li>缺点：它只反映了项目投资回收前的盈利情况，而不能反映投资回收后的盈利情况，因而对项目在整个寿命期内的经济效益反映是不全面的。</li>
</ul>
<p>因此，投资回收期通常不能独立判断项目是否可行。目前在项目评价中不再作为主要指标使用。</p>
<h4 id="净现值"><a href="#净现值" class="headerlink" title="净现值"></a>净现值</h4><p>净现值（Net Present Value，简计为NPV）是指建设项目在整个寿命期内，各年的净现金流按既定的折现率折算到计算期初的现值之和。</p>
<p>净现值是考察建设项目在其计算期内盈利能力的主要动态评价指标。其一般表达式为：</p>
<p>$$NPV = \sum_{t=0}^{n}NCF_t(P / F ,i_c,t)$$</p>
<p>$NCF_t$  —第t年的净现金流量<br>$i_c$    —既定的折现率<br>$n$      —项目计算期</p>
<p>评价建设项目的经济可行性，评价标准为：$NPV &gt;= 0$</p>
<h5 id="净现值函数"><a href="#净现值函数" class="headerlink" title="净现值函数"></a>净现值函数</h5><p>用来表示净现值与折现率之间变化关系的函数。对于既定的项目实施方案，NPV随着i的变化表现出某种变化规律。<br>一般随着i的增加，NPV逐渐变，NPV=f（i）呈减函数变化趋势</p>
<p>例：</p>
<blockquote>
<p>某项目的年净现金流入下表，若基准折现率为10% ，评价项目。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NCF</td>
<td align="center">-1000</td>
<td align="center">200</td>
<td align="center">300</td>
<td align="center">300</td>
<td align="center">300</td>
</tr>
</tbody></table>
<p>NPV=-127.23<br>由于NPV＜0，所以，该项目不可行</p>
<h5 id="净现值的评价"><a href="#净现值的评价" class="headerlink" title="净现值的评价"></a>净现值的评价</h5><ul>
<li>优点：计算简便；计算结果稳定，不会因算术方法的不同而带来任何差异；考虑了资金时间价值并全面考虑了项目在整个寿命期内的经济状况；直接以货币量表示项目的净收益，经济意义明确直观。</li>
<li>缺点：一是只反映资金的总量使用效果，而不反映资金的使用效率。在一些类别的项目评价时，比如金融资产投资项目，可能更需要关注资金的报酬率。此时净现值因无法评定可接受的备选项目的报酬率高低；二是必须预先设定一个较符合经济现实的基准收益率。而基准收益率的确定是一个比较复杂困难的问题。</li>
</ul>
<h4 id="内部收益率"><a href="#内部收益率" class="headerlink" title="内部收益率"></a>内部收益率</h4><p>内部收益率（Internal Rate of Return，简计为IRR）<br>使得项目计算期内各年净现金流量的现值累计值，即净现值等于零时的折现率。</p>
<p>$$\sum_{t=0}^{n}NCF_t(1 + IRR)^{-t} = 0 $$</p>
<p><img src="https://img-blog.csdnimg.cn/1564ebdc60f647828a6d17bc74bd2b1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>$$IRR = i_1 + \frac{NPV_1}{NPV_1 + | NPV_2 |}(i_2 - i_1)$$</p>
<p>注意：**$i_2 - i_1 &lt; 5% $,且 $NPV_1 &gt; 0,NPV_2 &lt; 0$**  </p>
<p>内部收益率表示方案存在于项目中的投资<br>（未被回收的投资）可以实现的盈利（收益）能力。</p>
<h5 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h5><p>$$IRR \ge i_c$$</p>
<h5 id="内部收益率的评价"><a href="#内部收益率的评价" class="headerlink" title="内部收益率的评价"></a>内部收益率的评价</h5><ul>
<li>优点：其大小完全取决于项目本身的现金流大小及分布，不受外界因素干预，客观真实地反映了 方案的经济性；</li>
<li>缺点：计算较烦琐，并且对于非常规项目，净现值方程会出现多解或无解的情形，从而可能使内 部收益率指标失效；内部收益率只反映项目占用资金的使用效率，而不能反映其总量使用效果。</li>
</ul>
<h4 id="利息备付率"><a href="#利息备付率" class="headerlink" title="利息备付率"></a>利息备付率</h4><p>利息备付率也称已获利息倍数，是指项目在借款偿还期内各年可用于支付利息的息税前利润与当 期应付利息费用的比值</p>
<p>$$ICR = \frac{EBIT}{PI}$$</p>
<p>$ICR$   —利息备付率<br>$PI$    —计入成本的应付利息<br>$EBIT$  —息税前利润</p>
<p>$$ EBIT = 净利润 + 计入成本的利息 + 所得税税金  = 毛利润 + 计入成本的利息$$</p>
<p>利息备付率从付息资金来源的充裕性角度反映项目<strong>偿付债务利息</strong>的保障程度。</p>
<p>理论上讲，利息备付率应<strong>大于2</strong>。工程经济分析中，应结合债权人要求确定其具体评价标准。</p>
<h4 id="偿债备付率（DSCR）"><a href="#偿债备付率（DSCR）" class="headerlink" title="偿债备付率（DSCR）"></a>偿债备付率（DSCR）</h4><p>偿债备付率是指借款偿还期内，各年可用于还本付息的资金与当年应还本付息额的比值</p>
<p>$$DSCR = \frac{EBITAD - T_{AX}}{PD}$$</p>
<p>$DESCR$    —偿债备付率<br>$EBITAD$   —息税前折旧摊销前利润<br>$T_{AX}$   —企业所得税额<br>$PD$       —应还本付息金额</p>
<p>$$EBITAD = 息税前金额 + 折旧 + 摊销$$</p>
<p>偿债备付率表示用于还本付息的资金偿还债务资金本息的保障程度。</p>
<p>理论上：$DSCR  &gt; 1$, 实际上：$DSCR \ge 1.3$</p>
<h2 id="第六章-建设项目融资"><a href="#第六章-建设项目融资" class="headerlink" title="第六章 建设项目融资"></a>第六章 建设项目融资</h2><h3 id="融资总体"><a href="#融资总体" class="headerlink" title="融资总体"></a>融资总体</h3><p>所谓融资主体，是指以其名义进行资金的融通活动、并由其对融资行为承担相应责任的当事人。</p>
<p>建设项目融资主体主要有<strong>既有企业法人融资主体</strong>和<strong>新设项目法人融资主体</strong>。</p>
<h4 id="既有企业法人融资"><a href="#既有企业法人融资" class="headerlink" title="既有企业法人融资"></a>既有企业法人融资</h4><p>以下情况应该使用：</p>
<ol>
<li>既有法人经济实力较为雄厚，具有很好的承担全部融资责任的实力。</li>
<li>新建项目与既有企业的资产和经营活动密切联系。</li>
<li>项目自身盈利能力较差，但项目建设和存续对企业整体的持续发展具有重要作用。</li>
</ol>
<h4 id="新设项目法人融资"><a href="#新设项目法人融资" class="headerlink" title="新设项目法人融资"></a>新设项目法人融资</h4><p>新设项目法人融资是指新设项目法人为项目的建设进行融资、并承担融资责任和风险的融资活动。</p>
<p>新设法人融资是以新组建的具有独立法人资格的项目公司为融资主体的资金筹措活动。采用新设项目法人融资方式的建设项目，项目法人大多是<strong>企业法人</strong>，这类项目一般为新建项目，也可以是将既有企业法人的一部分资产剥离出去后重新组建的新的项目法人的改扩建项目。</p>
<h3 id="资金来源"><a href="#资金来源" class="headerlink" title="资金来源"></a>资金来源</h3><p>$$建设项目资金来源渠道<br>\begin{cases}<br>国内资金<br>\begin{cases}<br>财政资金<br>\begin{cases}<br>财政预算内资金 \<br>财政预算外资金<br>\end{cases}<br>\ \ \金融机构信贷资金<br>\begin{cases}<br>政策性银行信贷资金\<br>商业性银行信贷资金 \<br>非银行金融机构资金<br>\end{cases}<br>\ \ \ 其他资金<br>\begin{cases}<br>其他单位资金 \<br>居民个人资金 \<br>企业内部自由资金<br>财政预算外资金<br>\end{cases}<br>\end{cases}<br>\ \ \国外资金<br>\begin{cases}<br>政府资金<br>\begin{cases}<br>政府财政资金 \<br>出口信贷资金<br>\end{cases}<br>\ \ \金融机构或组织资金<br>\begin{cases}<br>世界银行等国际金融组织资金 \<br>外国商业银行资金 \<br>国外非银行金融机构资金<br>\end{cases}<br>\ \ \国外其他资金<br>\begin{cases}<br>企业资金 \<br>居民资金<br>\end{cases}<br>\end{cases}<br>\end{cases}$$</p>
<h3 id="资本金制度"><a href="#资本金制度" class="headerlink" title="资本金制度"></a>资本金制度</h3><p>资本金是指在项目总投资中，由投资者认缴的出资额。对于建设项目来说是非债务性资金，项目法人不承担这部分资金的任何利息和债务；投资者可按其出资的比例依法享有所有者权益，也可转让其出资及其相应权益，但不得以任何方式抽回。</p>
<h4 id="资本金出资方式："><a href="#资本金出资方式：" class="headerlink" title="资本金出资方式："></a>资本金出资方式：</h4><p>货币出资，实物、工业产权、 非专利技术、土地使用权作价出资。对作为资本金 的实物、工业产权、非专利技术、土地使用权，必 须经过有资格的资产评估机构依照法律、法规评估 作价，不得高估或低估。以工业产权、非专利技术 作价出资的比例不得超过投资项目资本金总额的 20%，国家对采用高新技术成果有特别规定的除 外。</p>
<h4 id="资本金占项目总投资比例"><a href="#资本金占项目总投资比例" class="headerlink" title="资本金占项目总投资比例"></a>资本金占项目总投资比例</h4><table>
<thead>
<tr>
<th align="center">投资行业</th>
<th align="center">占比</th>
</tr>
</thead>
<tbody><tr>
<td align="center">交通运输、煤炭项目</td>
<td align="center">35%及以上</td>
</tr>
<tr>
<td align="center">钢铁、邮电、化肥项目</td>
<td align="center">25%及以上</td>
</tr>
<tr>
<td align="center">电力、机电、建材、化工、石油加工、有色、轻工、纺织、商贸及其他行业的项目</td>
<td align="center">20%及以上</td>
</tr>
</tbody></table>
<h4 id="资金的筹集方式"><a href="#资金的筹集方式" class="headerlink" title="资金的筹集方式"></a>资金的筹集方式</h4><p>$$资金筹集方式<br>\begin{cases}<br>资本金的筹集方式<br>\begin{cases}<br>吸收直接投资<br>\begin{cases}<br>国家资本金 \ \<br>法人资本金 \ \<br>个人资本金 \ \<br>外商资本金<br>\end{cases}<br>\ \ \发行股票<br>\begin{cases}<br>优先股 \ \<br>普通股<br>\end{cases}<br>\ \ \ 发行可转换公司债券<br>\end{cases}<br>\ \ \债务资金的筹集方式<br>\begin{cases}<br>银行贷款<br>\begin{cases}<br>商业性银行贷款 \ \<br>政策性银行贷款（国家开发银行、中国进出口银行、中国农业发展银行）<br>\end{cases}<br>\ \ \ 发行债券<br>\ \  \金融租赁<br>\ \ \ 国外债务融资<br>\begin{cases}<br>国际商业银行贷款 \<br>外国政府贷款 \<br>国际金融机构贷款<br>\end{cases}<br>\ \ \ 出口信贷<br>\ \ \国际债券<br>\end{cases}<br>\end{cases}<br>$$</p>
<h5 id="吸收直接投资"><a href="#吸收直接投资" class="headerlink" title="吸收直接投资"></a>吸收直接投资</h5><p>吸收直接投资是指建设项目按照“共同投资、共同经营、共担风险、共享利润”的原则，直接吸收国家、法人、个人和外商投入资本的一种资本金筹集方式。</p>
<h6 id="国家资本金"><a href="#国家资本金" class="headerlink" title="国家资本金"></a>国家资本金</h6><p>国家资本金是指有权代表国家部门或者机构用预算内资金、各类专项建设基金投入建设项目形成的资本金 。<br>特点：产权归国家所有；资金运用和处置受国家严格控制；在国有建设项目中被普遍采用。</p>
<h6 id="法人资本金"><a href="#法人资本金" class="headerlink" title="法人资本金"></a>法人资本金</h6><p>法人资本金是指由企业法人以其可以支配的法人资产投入建设项目形成的资本金 。<br>特点：发生在企业法人之间、以参与利润分配为目的，灵活多样的出资形式。</p>
<h5 id="发行股票"><a href="#发行股票" class="headerlink" title="发行股票"></a>发行股票</h5><h6 id="优先股"><a href="#优先股" class="headerlink" title="优先股"></a>优先股</h6><p>是一种兼具资本金和债务资金特点的有价证券。优先股是相对于普通股而言的。主要指在利润分红及剩余财产分配的权利方面，优先于普通股。</p>
<p>特征：</p>
<ol>
<li>股息率事先固定，不参与公司的分红，但可以先于普通股获得股息。</li>
<li>优先股的权利范围小。优先股股东一般没有选举权和被选举权，对股份公司的重大经营<strong>无投票权</strong>，但在某些情况下可以享有投票权。</li>
<li>如果公司破产清算，优先股的索偿权先于普通股，而次于债权人。</li>
</ol>
<p>发行目的：<br>帮助公司渡过财务难关，增加公司资产又不影响普通股股东的控制权。融资方案分析和财务分析中应视为项目资本金。</p>
<h6 id="普通股"><a href="#普通股" class="headerlink" title="普通股"></a>普通股</h6><p>是随着企业利润变动而变动的一种股份。</p>
<p>特征：</p>
<ol>
<li>股息和分红由公司的经营业绩来确定。</li>
<li>如果公司破产清算，普通股在债权人、优先股股东之后分得公司的剩余财产。</li>
</ol>
<h5 id="可转换债券"><a href="#可转换债券" class="headerlink" title="可转换债券"></a>可转换债券</h5><p>可转换公司债券（convertible bonds）是指根据发行公司债募集办法的规定，债券持有人可将其转换为发行公司的股票。债券持有人有权选择是否将其所持债券转换为股票。</p>
<h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p><strong>筹资灵活</strong>，既可为投资者增加灵活的投资机会，<strong>资金成本低</strong>，可为发行公司调整资本结构或减缓财务压力提供便利。可转换债券兼有债权性、股权性和可转换性的特征，持有人享有其他债券持有人不享有的转股权。筹资效率高，<strong>可转换债券的利息进入运营成本，在所得税前列支</strong>。在工程经济分析中，可转换债券一般作为项目债务资金处理</p>
<h5 id="资本金融资的特点"><a href="#资本金融资的特点" class="headerlink" title="资本金融资的特点"></a>资本金融资的特点</h5><ol>
<li>所筹资金是项目的权益资本，是其他方式筹资的基础，可增强融资主体的信用基础和举债能力。</li>
<li>没有到期偿还等财务问题，融资的财务风险较低。</li>
<li>不具有抵税功效，资金成本较高。</li>
<li>上市公开发行股票，必须公开披露信息，接受投资者和社会公众的监督。</li>
</ol>
<h5 id="银行贷款"><a href="#银行贷款" class="headerlink" title="银行贷款"></a>银行贷款</h5><p>政策性银行有：国家开发银行、中国进出口银行、中国农业发展银行</p>
<h5 id="发行债券"><a href="#发行债券" class="headerlink" title="发行债券"></a>发行债券</h5><p>债券投资者是企业的债权人，不是所有者，无权参与或干涉企业经营管理，但有权按期收回本息。</p>
<h5 id="融资租赁"><a href="#融资租赁" class="headerlink" title="融资租赁"></a>融资租赁</h5><p>它是指<strong>出租人</strong>作为<strong>买受人</strong>与<strong>出卖人</strong>订立买卖合同，购买承租人<strong>指定</strong>的租赁物，并提供给<strong>承租人</strong>使用、收益的租赁方式。融资租赁是一种融资和融物相结合，通过融物达到融资目的的有效手段。</p>
<h5 id="债务资金融资特点："><a href="#债务资金融资特点：" class="headerlink" title="债务资金融资特点："></a>债务资金融资特点：</h5><ol>
<li>是项目的债务资本，到期偿还，融资财务风险较高。</li>
<li>资金成本税前列支，具有抵税作用，资金成本较低。</li>
<li>融资渠道广泛，融资方式多样化</li>
</ol>
<h3 id="新型项目融资模式"><a href="#新型项目融资模式" class="headerlink" title="新型项目融资模式"></a>新型项目融资模式</h3><h4 id="BOT项目融资模式"><a href="#BOT项目融资模式" class="headerlink" title="BOT项目融资模式"></a>BOT项目融资模式</h4><p>BOT模式是国际上近十几年来逐渐兴起的一种基础设施建设的融资模式,是一种利用外资和民营资本兴建基础设施的新兴融资 模式。BOT是Build(建设)-Operate(经营)-Transfer(转让)的缩写, 代表一个完整的项目融资过程。</p>
<h4 id="ABS项目融资模式"><a href="#ABS项目融资模式" class="headerlink" title="ABS项目融资模式"></a>ABS项目融资模式</h4><p>“资产支持证券化”融资模式，是指以目标项目所拥有的资产为基础，以该项目资产的未来预期收益为保证，在资本市场上发行高级债券来筹集资金的的一种融资方式。</p>
<h4 id="PPP项目融资模式"><a href="#PPP项目融资模式" class="headerlink" title="PPP项目融资模式"></a>PPP项目融资模式</h4><p>公共部门与私人企业合作。是指政府、私人营利性企业和非营利性企业基于某个项 目而形成的相互合作关系的形式。</p>
<h4 id="产品支付项目融资模式"><a href="#产品支付项目融资模式" class="headerlink" title="产品支付项目融资模式"></a>产品支付项目融资模式</h4><p>国际贷款人在 提供项目贷款后，将根据项目融资文件直接取得一定比例的项 目产品或该部分产品，并以此进行偿本付息的项目融资方式。贷款偿还前，贷款方拥有项目的部分或全部产品，借款方清偿 债务时把贷款方的贷款看做这些产品销售收入折现后的净值。</p>
<h3 id="资金成本"><a href="#资金成本" class="headerlink" title="资金成本"></a>资金成本</h3><p>资金成本（Cost of Capital）就是企业为筹措和使用资金而付出的代价。</p>
<p>资金成本内容包括<strong>用资费用</strong>和<strong>筹资费用</strong>两部分：<br>用资费用：指企业在投资和经营过程中因获得资金的使用和收益权而付出的费用。如股利、利息等。<br>筹资费用：指企业在筹措资金过程中而付出的费用。如银行借款手续费。</p>
<h4 id="资金成本作用"><a href="#资金成本作用" class="headerlink" title="资金成本作用"></a>资金成本作用</h4><ol>
<li>资金成本是比较筹资方式的依据。</li>
<li>资金成本是评价和选择投资项目的重要标准。</li>
<li>资金成本是进行<strong>资金结构决策</strong>的依据。</li>
</ol>
<h5 id="资本金资本成本"><a href="#资本金资本成本" class="headerlink" title="资本金资本成本"></a>资本金资本成本</h5><h6 id="优先股资金成本"><a href="#优先股资金成本" class="headerlink" title="优先股资金成本"></a>优先股资金成本</h6><p>$K_p$ ——优先股成本；<br>$D_p$ ——优先股年股利，按票面价格计算；<br>$P_0$ ——优先股筹资额，按发行价格计算；<br>$f$ ——优先股筹资费用率。</p>
<p>$$K_p = \frac{D_p}{S_p(1- f)}$$</p>
<p>例：</p>
<blockquote>
<p>某互联网公司上市发行优先股股票，总面值100万元，发行总价为150万元，筹资费率为4％，<br>股息年利率为12％，试确定该优先股的资金成本。</p>
</blockquote>
<p>$$K_p =  \frac{D_p}{S_p(1- f)} = \frac{100 \times 12%}{150 \times (1-4%)} = 8.33%$$</p>
<h6 id="债务资金成本"><a href="#债务资金成本" class="headerlink" title="债务资金成本"></a>债务资金成本</h6><p>债券资金成本中的利息在税前支付，具有抵税效应。债券的筹资费用一般较高，这类费用主要包括申请发行债券的手续费、债券注册费、印刷费、上市费以及摊销费用等。</p>
<p>$K_h$  ——债券资金成本；<br>$B_0$  ——债券的筹资额，以发行价格计算；<br>$I$   ——债券年利息额，以票面价格计算<br>$T$   ——项目主体所得税税率<br>$f$ ——筹资费用率。</p>
<p>$$K_h = \frac{I(1-T)}{B_0(1-f)}$$</p>
<p>例：</p>
<blockquote>
<p>案例：某互联网公司发行总面额为500元的10年期债券，票面利率为2%，发行费用率为5%，公司所得税税率为25%。确定该债券的资金成本。解：根据公式得</p>
</blockquote>
<p>$$K_h = \frac{I(1-T)}{B_0(1-f)} = \frac{500 \times 12% \times (1-25%)}{500 \times (1-5%)} = 9.47%$$</p>
<h6 id="综合资金成本"><a href="#综合资金成本" class="headerlink" title="综合资金成本"></a>综合资金成本</h6><p>综合资本成本（Overall Cost of Capital）是指企业全部长 期资本的总成本。亦称加权平均资本成本（ Weighted  Average Cost of Capital，缩写为WACC）。</p>
<p>$K_w$ ——综合资本成本，即加权平均资本成本；<br>$K_j$ ——第j种个别资本成本；<br>$W_j$ ——第j种个别资本占全部资本的比重，即权数。</p>
<p>$$K_w = \sum_{j=1}^{n}K_jW_j$$</p>
<p>例：</p>
<blockquote>
<p>某项目发起人筹集的总资金为500万元，其中银行借款100万元，债券资金50万元，普通股250万元，留存盈余100万元；其资金成本分别为6.7%、9.1%、7%、11.26%、11%，确定该公司的加权平均资金成本。</p>
</blockquote>
<p>$$K_w = \sum_{j=1}^{n}K_jW_j = 6.7% \times \frac{100}{500} + 9.17% \times \frac{50}{500} +  11.26% \times \frac{250}{500} +  11% \times \frac{100}{500} = 10.09% $$</p>
<h3 id="资金结构和筹资优化"><a href="#资金结构和筹资优化" class="headerlink" title="资金结构和筹资优化"></a>资金结构和筹资优化</h3><h4 id="资金结构"><a href="#资金结构" class="headerlink" title="资金结构"></a>资金结构</h4><p>资金结构是指项目投资总额中各种资金的构成及其比例关系。对建设项目来说资金结构主要包括<strong>资本金与债务资金的比例</strong>、<strong>资本金内部结构比例</strong>和<strong>债务资金内部结构比例</strong>。</p>
<h4 id="筹资风险"><a href="#筹资风险" class="headerlink" title="筹资风险"></a>筹资风险</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>筹资风险的概念：又称财务风险，是指因借款而增加的风险，是项目因借入资金而产生的丧失偿债能力的可能性和项目利润的可变性。</p>
<h5 id="主要影响因素"><a href="#主要影响因素" class="headerlink" title="主要影响因素"></a>主要影响因素</h5><p>影响筹资风险的主要因素：资本供求的变化、利率水平的变动、项目获利能力的变化、资金结构（财务杠杆的利用程度）的变化。财务杠杆对筹资风险影响最大</p>
<h4 id="筹资优化"><a href="#筹资优化" class="headerlink" title="筹资优化"></a>筹资优化</h4><ul>
<li>资金结构的优化：财务杠杆系数  </li>
<li>筹资期限结构优化：还款时间节点</li>
<li>筹资利率结构优化：利率组合</li>
<li>筹资币种结构优化：不同币种</li>
<li>筹资方式的可转换性：债券、股票转换</li>
</ul>
<h2 id="第七章-建设项目评价"><a href="#第七章-建设项目评价" class="headerlink" title="第七章 建设项目评价"></a>第七章 建设项目评价</h2><h3 id="财务评价"><a href="#财务评价" class="headerlink" title="财务评价"></a>财务评价</h3><p>又称企业经济评价。根据<strong>现行国家财税制度和价格体系</strong>，分析、计算项目的直接效益和直接费用，以考察项目的盈利能力、清偿能力和财务生存能力等财务状况，据以判别项目的<strong>财务可行性</strong>。</p>
<p>站在项目的立场上，按照微观利益最大化的原则，以项目为边界，以项目系统的实际发生为依据，分析、计算项目的财务效益和费用，考察项目对财务主体的财务贡献，据此判断项目在财务上的可行性，为投资决策、融资决策和其他有关方面决策提供依据。</p>
<h4 id="财务评价分类"><a href="#财务评价分类" class="headerlink" title="财务评价分类"></a>财务评价分类</h4><p>融资前财务评价：考察项目自身的经济性，为后续工作提供基础。<br>融资后财务评价：考察在既定融资方案基础上，项目对投资人的贡献及其运行状况。</p>
<h4 id="融资前财务评价"><a href="#融资前财务评价" class="headerlink" title="融资前财务评价"></a>融资前财务评价</h4><p>融资前财务评价<strong>不考虑债务资金的筹集</strong>、<strong>使用和偿本付息等融资问题</strong>（假设所需全部资金均为项目所有）对项目建设和运营效益的影响，以考察<strong>项目自身的财务可行性</strong>。在初步可行性研究阶段，可以只进行融资前财务评价。</p>
<p>$$融资前财务评价的现金流<br>\begin{cases}<br>现金流入<br>\begin{cases}<br>营业收入 \<br>补贴收入 \<br>固定资产残值 \<br>流动资金回收<br>\end{cases}<br>\ \ \现金流出<br>\begin{cases}<br>建设投资 \<br>流动资金 \<br>经营成本 \<br>增值税 \<br>营业税金\<br>附加<br>\end{cases}<br>\end{cases}<br>$$</p>
<h4 id="融资后财务评价"><a href="#融资后财务评价" class="headerlink" title="融资后财务评价"></a>融资后财务评价</h4><p>在确定的融资方案基础上进行的项目财务评价。融资后财务评价考虑了债务资金的筹集、使用和还本付息等融资问题对项目建设和运营效益的影响，以考察<strong>项目对投资者的财务贡献</strong>。</p>
<p>融资前评价是站在项目的角度，考察项目的财务可行性；融资后评价是站在投资者的角度，考察项目对资本金和其他投资的贡献，判断项目满足投资者投资期望的程度。</p>
<h5 id="资本金财务评价。现金流量由以下科目构成："><a href="#资本金财务评价。现金流量由以下科目构成：" class="headerlink" title="资本金财务评价。现金流量由以下科目构成："></a>资本金财务评价。现金流量由以下科目构成：</h5><ul>
<li>现金流入：营业收入、补贴收入、固定资产残值及流动资金回收。</li>
<li>现金流出：项目资本金投入、经营成本、营业税金及附加、企业所得税、借款的偿本与付息。</li>
</ul>
<h5 id="投资各方财务评价。投资各方财务评价的现金流量由以下科目构成："><a href="#投资各方财务评价。投资各方财务评价的现金流量由以下科目构成：" class="headerlink" title="投资各方财务评价。投资各方财务评价的现金流量由以下科目构成："></a>投资各方财务评价。投资各方财务评价的现金流量由以下科目构成：</h5><ul>
<li>现金流入：利润分配、资产处置收益分配、租赁费收入、技术转让或使用收入。</li>
<li>现金流出：实缴资本、租赁资产支出。 </li>
</ul>
<p>$$财务评价<br>\begin{cases}<br>融资前评价 - 盈利能力评价<br>\begin{cases}<br>动态评价 - 项目投资现金流分析 - 项目投资财务净现值<br>\ \静态评价 - 投资回收期<br>\end{cases}<br>\ \ \ 融资后评价<br>\begin{cases}<br>盈利能力评价<br>\begin{cases}<br>动态评价<br>\begin{cases}<br>项目资本金现金流分析 - 资本金财务收益率 \ \<br>投资各方现金流分析 - 各方财务收益率<br>\end{cases}<br>\ \ 静态评价 - 资本金利润率、总投资收益率<br>\end{cases}<br>\ \ \偿债能力评价 - 利息备付率、偿债备付率<br>\  \ \财务生存能力评价 - 项目财务计划现金流分析 - 盈余资金<br>\end{cases}<br>\end{cases}<br>$$<br><img src="https://img-blog.csdnimg.cn/d5a91a19e01a4180a90b7f858940001d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>2.融资后财务评价<br>2.1盈利能力评价<br>    资本金现金流<br>        现金流入：营业收入、补贴收入、固定资产残值及流动资金回收。<br>        现金流出：资本金投入、经营成本、营业税金及附加、企业所得税、借款的偿本付息。<br>    ——资本金现金流量表<br>2.2偿债能力评价<br>   ——利润与利润分配表：营业收入、补贴收入、营业税金及附加、总成本费用、利润总额、所得税、净利润、可供分配利润、法定盈余公积金、可供投资者分配利润、优先股股利、普通股股利、未分配利润、息税前利润（利润总额+利息）、息税折旧摊销前利润（EBIT+折旧+摊销）<br>   ——借款还本付息计划表：期初余额、当期发生数额、当期应计利息、当期还本付息、其中：还本 、付息、期末余额<br>2.3财务生存能力评价<br>   ——财务计划现金流量表<br>2.3.1经营活动净现金流：<br>    现金流入：营业收入、增值税销项税额、补贴收入<br>    现金流出：经营成本、增值税进项税额、营业税及附加、增值税、所得税<br>2.3.2投资活动净现金流<br>    现金流出：建设投资、流动资金<br>2.3.3融资活动净现金流<br>    现金流入：项目资本金、建设投资借款、流动资金借款、短期借款<br>    现金流出：各种利息支付、借款本金偿还</p>
<h2 id="第八章-建设项目的国民经济评价"><a href="#第八章-建设项目的国民经济评价" class="headerlink" title="第八章 建设项目的国民经济评价"></a>第八章 建设项目的国民经济评价</h2><p>建设项目财务评价是以<strong>现行市场价格体系</strong>为评价基础的。现金流计算中的基本经济要素的价格都取自于市场价格体系。而市场发育不成熟、不完善，市场价格可能存在背离价值的“扭曲”和偏离供求关系的“失真”所以导致财务评价基础有一定的缺陷。</p>
<h3 id="国民经济评价的经济内涵"><a href="#国民经济评价的经济内涵" class="headerlink" title="国民经济评价的经济内涵"></a>国民经济评价的经济内涵</h3><ul>
<li>可以从宏观上优化配置国家的有限资源</li>
<li>可以真实反映工程项目对国民经济的净贡献</li>
<li>可以使投资决策更科学化</li>
</ul>
<h3 id="评价的项目范围"><a href="#评价的项目范围" class="headerlink" title="评价的项目范围"></a>评价的项目范围</h3><ul>
<li>具有垄断特征的项目</li>
<li>产出具有公共产品的特征的项目</li>
<li>外部效果显著的项目</li>
<li>资源开发项目</li>
<li>涉及国家安全的项目</li>
<li>受过度行政干预的项目</li>
</ul>
<h3 id="国民经济评价和财务评价的比较"><a href="#国民经济评价和财务评价的比较" class="headerlink" title="国民经济评价和财务评价的比较"></a>国民经济评价和财务评价的比较</h3><p>$$国民经济评价和财务评价的比较<br>\begin{cases}<br>相同点<br>\begin{cases}<br>提供决策依据；<br>\ \评价基础相同；<br>\ \评价分析方法、指标类似<br>\end{cases}<br>\ \ \不同点<br>\begin{cases}<br>评价角度不同；(财务评价：企业；国民经济评价：国家)<br>\ \费用和效益的划分不同；(财务评价：以项目系统为边界，以内部效果为计算基础；国民经济评价：以国民经济系统为边界，以项目的全部效果(内部和外部)为基础)<br>\ \使用的价格体系不同(财务评价；预测价格；国民经济评价：影子价格)<br>\ \采用的评价参数不同。<br>\end{cases}<br>\end{cases}<br>$$</p>
<h3 id="外部效果"><a href="#外部效果" class="headerlink" title="外部效果"></a>外部效果</h3><p>建设项目<strong>间接效益</strong>和<strong>间接费用</strong>的统称，是由于项目实施所导致的在项目之外未计入项目直接效益与直接费用的效果。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li>环境影响效果；环境污染费用</li>
<li>价格影响效果；大量出口导致同类产品价格下跌</li>
<li>相邻效果；上下游企业的发展</li>
<li>技术扩散效果；技术革新</li>
<li>乘数效果；闲置资源有效利用</li>
<li>无形效果；人力、生命质量、疾控、生活秩序等</li>
</ol>
<h3 id="转移支付"><a href="#转移支付" class="headerlink" title="转移支付"></a>转移支付</h3><p>在国民经济框架下，一个部门向另一个部门支付的财富，而这笔财富并未带来社会财富总量的变化</p>
<h3 id="影子价格"><a href="#影子价格" class="headerlink" title="影子价格"></a>影子价格</h3><p>某一种资源处于最优配置时，其<strong>边际增量</strong>对社会福利的贡献值。</p>
<h4 id="影子价格的确定"><a href="#影子价格的确定" class="headerlink" title="影子价格的确定"></a>影子价格的确定</h4><h5 id="1-由市场价格调整影子价格"><a href="#1-由市场价格调整影子价格" class="headerlink" title="1. 由市场价格调整影子价格"></a>1. 由市场价格调整影子价格</h5><h6 id="具有市场价格的商品影子价格的确定"><a href="#具有市场价格的商品影子价格的确定" class="headerlink" title="具有市场价格的商品影子价格的确定"></a>具有市场价格的商品影子价格的确定</h6><ul>
<li>对处于竞争性市场环境中的商品，取该市场价格为影子价格</li>
<li>若对原来有冲击，则求出两者的平均值</li>
</ul>
<h5 id="2-可外贸货物的影子价格"><a href="#2-可外贸货物的影子价格" class="headerlink" title="2. 可外贸货物的影子价格"></a>2. 可外贸货物的影子价格</h5><p>$$出口产出物的影子价格 = 离岸价(FOB) \times 影子汇率 - 出口费用 $$</p>
<p>$$进口投入物的影子价格 = 到岸价(CIF)  \times 影子汇率 + 进口费用 $$</p>
<p>$$影子汇率 = 影子汇率换算系数 \times 官方牌价汇率$$<br>我国影子汇率换算系数为1.08</p>
<h5 id="3-特殊投入物的影子价格"><a href="#3-特殊投入物的影子价格" class="headerlink" title="3. 特殊投入物的影子价格"></a>3. 特殊投入物的影子价格</h5><h6 id="人力资源的影子价格"><a href="#人力资源的影子价格" class="headerlink" title="人力资源的影子价格"></a>人力资源的影子价格</h6><p>$$影子工资 = 劳动力的机会成本 + 新增资源消耗$$</p>
<p>$$影子工资 = 财务工资 \times 影子工资换算系数$$</p>
<h6 id="土地影子价格"><a href="#土地影子价格" class="headerlink" title="土地影子价格"></a>土地影子价格</h6><p>$$土地影子价格 = 土地机会成本 + 新增资源消耗$$</p>
<p>新增资源消耗主要包括：拆迁费、安置费和其他费用</p>
<h2 id="第九章-不确定性分析和风险分析"><a href="#第九章-不确定性分析和风险分析" class="headerlink" title="第九章 不确定性分析和风险分析"></a>第九章 不确定性分析和风险分析</h2><h3 id="不确定性分析"><a href="#不确定性分析" class="headerlink" title="不确定性分析"></a>不确定性分析</h3><p>项目不确定性是指对于<strong>项目未来经济状况</strong>（尤其是收益和损失）的<strong>分布范围</strong>和<strong>状态</strong>不能确知的性质。</p>
<h4 id="项目不确定性产生的原因"><a href="#项目不确定性产生的原因" class="headerlink" title="项目不确定性产生的原因"></a>项目不确定性产生的原因</h4><h5 id="主观原因"><a href="#主观原因" class="headerlink" title="主观原因"></a>主观原因</h5><ol>
<li>信息的不完全性及不充分</li>
<li>人的有限理性</li>
</ol>
<h5 id="客观原因"><a href="#客观原因" class="headerlink" title="客观原因"></a>客观原因</h5><ol>
<li>经济环境因素的影响</li>
<li>技术环境因素的影响</li>
<li>政策及法律环境因素的影响</li>
<li>市场供求变化的影响</li>
<li>社会文化环境因素的影响</li>
<li>自然条件和资源因素的影响</li>
</ol>
<h4 id="不确定性分析的步骤"><a href="#不确定性分析的步骤" class="headerlink" title="不确定性分析的步骤"></a>不确定性分析的步骤</h4><ol>
<li>鉴定项目的主要不确定性因素</li>
<li>预测和估计不确定性因素的变动范围</li>
<li>选择不确定性分析的方法</li>
<li>确定分析的结果</li>
<li>提示项目实施风险</li>
</ol>
<h3 id="盈亏平衡分析"><a href="#盈亏平衡分析" class="headerlink" title="盈亏平衡分析"></a>盈亏平衡分析</h3><p>不确定性因素的变化，影响着建设项目的经济效果，当这些因素的变化达到某一临界值时，可能致使原来盈利的项目变为亏损项目，并导致项目比选的结果发生质的变化。盈亏平衡分析的目的就是找出这种由盈利到亏损、由优到劣的临界点，据此考察建设项目对运营状态变化的<strong>适应能力</strong>、<strong>承受能力</strong>和<strong>抵御风险能力</strong></p>
<h4 id="盈亏平衡分析的概念"><a href="#盈亏平衡分析的概念" class="headerlink" title="盈亏平衡分析的概念"></a>盈亏平衡分析的概念</h4><p>根据项目<strong>产（销）量、成本与利润</strong>之间的经济数量关系，通过分析项目的<strong>盈亏平衡点</strong>（Break-Even-Point，BEP），考察项目对运营状态变化的适应能力、承受能力和抵御风险能力，是评价项目财务可靠性的不确定性分析方法。盈亏平衡分析在<strong>财务评价环境</strong>中进行。</p>
<h4 id="线性盈亏平衡分析"><a href="#线性盈亏平衡分析" class="headerlink" title="线性盈亏平衡分析"></a>线性盈亏平衡分析</h4><p>基本假设:</p>
<ol>
<li>销售量等于产量；</li>
<li>固定成本和单位变动成本固定不变；</li>
<li>销售单价相对固定；</li>
<li>生产单一产品，或多种产品但可以换算为单一产品。</li>
</ol>
<p>$p$ —单位产品销售价格（单价）<br>$Q$ —年销售量（产量）<br>$v$ —单位产品可变成本<br>$F$ —年度固定成本<br>$P$ —年度总利润<br>$S$ —年度销售收入<br>$C$ —年度总成本费用<br>$r$ —营业税税率</p>
<p>年度销售收入函数：$$S = pQ$$<br>年度总成本费用函数：$$C＝F + vQ$$<br>年度总利润函数: $$P  = S - C - Sr$$</p>
<h5 id="盈亏平衡点"><a href="#盈亏平衡点" class="headerlink" title="盈亏平衡点"></a>盈亏平衡点</h5><ol>
<li><p>以年产销量表示：$Q_0$表好似盈亏平衡点产量<br>$$ Q_0 = F / (p - v - pr)$$</p>
</li>
<li><p>以销售收入表示：$S_0表示销售收入的盈亏平衡点$<br>$$S_0  = pQ_0  = pF / (p -v -pr)$$</p>
</li>
<li><p>以生产能力利用率表示：$a_0$为生产能力利用率的盈亏平衡点，$Q_s$表示设计生产能力</p>
</li>
</ol>
<p>$$a_0 = (Q_0 / Q_s) \times 100%$$<br>当$a_0 \le 70%$ ,项目具有较好的抗风险能力</p>
<h5 id="经营安全度"><a href="#经营安全度" class="headerlink" title="经营安全度"></a>经营安全度</h5><p>$$A = \frac{(Q_s - Q_0)}{Q_s}$$</p>
<p>$A$ —经营安全度</p>
<p>$A$越大，经营的安全性越大，$A \ge 70%$时，项目经营安全。</p>
<p>例：</p>
<blockquote>
<p>某方案设计年产量为30万件，估计产品单价为10元，单 位可变成本为8元，年固定成本为40万元，营业税率为 5%。试分别用产量、销售收入、生产能力利用率表示盈 亏平衡点，并计算经营安全度。</p>
</blockquote>
<p>Q0＝F／(p-v-pr)＝400000／（10-8-10×5%）＝266667（件）<br>S0＝p×F／(p-v-pr)＝10×400000/（10-8-10×5%）＝2666667<br>（元）<br>а0＝（Q0/Qs）×100%＝266667／300000＝88.9%<br>A＝1-а0=1-88.9%=11.1%<br>由于а0＞70%，A＜30%，所以项目经营风险较高，财务运营可靠性不高</p>
<h3 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h3><p>敏感性分析，也称灵敏度分析，是不确定性分析中常用的方法之一。通过敏感性分析发现敏感性因素，为进一步的风险分析打下基础。</p>
<p>敏感性分析是通过分析<strong>不确定性因素的变化</strong>对项目经济效益评价指标的影响，从中找出敏感因素，估计项目效益对 其敏感程度揭示经济效益指标及评价结论对不确定性因素的敏感性，粗略以此预测项目风险，并为进一步的风险分析作铺垫的不确定分析方法。</p>
<h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><p>敏感性分析分为<strong>单因素敏感性分析</strong>与<strong>多因素敏感性分析</strong>。 </p>
<p>单因素敏感性分析是指进行敏感性分析时，假定只有单一 因素是变化的，其它因素保持不变，用以分析单一因素对经济评价指标的影响以及评价指标对单一因素的敏感程度；<br>多因素敏感性分析是指在同时有两个或两个以上的因素发生变化时，分析这些变化的因素对经济评价指标的影响程度和评价指标对它们的敏感程度。为了找出对评价指标影响最大的敏感性不确定因素，通常采用单因素敏感性分析的方法。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>选择不确定性因素</li>
<li>预测不确定性因素的变动范围或幅度</li>
<li>确定进行敏感性分析的指标</li>
<li>计算各变动因素的敏感度系数和转换值</li>
<li>寻找敏感因素，进行项目风险的粗略分析</li>
</ol>
<p>例：</p>
<blockquote>
</blockquote>
<table>
<thead>
<tr>
<th align="center">主要参数</th>
<th align="center">投  资 K（万元）</th>
<th align="center">年营业收入  S（万元）</th>
<th align="center">年经营成本  C（万元）</th>
<th align="center">期末残值 L（万元）</th>
<th align="center">寿命 n（年）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">估算值</td>
<td align="center">1500</td>
<td align="center">600</td>
<td align="center">250</td>
<td align="center">200</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>基准折现率10%，项目实施中，投资、年营业收入、年经营成本均可能在±10%、±20%范围波动，试分别就年销售收入、投资、年经营成本进行项目敏感性分析。</p>
<p>解：<br>（1）选定项目的净年值（NAV）为评价指标。<br>（2）计算基本方案的净年值。<br>NAV = [-1500(A/P,10%,6)+600-250+200(A/F,10%,6)]万元<br>= 31.52 万元<br>（3）确定因素变动幅度为：-20%、-10%、+10%、-20%。<br>（4）计算相应的净年值变动率。<br>如 △S/S=+10%，即S=[600(1+10%)]万元=660万元，则：<br>NAV = [-1500(A/P,10%,6)+660-250+200(A/F,10%,6)]万元<br>= 91.52 万元<br>△ NPV=( 91.52- 31.52）=60 万元<br>△ NPV/ NPV= 60 / 31.52 =190.36%<br>（5）计算净年值指标对于年销售收入的敏感度系数。<br>如 NAV对于S的敏感度系数，S=190.36%/105=19.04</p>
<p>计算净年值指标对于年销售收入的敏感度系数。<br>如年销售收入，令：<br>NAV = -1500(A/P,10%,6)+600(1+Z)-250+200(A/F,10%,6)=0<br>解得：Z=-5.32%</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>敏感性分析虽然分析了不确定性因素的变化对方案的经济效益的影响，但它并不能说明不确定性因素发生变动的可能性大小，即<strong>发生变动的概率</strong>，而这种概率与项目的风险大小直接相关。实际上，有些因素变动尽管对项目经济效果影响很大，即为敏感因素，但由于其发生的可能性很小，所以给项目带来的风险并不大；而另外一些因素虽然它们变动对项目的经济效益影响不大，不是敏感因素，但因其发生的可能性很大，反而可能给项目带来很大的风险。对这类问题的分析，敏感性分析无法解决，而应借助于风险分析。</p>
<h3 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a>风险分析</h3><p>风险一般是指因某种不确定性引起的行动的<strong>潜在损失</strong>。<br>但在决策理论中，它们之间的差别在于关键的两点：</p>
<ol>
<li>风险条件下的决策，意味着决策者可以列出一个决策的所有可能后果，及与之相关的出现概率，这种决策称之为风险型决策。</li>
<li>不确定性条件下的决策，则意味着决策者不能列出全部可能 后果，或者不能确定各种后果的出现概率。这种决策称之为不确定性决策。<br>事实上，不确定性条件下的决策比之风险条件下的决策，决策者面临着更大的风险。</li>
</ol>
<p>把知道发生可能性（概率）的不确定性称为风险。<br>把不知道发生可能性（概率）的称为不确定性。即风险是可以或能够估量的不确定性，而不确定性（狭义的不确定性）是不能够估量的。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>风险识别</li>
<li>风险测度</li>
<li>风险评价</li>
<li>风险应对</li>
</ol>
<h4 id="风险概率分布的两种形式"><a href="#风险概率分布的两种形式" class="headerlink" title="风险概率分布的两种形式"></a>风险概率分布的两种形式</h4><h5 id="离散型概率分布"><a href="#离散型概率分布" class="headerlink" title="离散型概率分布"></a>离散型概率分布</h5><p>输入变量可能值是有限个数。各种状态的 概率取值之和等于1，它适用于变量取值个数不多的输入变量。</p>
<h5 id="连续型概率分布"><a href="#连续型概率分布" class="headerlink" title="连续型概率分布"></a>连续型概率分布</h5><p>输入变量的取值充满一个区间。</p>
<p><img src="https://img-blog.csdnimg.cn/e59d1631bec84f5fa20945e5fd2b09ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="风险分析方法"><a href="#风险分析方法" class="headerlink" title="风险分析方法"></a>风险分析方法</h4><h5 id="列表法"><a href="#列表法" class="headerlink" title="列表法"></a>列表法</h5><h5 id="概率树法"><a href="#概率树法" class="headerlink" title="概率树法"></a>概率树法</h5><p>概率树的画法：用来矩形表示方案结点，从方案结点引出的直线叫做方案枝，用⚪来表示状态结点，从状态结点引出的直线叫状态枝，同时把风险要素的各种状态及相应概率写在状态枝上，同时把各种状态下的收益写在概率树的 左三角号末端。</p>
<p>例：书(P180)</p>
<blockquote>
<p>某商品住宅小区开发项目现金流量的估计 值如表9-6所示，根据经验推断，销售收入和开发成本为离散型随机变量，其值在基本方案参数估计值的基础上可能发生的变化及其概率见表9-7。试确定该项目净现值大于等于零的概率。基准收益率ic=12%</p>
<table>
<thead>
<tr>
<th>年份</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>销售收入</td>
<td>857</td>
<td>7143</td>
<td>17446</td>
</tr>
<tr>
<td>开发成本</td>
<td>5888</td>
<td>4873</td>
<td>6900</td>
</tr>
<tr>
<td>其他税费</td>
<td>56</td>
<td>464</td>
<td>1196</td>
</tr>
<tr>
<td>净现金流量</td>
<td>-5087</td>
<td>1806</td>
<td>9350</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>概率  变幅 因素</th>
<th>-20%</th>
<th>0</th>
<th>+20%</th>
</tr>
</thead>
<tbody><tr>
<td>销售收入</td>
<td>0.2</td>
<td>0.6</td>
<td>0.2</td>
</tr>
<tr>
<td>开发成本</td>
<td>0.1</td>
<td>0.3</td>
<td>0.6</td>
</tr>
</tbody></table>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2fa9c9f689a144c5ae00e1b29a23e387.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="蒙特卡洛法"><a href="#蒙特卡洛法" class="headerlink" title="蒙特卡洛法"></a>蒙特卡洛法</h5><p>蒙特卡洛模拟法（简称模拟法）是通过<strong>反复地进行随机抽样</strong>来模拟各种随机变量的变化，进而计算分析项目经济效果指标的概率分布的一种分析方法。<br>当变量数或状态数超过3个时，运用概率树分析的工作量将很大。这时，可以采用模拟法，通过随机抽样的方法生成服从特定概率分布的建设投资、销售收入、经营成本等数据，并据此计算净现值、内部收益率等评价指标。经过反复地抽样、计算，当样本数足够大时，便可获得评价指标的概率分布以及累计概率分布、期望值、方差、标准差、离散系数等数据，从而估计项目的风险。</p>
<h6 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h6><p>a．确定风险分析所采用的评价指标；<br>b．确定影响项目评价指标的主要风险因素；<br>c．估计主要风险因素的概率分布，并用数学模型表示；<br>d．为各风险因素独立抽取随机数；<br>e．将抽得的各随机数转化为各风险因素的抽样值；<br>f．将抽样值组成一组项目评价基础数据，并据计算相应的评价指标；<br>g．重复d～f步骤，直至达到预定的模拟次数；<br>h．整理模拟结果，计算评价指标的期望值、方差、标准差、离散系数以及累计概率等，并可绘制累计概率图。</p>
<p>例：书(P181)</p>
<h2 id="第十章-可行性研究"><a href="#第十章-可行性研究" class="headerlink" title="第十章 可行性研究"></a>第十章 可行性研究</h2><p>可行性研究（Feasibility  Study）是在项目寿命周期中，项目策划决策阶段的一个重要内容，可行性研究也成为可行性分析。它主要是对拟投资的项目进行全面、综合技术经济分析。</p>
<h3 id="项目的生命周期（八个阶段）"><a href="#项目的生命周期（八个阶段）" class="headerlink" title="项目的生命周期（八个阶段）"></a>项目的生命周期（八个阶段）</h3><ol>
<li>策划决策阶段:项目建议书、可行性研究</li>
<li>勘察设计阶段：初步设计、技术设计、施工图设计</li>
<li>建设准备阶段：施工招投标、订立合同、办理施工许可</li>
<li>施工阶段</li>
<li>生产准备阶段</li>
<li>竣工验收阶段</li>
<li>项目后评审阶段</li>
<li>项目清理</li>
</ol>
<p>对项目进行可行性分析的一个核心是对项目投资合理性的论证，也就是对项目进行经济评价（财务评价和国民经济评价），需要应用我们所学的工程经济学基本原理与方法对拟投资项目在整个项目寿命期内，各种投入和产出（经济性评价要素）进行分析，因此说，工程经济学基本原理和方法在实践中的一个应用领域就是针对项目的可行性研究。</p>
<h3 id="可行性研究考察项目"><a href="#可行性研究考察项目" class="headerlink" title="可行性研究考察项目"></a>可行性研究考察项目</h3><p>$$考察项目<br>\begin{cases}<br>技术上的先进性、适用性 \ \<br>经济上的合理性、盈利性 \ \<br>实施上的可能性、风险性<br>\end{cases}<br>$$</p>
<h3 id="可行性研究的作用"><a href="#可行性研究的作用" class="headerlink" title="可行性研究的作用"></a>可行性研究的作用</h3><ol>
<li>作为项目投资决策的依据； </li>
<li>作为向银行等金融机构或金融组织申请贷款、筹集资金的依据； </li>
<li>作为项目主管部门商谈合同、签订协议的依据； </li>
<li>作为编制设计和进行建设工作的依据； </li>
<li>作为项目组织管理，机构设置，技术、设备采用等工作的依据； </li>
<li>作为申报项目和接受相关部门评审的依据。</li>
</ol>
<h3 id="可行性研究报告的编制框架"><a href="#可行性研究报告的编制框架" class="headerlink" title="可行性研究报告的编制框架"></a>可行性研究报告的编制框架</h3><ol>
<li>总论</li>
<li>市场需求调查、预测和拟建规模</li>
<li>原材料、能源、公共基础设施情况</li>
<li>建厂条件和厂址方案</li>
<li>工艺技术和设备选择</li>
<li>节能分析</li>
<li>环境影响评价</li>
<li>劳动安全卫生与消防</li>
<li>企业组织、劳动定员及员工培训</li>
<li>项目实施进度</li>
<li>投资估算与项目融资</li>
<li>经济评价</li>
<li>社会评价</li>
<li>综合评价</li>
<li>附件</li>
</ol>
]]></content>
      <categories>
        <category>软件工程经济学</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>软件工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器和生成器</title>
    <url>/135xyq.github.io/2021/12/31/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol>
<li>什么是迭代？</li>
</ol>
<p>从一个数据集合中按照一定的顺序，不断取出数据的过程</p>
<ol start="2">
<li>迭代和遍历的区别？</li>
</ol>
<p>迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完</p>
<p>遍历强调的是要把整个数据依次全部取出</p>
<ol start="3">
<li>迭代器</li>
</ol>
<p>对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象</p>
<ol start="4">
<li>迭代模式</li>
</ol>
<p>一种设计模式，用于统一迭代过程，并规范了迭代器规格：</p>
<ul>
<li>迭代器应该具有得到下一个数据的能力</li>
<li>迭代器应该具有判断是否还有后续数据的能力</li>
</ul>
<h3 id="JS中的迭代器"><a href="#JS中的迭代器" class="headerlink" title="JS中的迭代器"></a>JS中的迭代器</h3><p>JS规定，如果一个对象具有next方法，并且该方法返回一个对象，该对象的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: 值, <span class="attr">done</span>: 是否迭代完成&#125;</span><br></pre></td></tr></table></figure>

<p>则认为该对象是一个迭代器</p>
<p>含义：</p>
<ul>
<li>next方法：用于得到下一个数据</li>
<li>返回的对象<ul>
<li>value：下一个数据的值</li>
<li>done：boolean，是否迭代完成</li>
</ul>
</li>
</ul>
<h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p><strong>概念回顾</strong></p>
<ul>
<li>迭代器(iterator)：一个具有next方法的对象，next方法返回下一个数据并且能指示是否迭代完成</li>
<li>迭代器创建函数（iterator creator）：一个返回迭代器的函数</li>
</ul>
<p><strong>可迭代协议</strong></p>
<p>ES6规定，如果一个对象具有知名符号属性<code>Symbol.iterator</code>，并且属性值是一个迭代器创建函数，则该对象是可迭代的（iterable）</p>
<h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h3><p>for-of 循环用于遍历可迭代对象，格式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代完成后循环结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">in</span> iterable)&#123;</span><br><span class="line">    <span class="comment">//iterable：可迭代对象</span></span><br><span class="line">    <span class="comment">//item：每次迭代得到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> result = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.value);</span><br><span class="line">    result = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展开运算符与可迭代对象"><a href="#展开运算符与可迭代对象" class="headerlink" title="展开运算符与可迭代对象"></a>展开运算符与可迭代对象</h3><p>展开运算符可以作用于可迭代对象，这样，就可以轻松的将可迭代对象转换为数组。</p>
<p>字符串时可迭代的。</p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 (Generator)"></a>生成器 (Generator)</h2><h3 id="1-什么是生成器？"><a href="#1-什么是生成器？" class="headerlink" title="1.什么是生成器？"></a>1.什么是生成器？</h3><p>生成器是一个通过构造函数Generator创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象</p>
<h3 id="2-如何创建生成器？"><a href="#2-如何创建生成器？" class="headerlink" title="2. 如何创建生成器？"></a>2. 如何创建生成器？</h3><p>生成器的创建，必须使用生成器函数（Generator Function）</p>
<h3 id="3-如何书写一个生成器函数呢？"><a href="#3-如何书写一个生成器函数呢？" class="headerlink" title="3. 如何书写一个生成器函数呢？"></a>3. 如何书写一个生成器函数呢？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个生成器函数，该函数一定返回一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br></pre></td></tr></table></figure>

<h3 id="4-生成器函数内部是如何执行的？"><a href="#4-生成器函数内部是如何执行的？" class="headerlink" title="4. 生成器函数内部是如何执行的？"></a>4. 生成器函数内部是如何执行的？</h3><p>生成器函数内部是为了给生成器的每次迭代提供的数据</p>
<p>每次调用生成器的next方法，将导致生成器函数运行到下一个yield关键字位置</p>
<p>yield是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。</p>
<h3 id="5-有哪些需要注意的细节？"><a href="#5-有哪些需要注意的细节？" class="headerlink" title="5. 有哪些需要注意的细节？"></a>5. 有哪些需要注意的细节？</h3><p>1). 生成器函数可以有返回值，返回值出现在第一次done为true时的value属性中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">10</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>2). 调用生成器的next方法时，可以传递参数，传递的参数会交给yield表达式的返回值<br>3). 第一次调用next方法时，传参没有任何意义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="keyword">yield</span> <span class="number">2</span> + n;</span><br><span class="line">    <span class="built_in">console</span>.log(n1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next(<span class="number">33</span>)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">35</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next(<span class="number">34</span>)</span><br><span class="line"> <span class="number">34</span></span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>4). 在生成器函数内部，可以调用其他生成器函数，但是要注意加上*号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* test1()</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = test2();</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-生成器的其他API"><a href="#6-生成器的其他API" class="headerlink" title="6. 生成器的其他API"></a>6. 生成器的其他API</h3><ul>
<li>return方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束</li>
<li>throw方法：调用该方法，可以在生成器中产生一个错误</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>马克思题库</title>
    <url>/135xyq.github.io/2022/01/01/%E9%A9%AC%E5%85%8B%E6%80%9D%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>在纪念马克思诞辰200周年大会上，习近平指出：“人类社会发生了巨大而深刻的变化，但马克思的名字依然在世界各地受到人们的尊敬，马克思的学说依然闪烁着耀眼的真理光芒！”马克思主义之所以仍然闪耀真理的光芒是因为（）。<br>A. 它完成了对所有客观事物的认识<br>B. 它是检验认识真理性的唯一标准<br>C. 它正确反映了社会发展规律并具有与时俱进的理论品质<br>D. 它是任何条件下都必须全部照搬的<br>正确答案：C</p>
</li>
<li><p>（）标志着现代无产阶级作为独立的政治力量登上了历史舞台。<br>A. 资本主义生产方式在欧洲的普遍确立<br>B. 法国. 英国. 德国工人运动的兴起<br>C. 共产主义者同盟的成立<br>D. 马克思主义的公开问世<br>正确答案：B</p>
</li>
<li><p>（）在斗争中逐渐走向自觉，产生了对科学理论指导的需要，成为马克思主义的阶级基础。<br>A. 无产阶级<br>B. 小资产阶级<br>C. 地主阶级<br>D. 农民阶级<br>正确答案：A</p>
</li>
<li><p>表明马克思. 恩格斯完成从唯心主义向唯物主义. 从革命民主主义向共产主义的转变的是（）。<br>A. 1844年在《德法年鉴》上发表的论文<br>B. 1848年发表的《共产党宣言》<br>C. 1871年写成的《法兰西内战》<br>D. 1878年写成的《反杜林论》<br>正确答案：A</p>
</li>
<li><p>由马克思. 恩格斯合作写作的（）首次系统阐释了历史唯物主义的基本观点。<br>A. 《黑格尔法哲学批判》<br>B. 《德意志意识形态》<br>C. 《资本论》<br>D. 《反杜林论》<br>正确答案：B</p>
</li>
<li><p>马克思. 恩格斯接受国际性工人组织“正义者同盟”的邀请，为其起草了第一个无产阶级政党的党纲（）。<br>A. 《共产党宣言》<br>B. 《论犹太人问题》<br>C. 《政治经济学批判》<br>D. 《英国工人阶级状况》<br>正确答案：A</p>
</li>
<li><p>1876年至1878年，恩格斯写出了（），全面阐述了马克思主义理论体系。<br>A. 《神圣家族》<br>B. 《哥达纲领批判》<br>C. 《反杜林论》<br>D. 《家庭. 私有制和国家的起源》<br>正确答案：C</p>
</li>
<li><p>19世纪末到20世纪初，（）成为帝国主义体系中最薄弱的环节，为无产阶级革命首先在此发生并取得胜利创造了有利条件。<br>A. 美国<br>B. 法国<br>C. 德国<br>D. 俄国<br>正确答案：D</p>
</li>
<li><p>列宁深刻分析了19世纪末20世纪初世界历史条件的变化，认为资本主义发达国家已经发展到（）。<br>A. 自由竞争阶段<br>B. 垄断阶段<br>C. 生产集中阶段<br>D. 帝国主义阶段<br>正确答案：D</p>
</li>
<li><p>在帝国主义阶段，除无产阶级与资产阶级矛盾外，（）成为资本主义世界的又一重大矛盾。<br>A. 农民阶级与地主阶级的矛盾<br>B. 垄断资本家与小商品生产者的矛盾<br>C. 金融资本与实体产业的矛盾<br>D. 帝国主义和殖民地半殖民地国家的民族矛盾<br>正确答案：D</p>
</li>
<li><p>列宁和布尔什维克党领导了（），是社会主义从理想开始变为现实，开创了世界历史的新纪元。<br>A. 二月革命<br>B. 四月政变<br>C. 十月革命<br>D. 雾月政变<br>正确答案：C</p>
</li>
<li><p>列宁在领导俄国革命和建设过程中，把马克思主义与俄国实际相结合，创立了（），把马克思主义发展到一个新的历史阶段。<br>A. 列宁主义<br>B. 伯恩斯坦主义<br>C. 修正主义<br>D. 无政府主义<br>正确答案：A</p>
</li>
<li><p>习近平指出：“马克思创建了唯物史观和剩余价值学说，揭示了人类社会发展的一般规律，揭示了资本主义运行的特殊规律，为人类指明了从必然王国向自由王国飞跃的途径。”这集中体现了马克思主义的（）特征。<br>A. 科学性<br>B. 实践性<br>C. 革命性<br>D. 发展性<br>正确答案：A</p>
</li>
<li><p>恩格斯指出：“马克思的整个世界观不是教义，而是方法。它提供的不是现成的教条，而是进一步研究的出发点和供这种研究使用的方法。”这集中体现了马克思主义的（）特征。<br>A. 人民性<br>B. 发展性<br>C. 革命性<br>D. 科学性<br>正确答案：B</p>
</li>
<li><p>马克思主义的政治立场是（）。<br>A. 人民至上<br>B. 政党至上<br>C. 集团至上<br>D. 利益至上<br>正确答案：A</p>
</li>
<li><p>“江山就是人民. 人民就是江山，打江山. 守江山，守的是人民的心”集中体现了马克思主义的（）特征。<br>A. 人民性<br>B. 科学性<br>C. 革命性<br>D. 发展性<br>正确答案：A</p>
</li>
<li><p>马克思在《关于费尔巴哈的提纲》中提出：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”这集中体现了马克思主义的（）特征。<br>A. 人民性<br>B. 科学性<br>C. 实践性<br>D. 发展性<br>正确答案：C</p>
</li>
<li><p>（）观点是马克思主义首要的和基本的观点。<br>A. 实践<br>B. 认识<br>C. 物质<br>D. 价值<br>正确答案：A</p>
</li>
<li><p>德国古典哲学是马克思主义哲学的直接理论来源，马克思恩格斯批判地吸取了黑格尔哲学的（）。<br>A. 唯物主义思想<br>B. 辩证法思想<br>C. 劳动价值论<br>D. 唯物史观<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系，是（）. 是指引人民创造美好生活的行动指南。<br>A. 关于自然. 社会和人类思维发展一般规律的学说<br>B. 关于社会主义必然代替资本主义. 最终实现共产主义的学说<br>C. 关于无产阶级解放全人类解放和每个人自由而全面发展的学说<br>D. 无产阶级政党和社会主义国家的指导思想<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义的基本观点包括（）等一系列观点。<br>A. 关于世界统一于物质. 物质决定意识的观点<br>B. 关于实践和认识辩证关系的观点<br>C. 关于人与自然和谐共生的观点<br>D. 关于世界历史的观点<br>正确答案：ABCD</p>
</li>
<li><p>习近平指出：“中国共产党根基在人民. 血脉在人民. 力量在人民。”这体现了马克思主义的基本立场，即以无产阶级的解放和全人类的解放为己任. 以人的自由全面发展为美好目标. （）。<br>A. 以人民为中心<br>B. 一切为了人民<br>C. 一切依靠人民<br>D. 全心全意为人民谋幸福<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯所生活的时代，资本主义在西欧已经有了相当的发展，资本主义生产方式在促进生产发展的同时造成了（），带来如何说明资本主义这个怪物. 人类的未来在哪里等问题。<br>A. 社会分工向自给自足经济退化<br>B. 社会两极分化<br>C. 经济危机周期性爆发<br>D. 农民对于土地依附关系加强<br>正确答案：BC</p>
</li>
<li><p>19世纪西欧（）三大思潮为马克思主义的创立提供了直接的理论来源。<br>A. 德国古典哲学<br>B. 英国古典政治经济学<br>C. 英法两国的空想社会主义<br>D. 法国理性主义<br>正确答案：ABC</p>
</li>
<li><p>19世纪（）三大科学发现，为马克思主义提供了自然科学前提。<br>A. 作用力与反作用力定律<br>B. 细胞学说<br>C. 能量守恒与转化定律<br>D. 生物进化论<br>正确答案：BCD</p>
</li>
<li><p>列宁指出：“马克思的全部天才正是在于他回答了人类先进思想已经提出的种种问题。他的学说的产生正是哲学. 政治经济学和社会主义极伟大的代表人物的学说的直接继续。”马克思学说直接继续的“代表人物的学说”包括（）。<br>A. 黑格尔的辩证法思想<br>B. 亚当·斯密等人对劳动和价值的分析<br>C. 圣西门等人的社会主义思想<br>D. 孟德斯鸠等人的“三权分立”思想<br>正确答案：ABC</p>
</li>
<li><p>“马克思主义同‘宗派主义’毫无相似之处，它绝不是离开世界文明发展大道而产生的一种固步自封. 僵化不变的学说”，这说明马克思主义（）。<br>A. 是社会发展的产物<br>B. 回应了时代所提出的课题<br>C. 是对人类文明优秀成果的继承<br>D. 随时代发展而不断丰富<br>正确答案：ABCD</p>
</li>
<li><p>（）是马克思一生的两个伟大发现。<br>A. 劳动价值论<br>B. 剩余价值学说<br>C. 唯物主义<br>D. 唯物史观<br>正确答案：BD</p>
</li>
<li><p>中国共产党在革命. 建设. 改革的进程中不断推进马克思主义中国化，产生了毛泽东思想. （）等理论成果，丰富和发展了马克思主义。<br>A. 邓小平理论<br>B. “三个代表”重要思想<br>C. 科学发展观<br>D. 习近平新时代中国特色社会主义思想<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义具有鲜明的（），这些特征体现了马克思主义的本质和使命。<br>A. 科学性<br>B. 人民性<br>C. 实践性<br>D. 发展性<br>正确答案：ABCD</p>
</li>
<li><p>马克思关于哲学. 政治经济学. 科学社会主义的观点，最终升华为马克思主义的根本原因是（）。<br>A. 马克思对所处的时代和世界的深入考察<br>B. 马克思对人类社会发展规律的深刻把握<br>C. 马克思远超前人的才华与天赋<br>D. 马克思丰富的求学经历<br>正确答案：AB</p>
</li>
<li><p>马克思主义具有科学的世界观和方法论基础，即（）。<br>A. 辩证唯物主义<br>B. 历史唯物主义<br>C. 直观唯物主义<br>D. 朴素唯物主义<br>正确答案：AB</p>
</li>
<li><p>人民群众是历史的创造者，是社会主义事业的依靠力量，这要求马克思主义政党必须（）。<br>A. 把人民放在心中最高位置<br>B. 一切奋斗都致力于实现最广大人民的根本利益<br>C. 一切为了人民，一切依靠人民<br>D. 全心全意为人民谋幸福<br>正确答案：ABCD</p>
</li>
<li><p>当前世界正经历百年未有之大变局，必须坚持与时俱进，继续丰富和发展马克思主义，要（）。<br>A. 既坚持马克思主义基本原理，又谱写新的理论篇章<br>B. 既发扬优良传统，又创造新鲜经验<br>C. 在解放思想中统一思想<br>D. 用发展的马克思主义指导新的实践<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义之所以能够作为观察当代世界的认识工具，是因为（）。<br>A. 马克思主义能够站在科学和时代的制高点上观察事物和现象<br>B. 马克思主义掌握了人类社会发展的规律，具有唯物辩证的科学方法<br>C. 马克思主义善于透过现象看本质，能够把握住问题实质<br>D. 能够从运动中看到变化，从变化中看到发展<br>正确答案：ABCD</p>
</li>
<li><p>2019年，英国《泰晤士报》报道说，金融危机使西方人突然重视马克思的《资本论》了，“马克思再一次成为了时髦”。德国马克思故居展览馆馆长曾说“我记不清听到人们这样讲了多少次：‘这个人是对的’”。马克思能够再次成为时髦是因为（）。<br>A. 世界仍处于马克思所指明的从资本主义走向社会主义的大时代<br>B. 马克思所揭示的资本主义基本矛盾仍然存在<br>C. 马克思主义揭示了人类社会发展规律<br>D. 社会主义已经代替了资本主义<br>正确答案：ABC</p>
</li>
<li><p>马克思主义对于人类走向未来具有不可缺少的启示和引领价值，我们要（）。<br>A. 用马克思主义观察时代<br>B. 用马克思主义把握时代<br>C. 用马克思主义引领时代<br>D. 把中国特色社会社会主义和人类进步事业不断推向前进<br>正确答案：ABCD</p>
</li>
<li><p>新时代中国大学生的素质尤其是思想政治素质如何，关系到实现全面建设社会主义现代化强国的宏伟目标，学习马克思主义理论应（）。<br>A. 努力学习和掌握马克思主义的基本立场. 观点. 方法<br>B. 努力学习和掌握马克思主义中国化的理论成果<br>C. 坚持理论联系实际的马克思主义学风<br>D. 自觉将马克思主义内化于心<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>相对于特定历史条件下的个别理论判断，马克思主义基本原理具有普遍的. 根本的和长远的指导意义。<br>对</p>
</li>
<li><p>马克思主义仅仅是马克思和恩格斯两个人的学说的总和。<br>错</p>
</li>
<li><p>马克思主义哲学. 马克思主义政治经济学和科学社会主义构成马克思主义的全部内容。<br>错</p>
</li>
<li><p>马克思主义哲学是对德国古典哲学的完全继承。<br>错</p>
</li>
<li><p>马克思主义就是德国古典哲学. 英国古典政治经济学和空想社会主义的总和。<br>错</p>
</li>
<li><p>19世纪20世纪末，资本主义出现了马克思恩格斯生前不曾有的新特点，经济政治发展的不平衡成为资本主义发展的绝对规律。<br>对</p>
</li>
<li><p>社会主义革命可能在一国或数国首先发生并取得胜利的论断，是列宁在分析帝国主义的经济基础. 深刻矛盾和统治危机基础上提出的。<br>对</p>
</li>
<li><p>习近平新时代中国特色社会主义思想是马克思主义中国化最新理论成果，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南。<br>对</p>
</li>
<li><p>辩证唯物主义和历史唯物主义是马克思主义的一个突出特征和理论优势。<br>对</p>
</li>
<li><p>无产阶级解放和全人类解放是完全一致的。<br>对</p>
</li>
<li><p>观察当今世界局势和社会发展，不仅要看到现状，更要看到未来，因此需要马克思主义辩证思想的深邃目光。<br>对</p>
</li>
<li><p>中国现代化建设取得的举世瞩目的伟大成就，是马克思主义的现实指导作用和当代价值的最直接. 最可靠的证明。<br>对</p>
</li>
<li><p>为中国人民谋幸福，为中华民族谋复兴的初心和使命是激励中国共产党人不断前进的根本动力。<br>对</p>
</li>
<li><p>当今世界发展日新月异，与马克思所处时代相比已经发生了巨大而深刻的变化，马克思主义已经不再适用。<br>错</p>
</li>
<li><p>学习马克思主义最根本的是要掌握马克思主义的基本立场. 观点. 方法，领会马克思主义的精髓要义。<br>对</p>
</li>
</ol>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="单选-1"><a href="#单选-1" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>对（）问题的不同回答，形成了唯物主义和唯心主义两种根本对立的哲学派别。<br>A. 存在和思维何者为第一性的问题<br>B. 存在和思维是否具有同一性的问题<br>C. 谁是社会历史的创造者问题<br>D. 认识的本质和来源问题<br>正确答案：A</p>
</li>
<li><p>对（）问题的不同回答，形成了可知论和不可知论两种根本对立的哲学派别。<br>A. 存在和思维何者为第一性的问题<br>B. 存在和思维是否具有同一性的问题<br>C. 谁是社会历史的创造者问题<br>D. 认识的本质和来源问题<br>正确答案：B</p>
</li>
<li><p>把世界的本原归结为某种或某几种具体物质形态的观点属于( )。<br>A. 形而上学唯物主义<br>B. 朴素唯物主义<br>C. 唯心主义<br>D. 辩证唯物主义<br>正确答案：B</p>
</li>
<li><p>亚里士多德曾说：“最早的哲学家大都认为万物的唯一原理是物质本性的原理……这类哲学的创始人泰勒斯称该原理是水……”，这种“最早的哲学家”的观点属于（）。<br>A. 主观唯心主义<br>B. 客观唯心主义<br>C. 朴素唯物主义<br>D. 机械唯物主义<br>正确答案：C</p>
</li>
<li><p>桓谭在《新论·祛蔽》中说:“精神居形体，犹火之燃烛矣。……烛无，火亦不能独行于空虚。”这种认为精神没有了形体就不能存在的观点属于（）。<br>A. 唯物主义<br>B. 唯心主义<br>C. 可知论<br>D. 不可知论<br>正确答案：A</p>
</li>
<li><p>贝克莱曾说：“只要闭上眼睛，世界上就没有什么悬崖”，这种观点属于（）。<br>A. 唯物主义<br>B. 唯心主义<br>C. 可知论<br>D. 不可知论<br>正确答案：B</p>
</li>
<li><p>古希腊哲学家皮浪认为：“感觉是我们认知外在世界的唯一通道，但感觉又是不真实的。因为感觉并不能告诉我们什么是真理，什么是错误。我们一点也不能相信它们。”这种观点属于（）。<br>A. 唯物主义<br>B. 唯心主义<br>C. 可知论<br>D. 不可知论<br>正确答案：D</p>
</li>
<li><p>“鹅湖之会”是中国哲学史上著名的辩论，朱熹同陆氏兄弟围绕“教人之法”展开激烈辩论。朱熹主张格物致知，穷尽事物之理，陆九渊则主张心即理，发明本心。从哲学角度看，这场辩论的实际上是（）。<br>A. 可知论和不可知论之争<br>B. 朴素唯物主义和辩证唯物主义之争<br>C. 客观唯心主义同主观唯心主义之争<br>D. 机械唯物主义同朴素唯物主义之争<br>正确答案：C</p>
</li>
<li><p>1803年英国化学家约翰·道尔顿发表“原子说”，提出所有物质都是由原子构成。 随着科学发展，原子的存在进一步被证实。受此影响，近代部分哲学家认为物质的本质就是原子，这种观点的局限是（）。<br>A. 不能正确认识物质和意识何者为第一性的问题<br>B. 不能正确认识意识能否正确反映存在的问题<br>C. 不能正确理解哲学的物质概念与自然科学物质概念之间共性与个性的关系<br>D. 不能正确理解社会存在和社会意识的关系<br>正确答案：C</p>
</li>
<li><p>马克思主义的物质范畴从现实存在着的自然存在与社会存在中抽象出其共同特性，即（）。<br>A. 客观实在性<br>B. 主观能动性<br>C. 形式统一性<br>D. 相对独立性<br>正确答案：A</p>
</li>
<li><p>马赫主义主张世界第一性的东西既不是物质也不是精神，而是感觉经验，强调一切科学理论都不过是假说，不存在真实的外部世界。马赫主义的观点从根本上否认了物质世界的（）。<br>A. 主观能动性<br>B. 统一性<br>C. 多样性<br>D. 客观实在性<br>正确答案：D</p>
</li>
<li><p>费尔巴哈主张感觉能够给人揭示客观真理，认为“我的感觉是主观的，可是它的基础是客观的”，这说明物质（）。<br>A. 能够被感觉所复写<br>B. 和感觉完全同一<br>C. 不能被感觉所认识<br>D. 是感觉的派生物<br>正确答案：A</p>
</li>
<li><p>《坛经》中记载：“时有风吹幡动。一僧曰风动，一僧曰幡动。议论不已。惠能进曰：‘非风动，非幡动，仁者心动。’” 从辩证唯物主义来看，这种观点的局限性在于（）。<br>A. 认为世界不能被感知<br>B. 认为世界依赖于感觉而存在<br>C. 认为客观精神是世界的本源<br>D. 认为存在绝对静止<br>正确答案：B</p>
</li>
<li><p>马克思主义的物质范畴对物质作出了全面的科学规定，这一范畴（）。<br>A. 是对费尔巴哈的完全继承<br>B. 是一切人在生动的人类实践中作出的<br>C. 是对旧唯物主义的完全继承<br>D. 是对自然界的直观复写<br>正确答案：B</p>
</li>
<li><p>物质的根本属性是（）。<br>A. 运动<br>B. 静止<br>C. 时间<br>D. 空间<br>正确答案：A</p>
</li>
<li><p>列宁认为：“世界上除了运动着的物质之外，什么也没有”，这种观点属于（）。<br>A. 否认意识能动性的直观唯物主义<br>B. 否认世界可知性的经验批判主义<br>C. 认为运动是物质的根本属性的辩证唯物主义<br>D. 认为世界运转永恒不变的机械唯物主义<br>正确答案：C</p>
</li>
<li><p>运动就其作为哲学范畴而言，标志着（）。<br>A. 单纯空间位置的变动<br>B. 理论思维的发展过程<br>C. 时间的发展延伸<br>D. 一切事物和现象的变化及其过程<br>正确答案：D</p>
</li>
<li><p>毛泽东曾说：“人的认识物质，就是认识物质的运动形式”，这是因为（）。<br>A. 物质的静止状态不可认识<br>B. 物质本身不可认识<br>C. 物质和运动不可分离<br>D. 意识和运动直接同一<br>正确答案：C</p>
</li>
<li><p>马克思指出：“物体. 存在. 实体是同一种实在的观念。决不可以把思维同那思维着的物质分开。物质是一切变化的主体。”这说明（）。<br>A. 运动是物质的运动<br>B. 思维并不存在<br>C. 运动就是思维的运动<br>D. 物质依赖于思维而存在<br>正确答案：A</p>
</li>
<li><p>“风定花犹落，鸟鸣山更幽”形象地表达了动和静的辩证关系是（）。<br>A. 静不是动，动不是静<br>B. 动是必然的，静是偶然的<br>C. 运动和静止相互依赖. 相互渗透. 相互包含<br>D. 动是静的原因，静是动的结果<br>正确答案：C</p>
</li>
<li><p>明代诗人曾写道：“空手把锄头，步行骑水牛。人在桥上走，桥流水不流。”从辩证唯物主义来理解，“水不流”体现的是（）。<br>A. 物质运动的变动性<br>B. 物质运动的稳定性<br>C. 物质运动的一维性<br>D. 物质运动的三维性<br>正确答案：B</p>
</li>
<li><p>内稳态是生物学的一个定义，属于稳态的一种，表示生物通过神经-体液-免疫系统协同工作而维持的一种自身内部相对稳定的状态。内稳态的存在体现了（）。<br>A. 物质世界的运动是相对的<br>B. 物质运动过程中存在相对静止<br>C. 存在着不运动的物质<br>D. 相对静止的无条件性<br>正确答案：B</p>
</li>
<li><p>钱钟书在《管锥编》中写道：“寂静之幽深者，每以得声音衬托而愈觉其深”。以下各项中，与这句话体现的道理相同的是（）。<br>A. 物方生方死<br>B. 人一次也不能踏进同一条河流<br>C. 蝉噪林逾静，鸟鸣山更幽<br>D. 沉舟侧畔千帆过，病树前头万木春<br>正确答案：C</p>
</li>
<li><p>王安石对诗句“蝉噪林逾静，鸟鸣山更幽”十分喜爱，并在自己的《钟山绝句》将其改为“茅檐相对坐终日，一鸟不鸣山更幽”。黄庭坚评价他的这一改动为“点金成铁”，从哲学的角度看，这是因为（）。<br>A. 忽视了物质和运动不可分割的关系<br>B. 忽视了物质运动的无条件性<br>C. 忽视了运动与静止的对立统一关系<br>D. 忽视了物质运动与时空的紧密关联<br>正确答案：C</p>
</li>
<li><p>2021年6月17日，神舟十二号载人飞船成功对接于天和核心舱前向端口。在对接中，宇宙飞船首先以相同的速度与空间站同步移动，同步后，与其对接端口相连，这主要利用了（）。<br>A. 物质运动中空间的相对位置暂时不变<br>B. 事物的根本性质暂时不变<br>C. 静止的绝对性<br>D. 静止的无条件性<br>正确答案：A</p>
</li>
<li><p>时间是物质运动的持续性. 顺序性，特点是（）。<br>A. 一维性<br>B. 相对性<br>C. 主观性<br>D. 能动性<br>正确答案：A</p>
</li>
<li><p>空间是指物质运动的广延性，特点是（）。<br>A. 三维性<br>B. 多元性<br>C. 独立性<br>D. 主观性<br>正确答案：A</p>
</li>
<li><p>“盛年不再来，一日难再晨”体现的是（）。<br>A. 空间的三维性<br>B. 时间的一维性<br>C. 运动的相对性<br>D. 意识的主观性<br>正确答案：B</p>
</li>
<li><p>牛顿主张绝对的时空观，他曾提出“时间. 空间是一切事物的储藏所”，这种观点的局限性在于（）。<br>A. 否认了物质与运动的不可分割<br>B. 否认了时空与物质运动的不可分割<br>C. 否认了时间与空间的不可分割<br>D. 否认了运动与静止的不可分割<br>正确答案：B</p>
</li>
<li><p>诗人文嘉在《明日歌》中写道：“世人皆被明日累，明日无穷老将至。”“明日无穷老将至”所蕴含的哲学原理是（）。<br>A. 具体物质形态时空的有限性<br>B. 静止的无条件性<br>C. 空间的一维性<br>D. 整个物质世界时空的有限性<br>正确答案：A</p>
</li>
<li><p>经典力学中有一种观点认为时间是“永远均匀流动的，它不依赖于任何外界事物。”这观点属于（）。<br>A. 主观唯心主义<br>B. 朴素唯物主义<br>C. 辩证唯物主义<br>D. 机械唯物主义<br>正确答案：D</p>
</li>
<li><p>医学科学证明，如果人的大脑皮层受损，就会丧失思维能力，没有意识，这说明（）。<br>A. 人脑是意识内容的唯一来源<br>B. 人脑健康自然会有正确的意识<br>C. 人脑是意识的物质器官<br>D. 意识是对外界事物的正确反映<br>正确答案：C</p>
</li>
<li><p>“意识在任何时候都只能是被意识到了的存在，而人们的存在就是他们现实生活的过程”说明（）。<br>A. 意识本质上是客观世界的映像<br>B. 意识在形式和内容上都是客观的<br>C. 意识就是人们的现实生活<br>D. 意识是对现实生活的正确反映<br>正确答案：A</p>
</li>
<li><p>随着分工的发展，“意识才能现实地想象：它是和现存实践的意识不同的某种东西”，这说明（）。<br>A. 分工是意识的唯一来源<br>B. 社会实践特别是劳动，在意识发展中起着决定作用<br>C. 意识是分工条件下的特殊存在<br>D. 分工条件下意识摆脱现实获得完全独立性<br>正确答案：B</p>
</li>
<li><p>马克思. 恩格斯指出：“语言是一种实践的. 既为别人存在因而也为我自身而存在的. 现实的意识。”以下关于语言的说法中，错误的是（）。<br>A. 劳动和交往的需要是语言产生的基础<br>B. 语言的产生促进了意识的发展<br>C. 语言是意识的本体和来源<br>D. 语言的产生促进了生产和交往的发展<br>正确答案：C</p>
</li>
<li><p>中国古代提到月亮往往想到广寒宫等神话形象，而如今即使是小朋友们，也知道月亮是围绕地球旋转的一颗卫星。对月亮认知的变化来自于（）。<br>A. 社会实践的发展<br>B. 科学家的主观设想<br>C. 对月亮理念的回忆<br>D. 意识自身的进化<br>正确答案：A</p>
</li>
<li><p>马克思在批判费尔巴哈时指出：“樱桃树被移植到这个地区，才有对于樱桃树的“感性确定性”，这说明（）。<br>A. 意识是客观世界的主观映象<br>B. 感性认识是对世界的正确认识<br>C. 人的认识只能来自于直接经验<br>D. 物质和意识完全同一<br>正确答案：A</p>
</li>
<li><p>1920年10月，一位印度传教士在印度加尔各答的丛林中发现两个狼哺育的女孩，这两个女孩被人称为“狼孩”。在大脑结构上，狼孩和同龄人没多大差别，但智力缺不足同龄人的十分之一。这说明（）。<br>A. 意识是人的本质<br>B. 意识来源于人脑<br>C. 社会实践在意识发展中具有决定作用<br>D. 意识形式上是客观的<br>正确答案：C</p>
</li>
<li><p>马克思指出，人在“劳动过程结束时得到的结果，在这个过程开始时就已经在劳动者的表象中存在着，即已经观念地存在着”，这体现了（）。<br>A. 意识活动具有目的性和计划性<br>B. 意识活动具有创造性<br>C. 意识活动能够调控人的行为和生理活动<br>D. 意识活动具有客观性<br>正确答案：A</p>
</li>
<li><p>麒麟是中国传统瑞兽，融合了狮头. 麋身. 牛尾. 马蹄，麒麟的形象塑造体现了（）。<br>A. 意识是人脑的机能和属性<br>B. 意识是客观世界的直观反映<br>C. 意识活动具有目的性和计划性<br>D. 意识活动具有创造性<br>正确答案：D</p>
</li>
<li><p>听乐队合奏时，听觉注意力能够集中到某件乐器的声音上，此时其它乐器演奏的声音虽然也会被耳朵接收，却会被大脑皮层抑制，其信号也就被弱化和边缘化了。这说明（）。<br>A. 意识能够根据一定的目的和要求确定反映什么. 不反映什么<br>B. 意识能够摆脱物质的纠缠自主创造内容<br>C. 大脑皮层是意识的内容来源<br>D. 意识能够在思维中构造出一个现实中没有的世界<br>正确答案：A</p>
</li>
<li><p>2021年3月11日，十三届全国人大四次会议表决通过了《关于国民经济和社会发展第十四个五年规划和2035年远景目标纲要的决议》。制定五年规划对我国经济社会发展具有重要意义，五年规划的制定说明意识（）。<br>A. 具有目的性和计划性<br>B. 能够直观反映现实<br>C. 在内容上是主观的<br>D. 能够任意对感性材料加工创造<br>正确答案：A</p>
</li>
<li><p>我国古典小说《三国演义》写诸葛亮用木马车送粮，而不是用汽车；《西游记》中的孙悟空能做到七十二变，可就是变不出计算机。这说明（）。<br>A. 人们的立场不同，所以认识就不同<br>B. 意识的内容来自客观事物<br>C. 古代文学家思想保守，不善于联想，想象力不够<br>D. 人们的思想认识被局限于现实，不能有丝毫逾越<br>正确答案：B</p>
</li>
<li><p>鲁迅在评价《红楼梦》时曾说：“就因读者的眼光而有种种：经学家看见《易》，道学家看见淫， 才子看见缠绵，革命家看见排满，流言家看见宫闱秘事……。”这说明（）。<br>A. 意识对现实的反映具有主体选择性<br>B. 间接经验不能带来新的认识<br>C. 人所见的现实不过是自身意识的重现<br>D. 文学作品不是客观实在<br>正确答案：A</p>
</li>
<li><p>2021年10月14日，“羲和号”卫星升空，中国正式进入探日时代。太阳与地球相伴亿万年，或许人类从诞生之日起，就对太阳产生了浓厚的兴趣，面对太阳产生无限遐想，中国古代就有“夸父追日”“后羿射日”等神话传说。这些传说的产生所体现的意识的能动作用是（）。<br>A. 现实性<br>B. 选择性<br>C. 创造性<br>D. 直观性<br>正确答案：C</p>
</li>
<li><p>2021中国科幻大会推出沉浸式科幻产业展，其时空语境建立在多年以后，以“科幻共同体”为主题，打造在一艘太空飞船一日生活的沉浸式科幻体验场景。对多年以后时空语境的设想体现了（）。<br>A. 意识是客观世界的客观映像<br>B. 意识能够在思维中构造一个现实中没有的观念世界<br>C. 意识能够脱离现实自由畅想<br>D. 时空可以在现实物质运动之外被感知<br>正确答案：B</p>
</li>
<li><p>“羲和号”开启了中国的探日时代，然而在此之前，许多中国科幻小说中已经有了对太阳的“详尽”描述，这体现了意识的（）。<br>A. 反映特性<br>B. 能动作用<br>C. 现实性<br>D. 客观性<br>正确答案：B</p>
</li>
<li><p>孙中山曾说：“吾心信其可行，则移山填海之难，终有成功之日”，这说明（）。<br>A. 所有的设想都能变为现实<br>B. 意识坚定程度决定了未来的现实<br>C. 意识具有调控人的行为. 影响实践结果的作用<br>D. 决心是目标实现的根本原因<br>正确答案：C</p>
</li>
<li><p>马克思曾指出：“通过实践创造对象世界，即改造无机界，人证明自己是有意识的类存在物”，这说明（）。<br>A. 意识的具有改造客观世界的能动作用<br>B. 意识能够直接创造现实<br>C. 意识是第一性的，无机界是派生的<br>D. 意识是实践的源泉<br>正确答案：A</p>
</li>
<li><p>俗话说“笑一笑，十年少”，苏东坡曾言“百年须笑三万六千场”，现代医学也证明由衷的笑有益于身心健康。从哲学上看，笑的作用体现了（）。<br>A. 意识的反映特性<br>B. 意识形式上的客观性<br>C. 意识活动能够调控人的行为和生理活动<br>D. 意识具有目的性和计划性<br>正确答案：C</p>
</li>
<li><p>一项医学研究表明乐观有助改善新陈代谢. 减轻炎症反应等，乐观者与悲观者相比，全因死亡风险低14%。这说明（）。<br>A. 心态决定着寿命的长短<br>B. 只有乐观的意识能够改造世界<br>C. 乐观的意识能够影响人的生理活动<br>D. 乐观的意识是对世界的正确反映<br>正确答案：C</p>
</li>
<li><p>列宁指出：“世界不会满足人，人决心以自己的行动来改变世界。”这种观点属于（）。<br>A. 将意识与物质相割裂的二元论<br>B. 认为意识具有第一性的唯心主义<br>C. 承认意识能动作用的辩证唯物主义<br>D. 认为环境决定人的机械唯物主义<br>正确答案：C</p>
</li>
<li><p>“人有多大胆，地有多大产”的观点的错误在于（）。<br>A. 夸大了矛盾的特殊性<br>B. 夸大了运动的绝对性<br>C. 夸大了真正的相对性<br>D. 夸大了意识的能动性<br>正确答案：D</p>
</li>
<li><p>“巧妇难为无米之炊”说明（）。<br>A. 发挥主观能动性必须以尊重客观规律为前提<br>B. 意识无法影响现实<br>C. 物质材料是发挥主观能动性的根本途径<br>D. 客观规律不可认识<br>正确答案：A</p>
</li>
<li><p>早在公元前1200年，人类就已经有了关于“永动机”的设想，不同时代. 不同国家的科学家们都曾为此付出探索，但“永动机”一直没有实现。“永动机”无法被制造说明（）。<br>A. 人类在客观规律面前无能为力<br>B. 主观能动性必须以客观规律为前提<br>C. 人类实践不能改造世界<br>D. 物质运动并不是绝对的<br>正确答案：B</p>
</li>
<li><p>马克思认为：“物质的力量只能用物质力量来摧毁；但是理论一经掌握群众，也会变成物质力量”，这说明（）。<br>A. 物质力量来源于意识<br>B. 意识活动具有创造性<br>C. 物质力量与意识力量二元对立<br>D. 通过实践，正确的认识能够变为物质力量<br>正确答案：D</p>
</li>
<li><p>2021世界人工智能大会在上海拉开帷幕，会场内，嘉宾与全球首个火星车数字人“祝融号”相谈甚欢，虚拟主持人“泠鸢”和大会主持人一起为观众来了一场“脱口秀”，人工智能的智能在本质上是（）。<br>A. 机器的自主意识<br>B. 机器在实践中形成的对现实的反映<br>C. 人的部分智能活动的机器化<br>D. 机器主观能动性的体现<br>正确答案：C</p>
</li>
<li><p>由谷歌开发的人工智能围棋软件AlphaGo连续打败世界围棋冠军，AlphaGo既可以结合树状图的长远推断，又可像人类的大脑一样自发学习进行直觉训练，这说明（）。<br>A. 人工智能已经能够取代人类智能<br>B. 智能机器具备了人类意识<br>C. 智能机器实质上是对的思维机制的模仿<br>D. 智能机器能够进行实践活动<br>正确答案：C</p>
</li>
<li><p>随着人工智能的兴起，互联网上掀起一场“你会和人工智能谈恋爱吗”的讨论。从哲学意识观角度看，这场讨论的根源是人们意识到人工智能很难具备（）。<br>A. 人类的外表<br>B. 人类的计算能力<br>C. 人类的语言<br>D. 人类的情感<br>正确答案：D</p>
</li>
<li><p>商场的导引机器人或者是餐饮行业所使用的服务机器人，或者是智能手机配备的智能语音机器人都能和人类进行简单的沟通，这说明（）。<br>A. 机器人完全具备理解自然语言的能力<br>B. 人工智能以人类语言为基础<br>C. 机器人能够对人类语言进行物化模仿<br>D. 机器人基本自主交往实践能力<br>正确答案：C</p>
</li>
<li><p>2021年9月25日，中国《新一代人工智能伦理规范》发布，为人工智能特定活动制定了伦理规范，这说明（）。<br>A. 人工智能发展不利于社会应及时终止<br>B. 在利用人工智能的同时要加强风险研判和防范<br>C. 人工智能和人类一样是自主的社会伦理主体<br>D. 人工智能具备行为后果意识和自律意识<br>正确答案：B</p>
</li>
<li><p>客观世界的万事万物都处于普遍联系之中，这属于（）的观点。<br>A. 形而上学唯物主义<br>B. 唯物辩证法<br>C. 形而上学唯心主义<br>D. 唯心主义历史观<br>正确答案：B</p>
</li>
<li><p>恩格斯指出：“当我们通过思维来考察自然界或人类历史或我们自己的精神活动的时候，首先呈现在我们眼前的，是一幅由种种联系和相互作用无穷无尽地交织起来的画面。”这说明（）。<br>A. 思维不能彻底认识世界<br>B. 整个世界是普遍联系的<br>C. 世界联系性是思维的产物<br>D. 联系只在思维逻辑中存在<br>正确答案：B</p>
</li>
<li><p>以下各项中，所反映出的辩证法原理，与“城门失火，殃及池鱼”相同的是（）。<br>A. 揠苗助长<br>B. 刮目相看<br>C. 唇亡齿寒<br>D. 刻舟求剑<br>正确答案：C</p>
</li>
<li><p>恩格斯指出，15世纪的自然科学“把自然界分解为各个部分，把各种自然过程分成一定门类……这种做法给我们留下一个习惯：把各种自然和自然过程孤立起来”。这种自然科学的局限是（）。<br>A. 忽略了事物自身的运动<br>B. 割裂了世界的普遍联系<br>C. 否定了物质的第一性<br>D. 排斥了意识的能动作用<br>正确答案：B</p>
</li>
<li><p>“任何一个有机体，在每一个瞬间都既是它本身又不是它本身；在每一瞬间它消化着外界供给的物质，并排泄出其他物质”，这种观点（）。<br>A. 否认相对静止的诡辩论<br>B. 承认联系与发展的唯物辩证法<br>C. 否认认识世界可能性的不可知论<br>D. 承认物质永恒不变的形而上学<br>正确答案：B</p>
</li>
<li><p>“联系是逻辑思维给世界打上的烙印”，这种观点的错误在于否认了联系的（）。<br>A. 客观性<br>B. 普遍性<br>C. 条件性<br>D. 多样性<br>正确答案：A</p>
</li>
<li><p>庄子在《逍遥游》中提出了“无所待”的境界，主张无所依赖的绝对自由。从辩证法的角度看，这种自由无法实现的原因是（）。<br>A. 每一种事物都处在普遍联系之中<br>B. 事物的发展经历两次否定<br>C. 发展具有曲折性<br>D. 联系具有多样性<br>正确答案：A</p>
</li>
<li><p>社会上总会流传一种“不祥年”的说法，认为每逢这样的年份就会有天灾人祸发生。这种说法的错误在于（）。<br>A. 主观臆想了事物的联系<br>B. 割裂了事物的普遍发展<br>C. 忽视了事物发展的外因<br>D. 否定了和谐状态的存在<br>正确答案：A</p>
</li>
<li><p>一些地方的人们掠夺性地滥挖草原上的甘草，虽获得了一定的经济利益，却破坏了草原植被，造成土地荒漠化，一遇大风，沙尘暴铺天盖地而至，给人们带来了巨大灾难。这些人的做法忽视了（）。<br>A. 矛盾的同一性的观点<br>B. 世界的物质统一性观点<br>C. 事物普遍联系的观点<br>D. 必然性和偶然性统一的观点<br>正确答案：C</p>
</li>
<li><p>铁人王进喜曾说：“有条件要上，没条件创造条件也要上”，王进喜对条件的认识体现了（）。<br>A. 人可以完全超越条件的限制<br>B. 人可以任意创造有利条件<br>C. 要善于利用条件又要善于化不利条件为有利条件<br>D. 条件对事物的发展只有支持作用<br>正确答案：C</p>
</li>
<li><p>“揠苗助长”的错误在于（）。<br>A. 没有发挥主观能动性<br>B. 没有看到否定在发展中的作用<br>C. 强行改变事物存在发展的条件<br>D. 只关注主要矛盾忽视次要矛盾<br>正确答案：C</p>
</li>
<li><p>在第二届联合国全球可持续交通大会上，中国移动5G智慧港口展区展出了无人货车有条不紊地在码头上穿梭装卸货物，5G港机远控. 5G岸桥远控正从大型远洋运输船上把集装箱卸下等智慧港口视频画面。5G网络的发展带来了万物互联的时代，体现了（）。<br>A. 联系具有普遍性，世界是一个整体<br>B. 联系具有主观性，人为世界创造了联系<br>C. 联系具有条件性，人能够任意改变事物发展的条件<br>D. 联系具有多样性，人只能把握事物的直接联系<br>正确答案：A</p>
</li>
<li><p>习近平指出：“从古丝绸之路的驼铃帆影，到航海时代的劈波斩浪，再到现代交通网络的四通八达，交通推动经济融通. 人文交流，使世界成了紧密相连的‘地球村’”。从哲学上看，交通的发展体现了（）。<br>A. 人为孤立的世界创造了联系<br>B. 整个世界是相互联系的整体<br>C. 世界联系的偶然性<br>D. 联系的条件是不能改变的<br>正确答案：B</p>
</li>
<li><p>“小河有水大河满，大河无水小河干”体现了（）。<br>A. 世界是普遍联系的<br>B. 事物发展要经过两次否定<br>C. 质变和量变的统一<br>D. 意识对物质具有反作用<br>正确答案：A</p>
</li>
<li><p>从条件的观点来看，“人有多大胆，地有多大产”属于（）。<br>A. 唯心主义无条件论<br>B. 机械唯物主义唯条件论<br>C. 辩证唯物主义无条件论<br>D. 古代朴素唯物主义唯条件论<br>正确答案：A</p>
</li>
<li><p>变化泛指事物发生的一切改变，（）则是事物变化中前进的. 上升的运动。<br>A. 发展<br>B. 联系<br>C. 运动<br>D. 静止<br>正确答案：A</p>
</li>
<li><p>“沉舟侧畔千帆过，病树前头万木春”表现了诗人刘禹锡昂扬进取的精神，也蕴含着（）的哲理。<br>A. 永恒真理能够被认识<br>B. 新事物必然战胜旧事物<br>C. 事物的发展是偶然的<br>D. 主观能动性决定着事物的发展<br>正确答案：B</p>
</li>
<li><p>“凡是在人类历史领域中是现实的，随着时间的推移，都会成为不合理的”，这种观点属于（）。<br>A. 认为“物方生方死”的诡辩论<br>B. 承认事物发展的辩证法<br>C. 在社会历史领领域坚持唯心的旧唯物主义<br>D. 追求永恒真理的形而上学<br>正确答案：B</p>
</li>
<li><p>随着2G、 3G用户加速向4G迁移，截至2019年7月，我国4G用户数达12.4亿，2G、3G逐渐成为历史，而随着5G技术的成熟，4G也终将成为历史，这说明（）。<br>A. 世界是相互联系的整体<br>B. 世界统一于意识<br>C. 世界是变化发展的<br>D. 人创造了事物的发展<br>正确答案：C</p>
</li>
<li><p>在近代推翻封建统治的民主革命过程中，曾发生过多次复辟现象，例如法国波旁王朝路易十八复辟，这些复辟最终又一次被民主革命的浪潮推翻。从哲学上看这是因为（）。<br>A. 复辟王朝作为后出现的新事物在初期不够强大<br>B. 民主革命作为先出现的旧事物力量强大<br>C. 民主革命作为符合历史前进方向的新事物必然战胜旧事物<br>D. 复辟王朝保留了旧的形式，因而是旧事物<br>正确答案：C</p>
</li>
<li><p>习近平指出：“实施创新驱动发展战略，是应对发展环境变化. 把握发展自主权. 提高核心竞争力的必然选择。”从哲学上看这是因为（）。<br>A. 新事物必然战胜旧事物<br>B. 运动是相对的，静止是绝对的<br>C. 事物的发展是偶然的<br>D. 人只能被动的适应环境变化<br>正确答案：A</p>
</li>
<li><p>抓住“风口”对于企业来说极其重要，把握住“风口”往往能够事半功倍。由此发展出一种观点，认为只要站在“风口”上，无论如何都能取得成功。这种观点的错误属于（）。<br>A. 唯条件论<br>B. 无条件论<br>C. 辩证唯物主义<br>D. 主观唯心主义<br>正确答案：A</p>
</li>
<li><p>（）回答了事物为什么会发展的问题。<br>A. 对立统一规律<br>B. 价值规律<br>C. 剩余价值规律<br>D. 社会基本矛盾运动规律<br>正确答案：A</p>
</li>
<li><p>“祸兮福之所倚，福兮祸之所伏”体现了（）。<br>A. 矛盾的同一性<br>B. 矛盾的斗争性<br>C. 矛盾的特殊性<br>D. 矛盾的普遍性<br>正确答案：A</p>
</li>
<li><p>“有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随”体现了（）。<br>A. 矛盾双方相互依存. 相互贯通<br>B. 矛盾双方相互斗争. 相互排斥<br>C. 矛盾双方有主次之分<br>D. 矛盾双方存在和谐的状态<br>正确答案：A</p>
</li>
<li><p>“狡兔死，良狗烹；飞鸟尽，良弓藏；敌国破，谋臣亡”体现了（）。<br>A. 矛盾双方的斗争促进双方力量变化<br>B. 矛盾双方中一方以另一方为前提<br>C. 矛盾双方的斗争性是有条件的<br>D. 矛盾双方的同一性是无条件的<br>正确答案：B</p>
</li>
<li><p>“万物各得其和以生，各得其养以成”，人与自然应和谐共生。和谐是（）。<br>A. 事物发展的根本动力<br>B. 矛盾的普遍形式<br>C. 矛盾的绝对同一<br>D. 矛盾的特殊表现形式<br>正确答案：D</p>
</li>
<li><p>在纪念辛亥革命110周年大会上的讲话中，习近平指出：“今天，经过长期奋斗，实现中华民族伟大复兴具备了更为完善的制度保证. 更为坚实的物质基础. 更为主动的精神力量。前景光明辽阔，但前路不会平坦。”强调“前路不会平坦”体现了（）。<br>A. 矛盾具有同一性<br>B. 和谐是矛盾的特殊形式<br>C. 矛盾具有普遍性<br>D. 矛盾具有特殊性<br>正确答案：C</p>
</li>
<li><p>“世界没有永动机，也没有一劳永逸自动解决所有问题的制度”，从矛盾的观点看，这是因为（）。<br>A. 矛盾的同一性是绝对的<br>B. 矛盾的斗争性是相对的<br>C. 矛盾无处不在无时不有<br>D. 矛盾的重点是和谐<br>正确答案：C</p>
</li>
<li><p>辛亥革命虽然没有完成实现民族独立. 人民解放的历史任务，但辛亥革命“永远是中华民族伟大复兴征程上一座巍然屹立的里程碑”，从矛盾的观点看，这体现了（）。<br>A. 矛盾的普遍性决定了事物的不同性质<br>B. 事物的性质具有主观性<br>C. 次要矛盾的次要方面决定事物的性质<br>D. 主要矛盾的主要方面决定事物的性质<br>正确答案：D</p>
</li>
<li><p>坚持把马克思主义同中国具体实际. 同中华优秀传统文化相结合的哲学基础是坚持（）。<br>A. 矛盾的共性与个性的有机统一<br>B. 矛盾的同一性和斗争性的有机统一<br>C. 主要矛盾和次要矛盾的有机统一<br>D. 主要方面和次要方面的有机统一<br>正确答案：A</p>
</li>
<li><p>古希腊学者欧布里德曾经提出一个悖论，其大意是：一粒谷粒不能成为谷堆，再加上一粒也不能成为谷堆； 所以如果现有的谷粒数不成为谷堆，那么在这个基础上每次只加一粒谷粒，则谷堆一直不能形成，这个悖论被称为“谷堆悖论”。“谷堆悖论”的错误在于（）。<br>A. 只看到了主要矛盾，忽略了次要矛盾<br>B. 只看到了共性，忽略了个性<br>C. 只看到了量变，忽视了质变<br>D. 只看到了偶然性，忽视了必然性<br>正确答案：C</p>
</li>
<li><p>“山积而高，泽积而长”体现了（）。<br>A. 共性与个性的统一<br>B. 同一性与斗争性的统一<br>C. 客观性与主观性的统一<br>D. 量变和质变的统一<br>正确答案：D</p>
</li>
<li><p>当前，全民健身理念逐步成为一种社会主流认识，然而在全民健身的热潮中存在着一些认知偏差，比如朋友圈病态追求“瘦身”. 盲目打卡高难度动作等。从哲学上看，这些行为违反了（）。<br>A. 两点论与重点论相统一<br>B. 共性与个性相统一<br>C. 世界的物质统一性原理<br>D. 适度原则<br>正确答案：D</p>
</li>
<li><p>在实际工作中，要注意掌握分寸，防止“过”或“不及”，其关键在于（）。<br>A. 抓住事物的主要矛盾<br>B. 确定事物的质<br>C. 认识事物的量<br>D. 把握事物的度<br>正确答案：D</p>
</li>
<li><p>《孙子兵法》：“投入亡地然后存，陷于死地而后生。”韩信据此背水一战，打败赵军；马谡据此屯兵山下，痛失街亭。同是根据兵法，造成的结果却不同，这说明（）。<br>A. 矛盾具有普遍性，两者没有共性<br>B. 具体问题具体分析是解决矛盾的关键<br>C. 兵法本身有正确和错误之分<br>D. 矛盾双方是既对立又统一的<br>正确答案：B</p>
</li>
<li><p>鲁迅在评《三国演义》时说：“至于写人，亦颇有失，以致欲显刘备之长厚而似伪，状诸葛之多智而近妖。”这一评述所蕴含的哲理是（）。<br>A. 矛盾双方会相互转化<br>B. 要把握事物的度<br>C. 对事物既要肯定又要否定<br>D. 要把事物看作一个整体<br>正确答案：B</p>
</li>
<li><p>杜甫诗曰：“挽弓当挽强，用箭当用长，射人先射马，擒贼先擒王。”这首诗蕴含的哲理是（）。<br>A. 量变引起质变<br>B. 承认矛盾客观性，正确对待矛盾<br>C. 既要看到矛盾主要方面，又要看到矛盾次要方面<br>D. 抓主要矛盾，抓中心，抓关键<br>正确答案：D</p>
</li>
<li><p>事物的发展是通过其内在矛盾运动以（）的方式而实现的。<br>A. 自我否定<br>B. 外部否定<br>C. 绝对否定<br>D. 他物否定<br>正确答案：A</p>
</li>
<li><p>恩格斯指出：“小生产只能同生产和社会狭隘的. 自然生产的界限相容，因而它发展到一定程度就产生消灭它自身的手段”。这说明否定（）。<br>A. 是矛盾运动的原因<br>B. 是外部自然的产物<br>C. 是事物自身的否定<br>D. 是一次完成的<br>正确答案：C</p>
</li>
<li><p>有许多观众认为黄梅戏唱腔比较柔美，不适合演绎荡气回肠的故事，但黄梅戏《江姐》导演吴琼则指出，只要声腔设计从人物出发，黄梅戏也能够唱出激昂旋律。导演的回答体现了（）。<br>A. 内容决定形式<br>B. 形式决定内容<br>C. 现实决定可能<br>D. 可能决定现实<br>正确答案：A</p>
</li>
<li><p>经典黄梅戏剧目《女驸马》同名国风连载漫画作品以韩再芬版舞台剧《女驸马》为蓝本，将黄梅戏的种子植入年轻人的“二次元”世界。从哲学角度看，这体现了（）。<br>A. 内容决定形式，有什么样的内容就有什么样的形式<br>B. 形式具有相对独立性，同一内容可以通过多种形式来展现<br>C. 原因决定结果，有什么样的原因就有什么样的结果<br>D. 结果具有相对独立性，同一原因可能导致多种结果<br>正确答案：B</p>
</li>
<li><p>探测行星大气中的氧气一直以来都是寻找地外生命的一个标准，恒星的紫外辐射也会导致行星上产生氧气分子，形成虚假生命信号。从哲学上看，“虚假生命信号”体现了（）。<br>A. 存在不表现本质的现象<br>B. 存在不表现为现象的本质<br>C. 本质深藏在现象背后不可认识<br>D. 现象可以区分为真象和假象<br>正确答案：D</p>
</li>
<li><p>利用光伏板收集太阳能是开发绿色新能源的重要举措。但由于光板的遮挡，不少草地因此杂草疯长，影响光板的使用效果，也易造成火灾，而人工除草费时费力。中国某光伏园区，通过牧羊成功解决了这一难题。牧羊和难题的解决体现了（）。<br>A. 现象与本质的辩证关系<br>B. 必然性与偶然性的辩证关系<br>C. 现实与可能的辩证关系<br>D. 原因与结果的辩证关系<br>正确答案：D</p>
</li>
<li><p>下列选项中，属于因果联系的是（）。<br>A. 风来雨至<br>B. 摩擦生热<br>C. 冬去春来<br>D. 电闪雷鸣<br>正确答案：B</p>
</li>
<li><p>马克思指出：“辩证法对每一种既成的形式都是从不断的运动中，因而也是从它的暂时性方面去理解”，这说明辩证法（）。<br>A. 不承认相对静止<br>B. 不承认和谐状态的存在<br>C. 不能把握事物的本质<br>D. 不承认永恒不变的绝对真理<br>正确答案：D</p>
</li>
<li><p>马克思主义物质观认为客观实在性是物质的唯一特性，从个性中看到了个性，从相对中找到绝对，从暂时中发现永恒。这体现了（）。<br>A. 唯物主义和唯心主义的统一<br>B. 可知论和不可之论的统一<br>C. 唯物论和辩证法的统一<br>D. 认识论和历史观的统一<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“所谓的主观辩证法，不过是在自然中到处发生作用的. 对立中的运动的反映。”这表明（）。<br>A. 主观辩证法不具备能动性<br>B. 主观辩证法与客观辩证法完全一致<br>C. 主观辩证法与客观辩证法本质上是统一的<br>D. 客观辩证法不能被认识<br>正确答案：C</p>
</li>
<li><p>马克思的辩证法同黑格尔的辩证法截然相反，正如马克思所说，“在黑格尔看来，思维过程……是现实事物的创造主，而现实事物只是思维过程的外部表现。”这体现了两种辩证法的相反之处在于（）。<br>A. 关于普遍性与特殊性关系认识上<br>B. 关于必然与偶然关系认识上<br>C. 关于否定-肯定-否定认识上<br>D. 关于主观辩证法与客观辩证法关系的认识上<br>正确答案：D</p>
</li>
<li><p>习近平强调，改革要“扭住关键”，“突出问题导向，体现了（）在改革和发展问题上的运用。<br>A. 抽象推理法<br>B. 直观分析法<br>C. 唯心辩证法<br>D. 矛盾分析法<br>正确答案：D</p>
</li>
<li><p>从个别事实中概括出一般性结论，由个别前提过渡到一般性结论的推理形式是（）。<br>A. 归纳<br>B. 演绎<br>C. 分析<br>D. 具体<br>正确答案：A</p>
</li>
<li><p>由一般性原则推导出个别结论的推理形式是（）。<br>A. 归纳<br>B. 演绎<br>C. 抽象<br>D. 分析<br>正确答案：B</p>
</li>
<li><p>在发现澳大利亚的黑天鹅之前，17世纪之前的欧洲人认为天鹅都是白色的，但随着第一只黑天鹅的出现，这个不可动摇的信念崩溃了。这说明（）。<br>A. 人类不可能认识事物的本质<br>B. 归纳所得结论还不充分可靠<br>C. 经验对认识真理没有任何帮助<br>D. 存在脱离共性的个性<br>正确答案：B</p>
</li>
<li><p>在思维中把认识对象分解为各个部分. 方面. 要素的思维方法是（）。<br>A. 分析<br>B. 抽象<br>C. 归纳<br>D. 历史<br>正确答案：A</p>
</li>
<li><p>在庆祝中国共产党成立100周年大会上，习近平强调要以史为鉴. 开创未来，这是（）的体现。<br>A. 理念思维能力<br>B. 系统思维能力<br>C. 历史思维能力<br>D. 底线思维能力<br>正确答案：C</p>
</li>
<li><p>系统思维以确认事物的（）为前提，进而具体把握事物的系统存在. 系统联系与系统规律。<br>A. 特殊的个性存在<br>B. 普遍有机联系<br>C. 外在的否定<br>D. 前进上升的运动<br>正确答案：B</p>
</li>
<li><p>习近平指出：“生物多样性使地球充满生机，也是人类生存和发展的基础。保护生物多样性有助于维护地球家园，促进人类可持续发展。”保护生态. 保护生物多样性是（）的具体体现。<br>A. 理念思维能力<br>B. 历史思维能力<br>C. 系统思维能力<br>D. 底线思维能力<br>正确答案：C</p>
</li>
<li><p>“凡事从坏处准备，努力争取最好的结果，这样才能有备无患. 遇事不慌，牢牢把握主动权”强调的是（）。<br>A. 系统思维能力<br>B. 底线思维能力<br>C. 历史思维能力<br>D. 创新思维能力<br>正确答案：B</p>
</li>
<li><p>底线思维能力体现了对（）的深刻认识和把握。<br>A. 适度原则<br>B. 共性与个性的关系<br>C. 否定是事物自身的否定<br>D. 具体问题具体分析<br>正确答案：A</p>
</li>
</ol>
<h3 id="多选-1"><a href="#多选-1" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>哲学基本问题主要包括两方面内容，即（）。<br>A. 存在和思维何者为第一性的问题<br>B. 存在和思维是否具有同一性的问题<br>C. 真理和价值的关系问题<br>D. 真理的绝对性和相对性关系问题<br>正确答案：AB</p>
</li>
<li><p>马克思主义物质概念的重大变革在于（）。<br>A. 通过实践的发现揭示了社会存在<br>B. 克服了旧唯物主义将物质概念局限在自然领域的缺陷<br>C. 把唯心主义从社会历史领域彻底驱除出去<br>D. 找到了物的具体形态并将之作为世界本源<br>正确答案：ABC</p>
</li>
<li><p>马克思主义的物质范畴具有丰富而深刻的理论意义，包括（）。<br>A. 坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限<br>B. 坚持了能动的反映论和可知论，批判了不可知论<br>C. 体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷<br>D. 体现了唯物主义自然观与历史唯物主义历史观的统一<br>正确答案：ABCD</p>
</li>
<li><p>2013年11月，习近平到湖南湘西考察时首次作出了“实事求是. 因地制宜. 分类指导. 精准扶贫”的重要指示。“精准扶贫”所蕴含的哲学方法论是（）。<br>A. 想问题. 办事情都要以时间. 地点. 条件为转移<br>B. 充分发挥主观能动性创造自然规律<br>C. 努力把握矛盾的普遍性，以共性掩盖个性<br>D. 具体问题具体分析<br>正确答案：AD</p>
</li>
<li><p>席勒说：“时间的步伐有三种：未来姗姗来迟，现在像箭一样飞逝，过去永远静立不动”，这体现了时间具有（）。<br>A. 持续性<br>B. 顺序性<br>C. 一维性<br>D. 广延性<br>正确答案：ABC</p>
</li>
<li><p>古人对龙的描述有九似，“角似鹿. 头似驼. 眼似兔. 项似蛇. 腹似蜃. 鳞似鱼. 爪似鹰. 掌似虎. 耳似牛”，龙的“九似”说明意识（）。<br>A. 是对现实的直观反映<br>B. 是对现实的能动反映<br>C. 能够创造出现实不存在的客观物质<br>D. 能够构建实现没有的观念世界<br>正确答案：BD</p>
</li>
<li><p>意识的能动作用主要表现在意识具有（）。<br>A. 目的性和计划性<br>B. 创造性<br>C. 指导实践改造客观世界的作用<br>D. 调控人的行为和生理活动的作用<br>正确答案：ABCD</p>
</li>
<li><p>意识具有指导实践改造世界的作用，改造世界意味着（）。<br>A. 强化客观世界的变化过程<br>B. 创造出世界上原来没有的东西<br>C. 创造和改变客观规律<br>D. 改变物质的根本属性和存在形式<br>正确答案：AB</p>
</li>
<li><p>鲁迅说过：“描神画鬼，毫无对证，本可以专靠神思，所谓‘天马行空’地挥写了。然而他们写出来的却是三只眼. 长脖子，也就是在正常的人体身上增加了眼睛一只，拉长了颈子二三尺而已。”这段话说明，人们头脑中的鬼神观念是（）。<br>A. 头脑中主观自生的<br>B. 人脑对客观世界的歪曲反映<br>C. 人脑对鬼神的虚幻反映<br>D. 可以从人世间找到它的原型<br>正确答案：BD</p>
</li>
<li><p>“先有计划，后做工作；先有图纸，后造房子”，这说明（）。<br>A. 意识决定物质，思维决定存在<br>B. 物质存在形态的多样性<br>C. 意识对物质的能动作用<br>D. 意识活动的目的性计划性<br>正确答案：CD</p>
</li>
<li><p>正确发挥人的主观能动性所需要的前提和条件有（）。<br>A. 从实际出发<br>B. 实践<br>C. 一定的物质条件<br>D. 天赋观念<br>正确答案：ABC</p>
</li>
<li><p>在庆祝中国共产党成立100周年大会上，习近平指出，要“坚持实事求是，从中国实际出发，洞察时代大势，把握历史主动，进行艰辛探索，不断推进马克思主义中国化时代化，指导中国人民不断推进伟大社会革命”。从哲学角度看，这是因为（）。<br>A. 尊重客观规律是正确发挥主观能动性的前提<br>B. 只有从实际出发，才能获得正确的认识进而形成正确的行动<br>C. 遵循历史规律和进程，才能适应时代发展<br>D. 把握时代脉搏和契机，才能真正成为历史的主人<br>正确答案：ABCD</p>
</li>
<li><p>习近平总书记在庆祝中国共产党成立100周年大会上指出：“一百年来，中国共产党弘扬伟大建党精神，在长期奋斗中构建起中国共产党人的精神谱系，锤炼出鲜明的政治品格。”从物质和意识的辩证关系来看，弘扬伟大建党精神的原因有（）。<br>A. 意识对物质就有能动的反作用<br>B. 意识具有调控人的行为和生理活动的作用<br>C. 意识具有指导实践改造客观世界的作用<br>D. 只有充分发挥主观能动性才能正确认识和改造世界<br>正确答案：AB</p>
</li>
<li><p>即使是目前最强大. 最先进的智能机器，也不能达到人类智能的层级，这是因为（）。<br>A. 人工智能不具备情感. 信念. 意志等人类意识形式<br>B. 人工智能不具备人类的社会属性<br>C. 人工智能难以具备理解自然语言真实意义的能力<br>D. 人工智能的计算能力远低于人类<br>正确答案：ABC</p>
</li>
<li><p>世界的物质统一性体现在（）。<br>A. 自然界是物质的<br>B. 人类社会本质上是物质的<br>C. 人的意识统一于物质<br>D. 物质是道与理念的现实投射<br>正确答案：ABC</p>
</li>
<li><p>联系是指事物内部各要素之间和事物之间（）的关系。<br>A. 相互影响<br>B. 相互制约<br>C. 相互作用<br>D. 相互割裂<br>正确答案：ABC</p>
</li>
<li><p>世界上的万事万物既作为个体事物存在，又作为联系中的事物存在，事物之间的联系具有（）的特点。<br>A. 客观性<br>B. 普遍性<br>C. 多样性<br>D. 条件性<br>正确答案：ABCD</p>
</li>
<li><p>联系具有客观性和普遍性，其中联系的普遍性的含义包括（）。<br>A. 任何事物都具有内在的结构性<br>B. 任何事物都不能孤立存在<br>C. 整个世界是相互联系的统一整体<br>D. 事物皆在理念之中<br>正确答案：ABC</p>
</li>
<li><p>在第二届联合国全球可持续交通大会上，习近平指出：“要大力发展智慧交通和智慧物流，推动大数据. 互联网. 人工智能. 区块链等新技术与交通行业深度融合，使人享其行. 物畅其流。”下列关于智慧交通的说法中，正确的有（）。<br>A. 说明事物的联系是人为创造的<br>B. 智慧交通的智慧之处在于具备真正的自主. 自觉的社会活动<br>C. 说明人可以利用和改变条件推动事物的发展<br>D. 体现了世界的普遍联系<br>正确答案：CD</p>
</li>
<li><p>联系具有多样性，事物联系的主要方式包括（）。<br>A. 直接联系与间接联系<br>B. 内部联系与外部联系<br>C. 本质联系与非本质联系<br>D. 必然联系与偶然联系<br>正确答案：ABCD</p>
</li>
<li><p>联系具有条件性，唯物辩证地看待条件要求我们（）。<br>A. 善于充分利用有利条件<br>B. 善于化不利条件为有利条件<br>C. 唯条件至上. 万事等待条件成熟<br>D. 超越客观规律创造条件<br>正确答案：AB</p>
</li>
<li><p>在新陈代谢的发展过程中，新事物是不可战胜的，这是因为（）。<br>A. 新事物的要素和功能适应了新的环境和条件<br>B. 旧事物的要素和功能不适应环境和客观条件<br>C. 新事物在旧事物的“母体”中孕育成熟<br>D. 在社会历史领域，新事物从根本上符合人民群众的利益和要求<br>正确答案：ABCD</p>
</li>
<li><p>唯物辩证法揭示了事物发展变化的一般规律，包括（）。<br>A. 对立统一关系规律<br>B. 量变质变规律<br>C. 否定之否定规律<br>D. 永恒轮回规律<br>正确答案：ABC</p>
</li>
<li><p>“有了开放就有竞争，有了竞争才有学习，有了学习才有发展。”从对立统一规律的角度看，这是因为（）。<br>A. 矛盾双方不存在和谐状态<br>B. 矛盾双方只存在对抗形式的斗争<br>C. 同一性使矛盾双方相互吸取有利于自身的因素，在相互作用中得到发展<br>D. 矛盾双方的斗争性促进矛盾双方力量的变化<br>正确答案：CD</p>
</li>
<li><p>矛盾的特殊性是指（）。<br>A. 每个具体事物的矛盾各有特点<br>B. 每一矛盾的各个方面各有不同<br>C. 同一矛盾的不同阶段有不同特点<br>D. 矛盾无时不在<br>正确答案：ABC</p>
</li>
<li><p>关于矛盾的共性与个性，下列说法中正确的是（）。<br>A. 矛盾的共性是有条件的. 相对的<br>B. 矛盾的个性是无条件的. 绝对的<br>C. 没有离开个性的共性<br>D. 没有离开共性的个性<br>正确答案：CD</p>
</li>
<li><p>“不积跬步，无以至千里；不积小流，无以成江海”体现了（）。<br>A. 量变是质变的必要准备<br>B. 质变是量变的必要准备<br>C. 量变是质变的必然结果<br>D. 质变是量变的必然结果<br>正确答案：AD</p>
</li>
<li><p>唯物辩证法的否定观所揭示的否定的科学内涵包括（）。<br>A. 否定是事物的自我否定<br>B. 否定是事物发展的环节<br>C. 否定是新旧事物联系的环节<br>D. 辩证否定的实质是“扬弃”<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，与“麦粒-麦株-麦粒”所反映的哲学原理相同的有（）。<br>A. 团结-批评-团结<br>B. 婴儿-青年-老年<br>C. 否定-肯定-否定<br>D. 自然唯物主义-唯心主义-辩证唯物主义<br>正确答案：ACD</p>
</li>
<li><p>在社会主义条件下，在推进中国特色社会主义事业进程中坚持和发扬唯物辩证法精神就是要（）。<br>A. 坚持解放思想. 实事求是. 与时俱进，用发展着的马克思主义指导新的实践<br>B. 坚持改革开放，不断推进社会主义制度的自我完善<br>C. 推进党的自我革命，始终保持党的先进性和纯洁性<br>D. 提倡创新创造， 反对因循守旧. 墨守成规<br>正确答案：ABCD</p>
</li>
<li><p>归纳和演绎是人们认识世界的重要逻辑方法，以下关于归纳与演绎的关系的说法中，正确的有（）。<br>A. 归纳是演绎的基础<br>B. 演绎为归纳提供理论依据<br>C. 归纳和演绎相互补充<br>D. 归纳和演绎互为前提<br>正确答案：ABCD</p>
</li>
<li><p>马克思认为思想进程不过是历史进程的反映，“这种反映是经过修正的，然而是按照现实的历史过程本身的规律修正的”，这里的“修正”是指（）。<br>A. 抛弃偶然性，抓住必然性<br>B. 抛弃偏差，抓住基本方向和基本线索<br>C. 抛弃历史现实，进行主观创造<br>D. 抛弃历史细节，抓住主流<br>正确答案：ABD</p>
</li>
<li><p>关于逻辑与历史的关系，下列说法中正确的有（）。<br>A. 历史的东西是逻辑的东西的基础<br>B. 逻辑的进程和历史的进程具有内在统一性<br>C. 逻辑的东西能够把握历史的主流<br>D. 逻辑与历史的统一是包含差异的统一<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，属于现代科学思维方法的有（）。<br>A. 控制方法<br>B. 信息方法<br>C. 系统方法<br>D. 模型方法<br>正确答案：ABCD</p>
</li>
<li><p>辩证思维方法和现代科学思维方法是认识世界的重要方法，关于二者的关系，下列说法中正确的有（）。<br>A. 辩证思维方法是现代科学思维方法的方法论前提<br>B. 现代科学思维方法是辩证思维方法的方法论前提<br>C. 辩证思维方法要自觉以现代科学思维方法为指导<br>D. 现代科学思维方法丰富了辩证思维方法<br>正确答案：AD</p>
</li>
<li><p>创新能力是指破除迷信. （）的能力。<br>A. 超越陈规<br>B. 善于因时制宜<br>C. 知难而进<br>D. 开拓创新<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>哲学是系统化. 理论化的世界观。<br>对</p>
</li>
<li><p>解决其他一切哲学问题的前提和基础是对哲学基本问题的回答。<br>对</p>
</li>
<li><p>物质世界的运动是相对的，静止是绝对的。<br>错</p>
</li>
<li><p>静止的相对性是物质运动的稳定性. 有条件性的体现。<br>对</p>
</li>
<li><p>运动的绝对性是物质运动的稳定性. 有条件性的体现。<br>错</p>
</li>
<li><p>没有离开运动的时空，只有在物质运动中才能感受到时空，这说明时空只是人们对物质运动的主观感受。<br>错</p>
</li>
<li><p>从哲学上看，世界二重化为主观世界和客观世界，主观世界是实践活动的产物。<br>对</p>
</li>
<li><p>意识是主观世界的客观映像。<br>错</p>
</li>
<li><p>意识是自然界长期发展的产物，也是社会历史发展的产物。<br>对</p>
</li>
<li><p>意识是人脑这样一种特殊物质的机能和属性。<br>对</p>
</li>
<li><p>意识的内容是客观的，形式是主观的。<br>对</p>
</li>
<li><p>物质决定意识，意识对物质具有反作用，这种反作用就是意识的能动作用。<br>对</p>
</li>
<li><p>物质决定意识，这说明人在认识客观世界时，客观世界有什么就只能反映什么，无法进行选择。<br>错</p>
</li>
<li><p>意识具有目的性和计划性，人的整个实践过程就是围绕意识活动所构建的目标进行的，这说明意识决定了人的实践活动。<br>错</p>
</li>
<li><p>意识是对客观世界的反映，鬼神在意识中存在因而也是客观存在的。<br>错</p>
</li>
<li><p>物质是第一性的，意识是派生的，这意味着意识只能在自身范围内活动，不能对物质产生影响。<br>错</p>
</li>
<li><p>观念的东西可以变为客观现实。<br>对</p>
</li>
<li><p>“笑一笑十年少，愁一愁白了头”是主观唯心主义错误思想在心理上的重要体现。<br>错</p>
</li>
<li><p>规律是事物变化发展过程中本身所固有的内在的. 本质的. 必然的联系。<br>对</p>
</li>
<li><p>人在客观世界面前不是无能为力的，人可以创造和改变客观规律以实现自己的目标。<br>错</p>
</li>
<li><p>人是历史的主人，这意味着人可以按照自己的意识，随心所欲的创造历史。<br>错</p>
</li>
<li><p>人只有在掌握客观规律的基础上，才能正确认识世界，有效地改造世界。<br>对</p>
</li>
<li><p>意识是客观世界的反映，遵循感觉即是掌握真理。<br>错</p>
</li>
<li><p>强调规律的客观性即是说人在规律面前是无能为力的。<br>错</p>
</li>
<li><p>正确的认识只有通过实践才能变为物质力量。<br>对</p>
</li>
<li><p>认识只要进行实践就能改变世界。<br>错</p>
</li>
<li><p>人工智能，就是人的部分智能活动机器化。<br>对</p>
</li>
<li><p>人工智能的出现表明人类意识已经能够把意识活动部分地从人脑分离出来。<br>对</p>
</li>
<li><p>人工智能是人的意识的物化，是意识器官功能的延伸。<br>对</p>
</li>
<li><p>社会性是人的意识所固有的本质属性。<br>对</p>
</li>
<li><p>人工智能在一定程度上可以承担某种社会功能。<br>对</p>
</li>
<li><p>随着人工智能的发展，机器人将真正具备自立. 自主. 自觉的社会活动。<br>错</p>
</li>
<li><p>马克思主义认为世界没有所谓共同的本原或本质。<br>错</p>
</li>
<li><p>世界的物质统一性否定了世界的多样性。<br>错</p>
</li>
<li><p>世界的物质统一性是由哲学和自然科学的长期和持续的发展所证明的。<br>对</p>
</li>
<li><p>世界物质统一性原理是辩证唯物主义最基本. 最核心的观点，是马克思主义的基石。<br>对</p>
</li>
<li><p>联系和发展的观点集中体现了唯物辩证法的总特征。<br>对</p>
</li>
<li><p>世界上的万事万物既作为个体事物存在，又作为联系中的事物存在。<br>对</p>
</li>
<li><p>事物的联系是事物本身所固有的。<br>对</p>
</li>
<li><p>在联系的观点上坚持唯物论就是要坚持联系的客观性。<br>对</p>
</li>
<li><p>世界上的事物是多样的，事物之间的联系也是多样的。<br>对</p>
</li>
<li><p>条件往往对人的实践起到支持或制约作用，条件是可以改变和创造的。<br>对</p>
</li>
<li><p>条件是对事物存在和发展发生作用的诸要素的总和。<br>对</p>
</li>
<li><p>条件对事物发展和人的活动只具有支持和促进作用。<br>错</p>
</li>
<li><p>世界是发展变化的，尽管在变化过程中有种种倒退，但前进的发展终究会实现。<br>对</p>
</li>
<li><p>物质世界的发展特别是人类社会的发展，其实质是新事物的产生和旧事物的灭亡。<br>对</p>
</li>
<li><p>判断一个事物是新事物还是旧事物的标准是出现时间的先后。<br>错</p>
</li>
<li><p>新事物是指合乎历史前进方向. 具有远大前途的东西。<br>对</p>
</li>
<li><p>新事物战胜旧事物必然采取革命的形式。<br>错</p>
</li>
<li><p>旧事物就是从来都不符合历史发展要求的事物。<br>错</p>
</li>
<li><p>在社会历史领域，新事物是社会上先进的. 富有创造力的人们创造性活动的产物，能够得到人民群众的拥护，因而必然战胜旧事物。<br>对</p>
</li>
<li><p>对立统一规律是事物发展的根本规律。<br>对</p>
</li>
<li><p>矛盾着的双方相互依存. 相互贯通的性质和趋势即是矛盾的同一性。<br>对</p>
</li>
<li><p>矛盾着的对立面相互排斥. 相互分离的性质和趋势即是矛盾的斗争性。<br>对</p>
</li>
<li><p>矛盾的双方是相互贯通的，在一定条件下可以相互转化。<br>对</p>
</li>
<li><p>矛盾的同一性是有条件的. 相对的。<br>对</p>
</li>
<li><p>矛盾的斗争性是有条件的. 相对的。<br>错</p>
</li>
<li><p>没有矛盾的同一性就没有矛盾的斗争性，没有矛盾的斗争性就没有矛盾的同一性。<br>对</p>
</li>
<li><p>对抗性矛盾和非对抗性矛盾是矛盾斗争的两种基本形式。<br>对</p>
</li>
<li><p>矛盾的斗争性寓于同一性之中，同一性通过斗争性来体现。<br>对</p>
</li>
<li><p>矛盾同一性是事物存在和发展的前提。<br>对</p>
</li>
<li><p>矛盾的同一性规定着事物转化的可能和发展的趋势。<br>对</p>
</li>
<li><p>事物之所以能够转化是因为事物外部矛盾双方具有相互贯通的关系。<br>错</p>
</li>
<li><p>事物的发展方向是有规律地向自己的对立面转化。<br>对</p>
</li>
<li><p>运用矛盾的同一性和斗争性原理指导实践，还要正确认识和谐对事物发展的作用，和谐是相对的. 有条件的。<br>对</p>
</li>
<li><p>社会和谐. 人与自然的和谐，都是在不断解决矛盾的过程中实现的。<br>对</p>
</li>
<li><p>事物的性质是由主要矛盾的主要方面所决定的。<br>对</p>
</li>
<li><p>矛盾的共性和个性. 绝对和相对的道理，是关于事物矛盾问题的精髓，是正确理解矛盾学说的关键。<br>对</p>
</li>
<li><p>质变体现了事物发展的渐变性和连续性。<br>错</p>
</li>
<li><p>量变质变规律是事物发展渐进性和飞跃性统一的体现。<br>对</p>
</li>
<li><p>否定之否定规律揭示了事物自己发展自己的完整过程和本质。<br>对</p>
</li>
<li><p>否定因素是事物内部促使现存事物灭亡的因素。<br>对</p>
</li>
<li><p>事物的自我发展要经历两次否定. 三个阶段。<br>对</p>
</li>
<li><p>事物经过两次否定完成是矛盾得到根本解决，达到事物发展的最终终点。<br>错</p>
</li>
<li><p>内容是构成事物的一切要素的总和。<br>对</p>
</li>
<li><p>形式是指把诸要素统一起来的结构或表现内容的方式。<br>对</p>
</li>
<li><p>内容是事物存在的基础，对形式具有决定作用。<br>对</p>
</li>
<li><p>本质是事物的根本性质，是构成事物的诸要素之间的内在联系。<br>对</p>
</li>
<li><p>现象是事物的外部联系和表面特征，是事物本质的外在表现。<br>对</p>
</li>
<li><p>事物的本质深藏于事物的内部，只能通过感性来感知。<br>错</p>
</li>
<li><p>假象是不表现本质的现象。<br>错</p>
</li>
<li><p>原因和结果的区分既是确定的又是不确定的。<br>对</p>
</li>
<li><p>现实事物的发展可以只表现为纯粹必然的情况。<br>错</p>
</li>
<li><p>偶然性之所以为偶然性，是因为它脱离了必然性。<br>错</p>
</li>
<li><p>现实是相互联系着的实际存在的事物的综合。<br>对</p>
</li>
<li><p>可能是指包含在事物中的预示事物发展前途的种种趋势。<br>对</p>
</li>
<li><p>发展就是现实与可能相互转化的过程。<br>对</p>
</li>
<li><p>唯物辩证法是马克思主义世界观和方法论的核心内容，为人们认识世界和改造世界提供了根本方法。<br>对</p>
</li>
<li><p>唯物辩证法在本质上是批判的和革命的。<br>对</p>
</li>
<li><p>客观辩证法是指人从客观条件出发认识事物所用的思维方法。<br>错</p>
</li>
<li><p>客观辩证法与主观辩证法在形式上是统一的，在本质上是不同的。<br>错</p>
</li>
<li><p>唯物辩证法既是科学的世界观，也是我们认识世界和改造世界的基本方法论。<br>对</p>
</li>
<li><p>矛盾分析法的核心要求是善于分析矛盾的特殊性，做到具体问题具体分析。<br>对</p>
</li>
<li><p>马克思主义的活的灵魂就在于具体地分析具体的情况。<br>对</p>
</li>
<li><p>同分析与综合相比，归纳与演绎是一种更为深刻的思维方法。<br>错</p>
</li>
<li><p>综合就是在分析的基础上，再把各个因素机械拼凑起来。<br>错</p>
</li>
<li><p>分析和综合的实质，就是建立在调查研究基础上的矛盾分析法。<br>对</p>
</li>
<li><p>分析是综合的基础，综合是分析的完成。<br>对</p>
</li>
<li><p>辩证思维能力是科学思维能力的根本要求和集中体现。<br>对</p>
</li>
<li><p>辩证思维能力就是以唯物辩证法为指导，发现矛盾. 分析矛盾. 解决矛盾，把握本质. 遵循规律. 推动工作的能力。<br>对</p>
</li>
<li><p>战略思维能力之所以重要，是因为它是一种充分发挥人的主观能动性. 积极性和创造性的思维活动。<br>对</p>
</li>
<li><p>当今世界，创新已经成为社会进步的主导力量和重要源泉。<br>对</p>
</li>
<li><p>“要胸怀两个大局，一个是中华民族伟大复兴的战略全局，一个是世界百年未有之大变局”是系统思维能力运用的光辉典范。<br>对</p>
</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="单选-2"><a href="#单选-2" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>（）的观点是马克思主义的基本观点。<br>A. 实践<br>B. 真理<br>C. 价值<br>D. 意识<br>正确答案：A</p>
</li>
<li><p>在（）中，马克思系统论述了实践的观点，揭示了科学实践观的基本内容。<br>A. 《黑格尔法哲学批判》<br>B. 《论犹太人问题》<br>C. 《关于费尔巴哈的提纲》<br>D. 《反杜林论》<br>正确答案：C</p>
</li>
<li><p>马克思指出：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”这凸显了（）的重要性。<br>A. 物质<br>B. 意识<br>C. 真理<br>D. 实践<br>正确答案：D</p>
</li>
<li><p>实践是“主观见之于客观的东西”，这属于（）的观点。<br>A. 主观唯心主义实践观<br>B. 机械唯物主义实践观<br>C. 直观唯物主义实践观<br>D. 辩证唯物主义实践观<br>正确答案：D</p>
</li>
<li><p>实践的（）特征把它和主观认识活动区分开来。<br>A. 自觉能动性<br>B. 客观实在性<br>C. 社会历史性<br>D. 创造性<br>正确答案：B</p>
</li>
<li><p>“任何历史记载都应当从这些自然基础以及它们在历史进程中由于人们的活动而发生的变更出发”，这说明（）。<br>A. 实践能够引起客观世界的变化<br>B. 历史是人的主观创造<br>C. 自然环境对人具有决定作用<br>D. 人的改变了自然的运行规律<br>正确答案：A</p>
</li>
<li><p>“环境的改变和人的活动的一致，只能被看做是并合理地理解为变革的实践”，这说明实践具有（）。<br>A. 自觉能动性<br>B. 客观实在性<br>C. 社会性<br>D. 历史性<br>正确答案：B</p>
</li>
<li><p>马克思指出：“动物只是按照它所属的那个种的尺度和需要来建造，而人却懂得按照任何一个种的尺度来进行生产，并且懂得怎样处处都把内在的尺度运用到对象上去。”这说明相比于动物，人的实践具有（）。<br>A. 客观实在性<br>B. 社会性<br>C. 自觉能动性<br>D. 历史性<br>正确答案：C</p>
</li>
<li><p>“在曼彻斯特只看见一些工厂和机器，而100年前在那里只能看见一些脚踏纺车和织布机。”从脚踏纺车到机器工厂的发展说明实践活动具有（）。<br>A. 主观性<br>B. 社会历史性<br>C. 反映性<br>D. 特殊性<br>正确答案：B</p>
</li>
<li><p>相传万户是中国第一个试图利用火箭飞行的人，他设想利用火箭的推力，加上风筝的力量飞起，但火箭在实验过程中爆炸，万户也为此献出了生命。从哲学角度看，万户的失败体现了（）。<br>A. 实践不具备改造世界的能力<br>B. 实践的目的正确与否决定实践的成败<br>C. 实践受到社会历史条件的制约<br>D. 实践是人不断摆脱客观规律的活动<br>正确答案：C</p>
</li>
<li><p>2021年6月，广西首个5G+无人驾驶集装箱卡车作业港口项目在北部湾港北海港区启动。无人驾驶集装箱卡车的出现说明（）。<br>A. 机器成为实践的主体<br>B. 人工智能取代人类意识<br>C. 人能够通过工具延伸自己的肢体功能<br>D. 实践不具备能动性<br>正确答案：C</p>
</li>
<li><p>（）实践是人类最基本的实践活动。<br>A. 物质生产<br>B. 科学实验<br>C. 社会政治<br>D. 文化传播<br>正确答案：A</p>
</li>
<li><p>《孙子兵法》指出：“谋定而后动，知止而有得”，从哲学角度看，这说明（）。<br>A. “谋”是“动”的根本目的<br>B. “谋”是“动”的根本来源<br>C. 人的“动”具有自觉能动性<br>D. 人的“谋”是世界的本源<br>正确答案：C</p>
</li>
<li><p>联结人与自然的中介是（）。<br>A. 社会关系<br>B. 社会意识<br>C. 实践<br>D. 地理环境<br>正确答案：C</p>
</li>
<li><p>把科学的实践观第一次引入认识论是（）。<br>A. 费尔巴哈哲学的功绩<br>B. 黑格尔哲学的功绩<br>C. 马克思主义哲学的功绩<br>D. 法国唯物主义哲学的功绩<br>正确答案：C</p>
</li>
<li><p>一种活动能否被称为实践活动关键是看它（）。<br>A. 是否有正确意识的指导<br>B. 是否有合适的中介<br>C. 是否以自然界为客体<br>D. 是否超出了纯粹意识活动<br>正确答案：D</p>
</li>
<li><p>（）构成全部社会生活的基础。<br>A. 社会政治实践<br>B. 科学文化实践<br>C. 物质生产实践<br>D. 纯粹意识活动<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯指出：“如果在全部意识形态中，人们和他们的关系就像在照相机中一样是倒立成像的，那么这种现象也是从人们生活的历史过程中产生的”，这说明（）。<br>A. 意识只能歪曲地认识世界<br>B. 意识是实践的基础<br>C. 实践是意识的基础<br>D. 实践不能产生正确的认识<br>正确答案：C</p>
</li>
<li><p>列宁曾说：“我的朋友，理论是灰色的，而生活之树是常青的”，这说明（）。<br>A. 理论不能指导实践<br>B. 理论一旦形成就没有任何变化<br>C. 实践是认识的基础和来源<br>D. 生活瞬息万变不可把握<br>正确答案：C</p>
</li>
<li><p>习近平指出：“我们党现阶段提出和实施的理论和路线方针政策，之所以正确，就是因为它们都是以我国现时代的社会存在为基础的。”这说明（）。<br>A. 实践是认识的来源<br>B. 来自实践的认识都是正确的<br>C. 间接经验不能带来任何知识<br>D. 只有正确的认识具有能动性<br>正确答案：A</p>
</li>
<li><p>杜甫的诗句“读书破万卷，下笔如有神”体现了（）。<br>A. 书本是真知的源头<br>B. 人可以通过书本获得知识<br>C. 认识世界只是需要间接经验<br>D. 书本是知识的直接经验部分<br>正确答案：B</p>
</li>
<li><p>黑格尔说过，对于同一句格言，出自饱经风霜的老年人之口与出自缺乏阅历的青少年之口，其内涵是不同的。这句话说明（ ）。<br>A. 实践是认识的源头活水<br>B. 年龄是检验认识真理性的标准<br>C. 认识与世界不具备统一性<br>D. 语言不能充当实践的中介<br>正确答案：A</p>
</li>
<li><p>恩格斯说：“社会一旦有技术上的需要，这种需要就会比十所大学更能把科学推向前进。”这说明（）。<br>A. 实践的需要推动认识的产生和发展<br>B. 大学不能推动科技前进<br>C. 社会意识决定社会需要的产生<br>D. 间接经验不能推动科学发展<br>正确答案：A</p>
</li>
<li><p>古代水利工程. 建筑. 航海战争的需要催生了古代天文学. 数学和力学；生态环境保护的需要推动了生态文明理论的发展。这说明（）。<br>A. 科学文化实践是决定着社会的基本性质和面貌<br>B. 社会政治实践是人类最基本的实践活动<br>C. 实践的需要是推动认识发展之根本<br>D. 认识是实践的根本目的<br>正确答案：C</p>
</li>
<li><p>随着“羲和号”成功入轨，我国太空探测迎来“探日时代”，将进一步提升对太阳的认识。从哲学的角度来看，这说明（）。<br>A. 实践需要推动认识的产生和发展<br>B. 认识是实践的根本目的<br>C. 认识是检验实践的唯一标准<br>D. 实践为认识的发展提供了手段和条件<br>正确答案：D</p>
</li>
<li><p>柏拉图认为，人在出生之前，其灵魂已经分有了普遍的理念，知识就是对这些理念的回忆。这属于（）。<br>A. 唯心主义认识路线<br>B. 旧唯物主义反映论<br>C. 辩证唯物主义认识论<br>D. 机械唯物主义认识论<br>正确答案：A</p>
</li>
<li><p>有一种观点认为既然意识是物质的反映，那么关于鬼神是否存在就要看是否有人见到过或听到过鬼神，从认识论的角度看，这属于（）<br>A. 先验论<br>B. 理念论<br>C. 直观反映论<br>D. 能动反映论<br>正确答案：C</p>
</li>
<li><p>杭州五年级的学生发现了《西游记》的漏洞：从东土大唐到西域，吃的似乎都是江淮美食，而吴承恩正是淮安人，从认识论的角度看，这个漏洞说明（）。<br>A. 认识必然要以客观事物为原型和摹本<br>B. 认识只能受现实束缚而不能有丝毫逾越<br>C. 个人喜好是认识的根本来源<br>D. 认识是具有创造性的活动<br>正确答案：A</p>
</li>
<li><p>近年来人工智能快速发展，从“智能服务员”到无人港口，人工智能正在改变人的生活，而实际上在人工智能还没有成为现实的时候，关于人工智能的思想与模型就已经出现在科幻小说的场景中和科学家的论文里，这说明（）。<br>A. 意识是实践的基础<br>B. 认识是理念的重现<br>C. 认识改变世界而不是反映世界<br>D. 认识具有能动性和创造性<br>正确答案：D</p>
</li>
<li><p>认识运动的第一次飞跃指的是（）。<br>A. 从理念到自我意识<br>B. 从意识到现实<br>C. 从感性认识到理性认识<br>D. 从非理性因素到理性因素<br>正确答案：C</p>
</li>
<li><p>列宁称感性认识为“生动的直观”，这体现了感性认识的突出特点为（）。<br>A. 创造性<br>B. 能动性<br>C. 直接性<br>D. 正确性<br>正确答案：C</p>
</li>
<li><p>我们在意识中把通过眼. 耳. 鼻. 舌. 身各种感官感觉到一个梨子的各种属性联系起来形成了关于这个梨子的感性形象，这种意识形式属于感性认识中的（）。<br>A. 感觉<br>B. 抽象<br>C. 知觉<br>D. 分析<br>正确答案：C</p>
</li>
<li><p>“感觉到了的东西，我们不能立即理解它，只有理解了的东西，才能更深刻地感觉它。”这一观点说明（）。<br>A. 感性认识对人认识事物本质没有实际意义<br>B. 感性认识是整个认识的起点<br>C. 感性认识是认识的初级阶段，理性认识是认识的高级阶段<br>D. 感性认识的局限性<br>正确答案：C</p>
</li>
<li><p>在实际工作中，片面夸大感性经验的作用，轻视理论，把局部经验当作普遍真理到处搬用，这倾向属于（）。<br>A. 本本主义<br>B. 经验主义<br>C. 教条主义<br>D. 人本主义<br>正确答案：B</p>
</li>
<li><p>恩格斯说：“鹰比人看得远得多，但是人的眼睛识别的东西远胜于鹰。”人的感官的识别能力高于动物，除了人脑及感官发育得更完善之外，还因为（）。<br>A. 人不仅有理性还有非理性<br>B. 人不仅有感觉还有思维<br>C. 人不仅有直觉还有想象<br>D. 人不仅有生理机能还有心理活动<br>正确答案：B</p>
</li>
<li><p>恩格斯说：“人的智力是按照人如何学会改造自然界而发展的。”这说明（）。<br>A. 自然界是认识发展的动力<br>B. 实践是认识发展的动力<br>C. 意识是对世界的直观反映<br>D. 自然界是认识与实践的唯一客体<br>正确答案：B</p>
</li>
<li><p>人们所从事的政治活动. 社会改革. 社会革命都属于（）。<br>A. 物质生产实践<br>B. 意识活动实践<br>C. 社会政治实践<br>D. 科学文化实践<br>正确答案：C</p>
</li>
<li><p>有人认为只有写到书本上的理论才是真实可靠的，便不顾实际情况，生搬硬套书本上的理论，这犯了（）的错误。<br>A. 经验主义<br>B. 直观被动反映论<br>C. 唯心主义先验论<br>D. 教条主义<br>正确答案：D</p>
</li>
<li><p>改革开放以来，大约有上千条新词汇产生，比如外资企业. 知识经济. 电子邮件. 信用卡. 再就业等等。从哲学上看，这一事实说明（）。<br>A. 理性认识依赖于感性认识<br>B. 科学理论对实践具有指导作用<br>C. 意识是人脑的机能<br>D. 意识是客观存在的反映<br>正确答案：D</p>
</li>
<li><p>真理观中的首要问题是（）。<br>A. 真理是不是绝对的<br>B. 真理是不是与价值相统一<br>C. 真理是不是客观的<br>D. 真理能不能被认识<br>正确答案：C</p>
</li>
<li><p>认为真理是“观念与主体感觉相符合”的观点的局限性在于（）。<br>A. 否认了真理的相对性<br>B. 否认了真理的主观形式<br>C. 否认了真理的客观性<br>D. 否认了真理的绝对性<br>正确答案：C</p>
</li>
<li><p>认为“真理是‘绝对理念’的自我显现”的真理观属于（）。<br>A. 客观唯心主义真理观<br>B. 主观唯心主义真理观<br>C. 机械唯物主义真理观<br>D. 辩证唯物主义真理观<br>正确答案：A</p>
</li>
<li><p>马克思主义真理观与旧唯物主义真理观的不同之处在于，它认为真理与客观事物之间的符合关系是建立在（）的基础上的<br>A. 意识<br>B. 理念<br>C. 自然界<br>D. 实践<br>正确答案：D</p>
</li>
<li><p>认识成为真理的先决条件在于（）。<br>A. 是否采取理性判断的形式<br>B. 是否能形成自圆其说的推理<br>C. 是否有感性认识作支撑<br>D. 是否正确反映对象的本质和规律<br>正确答案：D</p>
</li>
<li><p>列宁指出：“主观主义和辩证法的区别在于：在（客观的）辩证法中，相对和绝对的差别也是相对的。”从真理的角度看，这说明（）。<br>A. 真理都是相对主体而言的<br>B. 真理在本质上不具备绝对性<br>C. 真理是绝对性与相对性的统一<br>D. 真理不可认识<br>正确答案：C</p>
</li>
<li><p>列宁指出：“在唯物主义者看来，人类实践的成功证明着我们的表象和我们所感知的客观事物的客观本性相符合。”这说明真理是（）。<br>A. 对客观事物及其规律的正确反映<br>B. 客观实在<br>C. 感性认识<br>D. 主观内容与客观形式的统一<br>正确答案：A</p>
</li>
<li><p>“‘成功’是我在实践中所需要的一切”这种观点的局限在于（）。<br>A. 混淆了“真理”和“有用”<br>B. 忽视了真理的主观形式<br>C. 把实践当做检验真理的唯一标准<br>D. 承认真理的客观性<br>正确答案：A</p>
</li>
<li><p>不同的主体对同一事物往往有不同的认识和判断，往往出现“此亦一是非，彼亦一是非”的情况，这是因为（）。<br>A. 真理是多元的<br>B. 认识是多元的<br>C. 真理不具有客观性<br>D. 认识不能正确反映世界<br>正确答案：B</p>
</li>
<li><p>承认了世界的可知性，承认人能够获得关于无限发展着的物质世界的正确认识，也就是承认了（）。<br>A. 认识的本源性<br>B. 静止的绝对性<br>C. 矛盾的特殊性<br>D. 真理的绝对性<br>正确答案：D</p>
</li>
<li><p>列宁指出：“人不能完全地把握——反映——描绘整个自然界. 它的‘直接的总体’，人只能通过创立抽象. 概念. 规律. 科学的世界图景等等永远地接近于这一点。”这说明（）。<br>A. 真理不具有绝对性<br>B. 世界是不可知的<br>C. 真理具有相对性<br>D. 真理的内容是主观的<br>正确答案：C</p>
</li>
<li><p>在实际工作中的教条主义. 思想僵化，追求某种一成不变的公式，是（）的表现。<br>A. 绝对主义<br>B. 相对主义<br>C. 辩证法<br>D. 唯物主义<br>正确答案：A</p>
</li>
<li><p>所谓马克思主义“过时论”属于（）。<br>A. 只承认真理绝对性的独断论<br>B. 只承认真理相对性的相对主义<br>C. 只承认真理客观性的唯物主义<br>D. 只承认真理主观性的实用主义<br>正确答案：B</p>
</li>
<li><p>“真理和谬误的对立，只是在非常有限的范围内才有意义”是（）。<br>A. 形而上学的观点<br>B. 唯物辩证法的观点<br>C. 诡辩论的观点<br>D. 相对主义的观点<br>正确答案：B</p>
</li>
<li><p>列宁指出：“任何真理，如果把它说得‘过火’……加以夸大，把它运用到实际使用的范围之外，便可以弄到荒谬绝伦的地步。”这说明（）。<br>A. 真理和谬误的对立是绝对的<br>B. 真理和谬误在一定条件下相互转化<br>C. 真理不具有绝对性<br>D. 从整体上看世界是不可知的<br>正确答案：B</p>
</li>
<li><p>平面条件下三角形的内角和为180度，这是广为人知的定理，但是到了曲面条件下，三角形的内角和就会大于或小于180度。这说明（）。<br>A. 真理都是在一定条件下才能成立<br>B. 数学知识不具备真理性<br>C. 真理与谬误的对立是绝对的<br>D. 人不能认识曲面条件下的几何知识<br>正确答案：A</p>
</li>
<li><p>在现实中，反面案例. 反面教材往往能起到警示人的教育作用，这说明（）。<br>A. 谬误就是真理. 真理就是谬误<br>B. 谬误是真理的来源<br>C. 在批判谬误中可以发展真理<br>D. 任何谬误都会转化为真理<br>正确答案：C</p>
</li>
<li><p>以多数人的意见为真理的标准和强调有用即真理的实用主义，在真理标准问题上的共同错误是（）。<br>A. 用认识检验认识<br>B. 认为真理具有客观性<br>C. 用实践检验认识<br>D. 认为真理是绝对的<br>正确答案：A</p>
</li>
<li><p>真理的本性在于（）。<br>A. 客观实在<br>B. 主观意识<br>C. 主观和客观相符合<br>D. 对主体的有用性<br>正确答案：C</p>
</li>
<li><p>“人们达到了思想中所预想的结果时，人们的认识才被证实了”说明（）。<br>A. 目的的正确性是检验真理的标准<br>B. 真理是主观见之于主观的认识活动<br>C. 实践是检验认识真理性的唯一标准<br>D. 认识是第一位的，实践是第二位的<br>正确答案：C</p>
</li>
<li><p>列宁指出：“实践标准决不能完全地证实或驳倒人类的任何表象。”这说明（）。<br>A. 实践不是检验认识真理性的标准<br>B. 实践标准具有不确定性<br>C. 表象是不可认知的<br>D. 实践标准不具有确定性<br>正确答案：B</p>
</li>
<li><p>列宁指出：“必须把人的全部实践——作为真理的标准，也作为事物同人所需要它的那一点的联系的实际确定者——包括到事物的完整的‘定义’中去。”这说明（）。<br>A. 具体的实践不能检验真理<br>B. 实践标准不具有客观性<br>C. 实践检验是一次完成的<br>D. 实践检验真理是一个永无止境的过程<br>正确答案：D</p>
</li>
<li><p>以前在农村，秸秆对农民来说几乎是一个毫无价值的东西，往往通过焚烧来处理，而随着新能源研究的推进，秸秆作为发电和制沼的原料，其价值在某种程度上甚至超过了粮食。这说明（）。<br>A. 客体的价值不具有确定性<br>B. 不同主体的评价创造了不同价值<br>C. 价值是实践基础上确立的主体与客体之间一种创造性关系<br>D. 价值随主体变化，而变化与客体本身无关<br>正确答案：C</p>
</li>
<li><p>同一块钻石，对不同的人而言，具有不同的价值，这说明（）。<br>A. 价值具有主体性与客体无关<br>B. 价值是运动变化的不能不能认识<br>C. 价值的客体性依赖于主体性<br>D. 价值具有多维性<br>正确答案：D</p>
</li>
<li><p>从家用热水器到发电厂的光伏板，今天人们已经充分认识了太阳能的巨大价值。太阳能的发现和利用体现了（）。<br>A. 价值具有社会历史性<br>B. 价值是一维的<br>C. 人的认识和评价创造了价值<br>D. 价值不具有确定性<br>正确答案：A</p>
</li>
<li><p>我国科学家屠呦呦用科学实验方法探寻疟疾的新疗法，体现了（）。<br>A. 真理的确定性和不确定性的统一<br>B. 价值的多维性和一维性的统一<br>C. 真理与价值的对立性<br>D. 真理尺度与价值尺度的统一<br>正确答案：D</p>
</li>
<li><p>1978年关于真理标准大讨论是一场新的思想解放运动，实践之所以成为检验真理的唯一标准是由（）。<br>A. 真理的主观性和实践的客观性所要求的<br>B. 真理的相对性和实践的决定性所预设的<br>C. 真理的绝对性和实践的功能所规定的<br>D. 真理的本性和实践的特点所决定的<br>正确答案：D</p>
</li>
<li><p>列宁指出：“没有抽象的真理，真理都是具体的。”这句话的含义是（）。<br>A. 真理有其适用的范围和条件<br>B. 真理的形成不需要进行抽象的概括<br>C. 真理是抽象不变的公式<br>D. 真理本身没有任何抽象因素<br>正确答案：A</p>
</li>
<li><p>辩证法与形而上学在真理观上的对立在于是否承认（）。<br>A. 真理具有绝对性<br>B. 真理具有客观性<br>C. 真理具有主观性<br>D. 真理具有相对性<br>正确答案：D</p>
</li>
<li><p>既承认实践是检验真理的唯一标准，又承认逻辑证明在认识和探索真理中的作用，就是认为（）。<br>A. 检验真理的标准是多元的<br>B. 逻辑证明可以取代实践标准<br>C. 逻辑证明可以最终证实或驳倒真理<br>D. 被逻辑证明和证伪了的认识最终还要靠实践的检验<br>正确答案：D</p>
</li>
<li><p>16世纪末，伽利略通过在比萨斜塔所做的自由落体实验，推翻了亚里士多德关于物体的降落速度与物体的重量成正比的说法。这件事说明（）。<br>A. 感性认识只有上升到理性认识才能把握事物的本质<br>B. 实践是检验认识真理性的唯一标准<br>C. 实践是认识发展的动力<br>D. 真理是对事物及其发展规律的正确反映<br>正确答案：B</p>
</li>
<li><p>“追求真理比占有真理更宝贵”这一命题所包含的哲理是（）。<br>A. 认识经历着从感性认识到理性认识的发展<br>B. 认识的根本任务是通过现象认识本质<br>C. 认识不能停滞，而应该不断扩展和深化<br>D. 改造世界比认识世界更重要<br>正确答案：C</p>
</li>
<li><p>价值评价是主体对客体价值以及价值大小所作的评判或判断，价值评价是（）。<br>A. 一种纯主观的认识活动<br>B. 没有任何客观标准的评价<br>C. 没有正确与错误区分的评价<br>D. 有肯定与否定之分的评价<br>正确答案：D</p>
</li>
<li><p>人类认识和实践活动中的基本矛盾是（）。<br>A. 普遍性与特殊性的矛盾<br>B. 绝对性与相对性的矛盾<br>C. 主观与客观的矛盾<br>D. 个人和社会的矛盾<br>正确答案：C</p>
</li>
<li><p>（）是人类认识世界和改造世界的根本动力。<br>A. 真理与价值的矛盾<br>B. 经济基础和上层建筑的矛盾<br>C. 本质与现象的矛盾<br>D. 主观与客观的矛盾<br>正确答案：D</p>
</li>
<li><p>马克思在《关于费尔巴哈的提纲》中指出：“环境的改变和人的活动或自我改变是一致的。”这体现了（）。<br>A. 改造客观世界与改造主观世界的统一<br>B. 认识的真理性和价值性的统一<br>C. 环境的客观实在性和主观能动性的统一<br>D. 人的活动的有限性和无限性的统一<br>正确答案：A</p>
</li>
<li><p>自由就是“由自”，这种观点（）。<br>A. 属于宿命论<br>B. 属于唯意志论<br>C. 强调消极顺应自然<br>D. 抹杀了人类自由的可能性<br>正确答案：B</p>
</li>
<li><p>恩格斯指出：“自由不在于幻想中摆脱自然规律而独立，而在于认识这些规律，从而能够有计划地使自然规律为一定目的服务”，这说明（）。<br>A. 人的实践只具有合目的尺度<br>B. 人能够改造和利用自然规律<br>C. 自由既要认识必然又要利用必然<br>D. 人只能消极的顺应自然<br>正确答案：C</p>
</li>
<li><p>习近平指出：“我国正处于并将长期处于社会主义初级阶段，我们不能做超越阶段的事情……而是要根据现有条件把能做的事情尽量做起来”，从自由观的角度看，这说明（）。<br>A. 自由是具体的历史的<br>B. 人只能被动的受社会历史限制<br>C. 实践条件是自由的唯一条件<br>D. 自由是一劳永逸的事情<br>正确答案：A</p>
</li>
<li><p>一切从（）出发，是马克思主义认识论的根本要求和具体体现。<br>A. 实际<br>B. 认识<br>C. 权威<br>D. 书本<br>正确答案：A</p>
</li>
<li><p>马克思. 恩格斯认为：“共产党人的原理……不过是现存的阶级. 我们眼前的历史运动的真实关系的一般表述。”这说明（）。<br>A. 马克思主义基本原理没有把握人类社会发展规律<br>B. 马克思主义只在当时的历史条件有效<br>C. 运用马克思主义必须从实际出发<br>D. 马克思主义不能指导实践<br>正确答案：C</p>
</li>
</ol>
<h3 id="多选-2"><a href="#多选-2" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>科学实践观创立和发展的意义包括（）。<br>A. 克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础<br>B. 建立了科学的. 能动的. 革命的反映论，实现了人类认识史上的变革<br>C. 在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础<br>D. 为人们能动地认识世界和改造世界提供了基本的思想方法和工作方法<br>正确答案：ABCD</p>
</li>
<li><p>实践是人能动改造客观世界的物质性活动，具有（）等基本特征。<br>A. 客观实在性<br>B. 自觉能动性<br>C. 社会历史性<br>D. 不可认识性<br>正确答案：ABC</p>
</li>
<li><p>实践在本质上是客观的. 物质的活动，这是因为（）。<br>A. 实践的主体和客体都是客观实在<br>B. 实践的中介是物质的<br>C. 实践的水平. 广度. 深度和发展过程都受客观条件制约<br>D. 实践能引起客观世界的变化<br>正确答案：ABCD</p>
</li>
<li><p>实践的基本要素包括（）。<br>A. 实践的主体<br>B. 实践的客体<br>C. 实践的中介<br>D. 实践的结果<br>正确答案：ABC</p>
</li>
<li><p>以下各项中，属于实践中介的有（）。<br>A. 耕牛<br>B. 电脑<br>C. 无人机<br>D. 语言<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，属于体现客体主体化的现象的有（）。<br>A. 万户设想了通过火箭升空的场景<br>B. 设计师设计制作了一款新型手机<br>C. 商人乘坐飞机飞往大洋彼岸<br>D. 大学生在课堂上学习知识<br>正确答案：BC</p>
</li>
<li><p>一位科学家说：“我们今天生活着的世界，与其说是自然世界，还不如说是人造或人为的世界。在我们的周围，几乎每样东西都刻有人的技能的痕迹。”这段话应理解为（）。<br>A. 人造的或人为的世界是惟一存在的世界<br>B. 现实世界是人类精神的创造物<br>C. 人类世界是人的实践活动对象化的结果<br>D. 科学技术越来越成为人类改造世界的伟大力量<br>正确答案：CD</p>
</li>
<li><p>马克思指出：“费尔巴哈把宗教的本质归结于人的本质。但是人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。”这说明相对于费尔巴哈的旧唯物主义，马克思主义的科学之处在于（）。<br>A. 从实践出发把握现实世界<br>B. 从实践出发认识人及其与世界的关系<br>C. 在实践基础上实现了唯物论和辩证法的统一<br>D. 克服了旧唯物主义不懂实践在社会生活中的决定意义的局限<br>正确答案：ABCD</p>
</li>
<li><p>马克思指出：“人的认识是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题。”马克思主义科学实践观的意义在于（）。<br>A. 揭示了实践的观点是辩证唯物主义认识论首要的和基本的观点。<br>B. 找到了检验认识真理性的唯一标准<br>C. 批判了唯心主义先验论和不可知论<br>D. 克服了旧唯物主义直观反映论的缺陷<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯在《德意志意识形态》中写道：“以一定的方式进行生产活动的一定的个人，发生一定的社会关系和政治关系。”马克思的科学实践观的科学之处在于（）。<br>A. 揭示了社会生活的实践本质<br>B. 指出了物质生产实践在社会生活中的重要作用和地位<br>C. 实现了唯物主义自然观和历史观的统一<br>D. 找到了人类历史“真正的发源地”<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯指出：“对实践的唯物主义者即共产主义者来说，全部问题在于使现存世界革命化，实际地反对并改变现存的事物。”马克思主义科学实践观的意义在于（）。<br>A. 强调改变世界的重要性<br>B. 强调理论应转化为物质力量<br>C. 为人能动地改造世界提供了基本的思想方法和工作方法<br>D. 是人们认识世界和改造世界的锐利武器<br>正确答案：ABCD</p>
</li>
<li><p>人类的实践活动是不断发展的，它的发展有自身的特点和规律。实践的发展过程是（）。<br>A. 范围不断扩大. 程度不断加深. 效果不断提升的过程<br>B. 从低级到高级. 从简单到复杂. 从自发到自觉的过程<br>C. 改造客观世界和改造主观世界相互促进的过程<br>D. 逐步走向真善美相统一. 最终实现人的自由而全面的发展的过程<br>正确答案：ABCD</p>
</li>
<li><p>实践对认识的决定作用表现在（）。<br>A. 实践是认识的来源<br>B. 实践是认识发展的动力<br>C. 实践是认识的目的<br>D. 实践是检验认识真理性的唯一标准<br>正确答案：ABCD</p>
</li>
<li><p>实践是认识发展的动力，这表现在（）。<br>A. 实践的需要推动认识的产生和发展<br>B. 实践为认识发展提供了手段和条件<br>C. 实践改造了人的主观世界<br>D. 实践锻炼和提高了人的认识能力<br>正确答案：ABCD</p>
</li>
<li><p>习近平说：“你脑子里装着问题了，想解决问题了，想把问题解决好了，就会去学习，就会自觉去学习。”这体现了（）。<br>A. 实践需要推动认识的产生和发展<br>B. 学习间接经验是解决问题的根本途径<br>C. 主观意愿是获得知识的根本动力<br>D. 实践推动人提高认识能力改造主观世界<br>正确答案：AD</p>
</li>
<li><p>习近平指出：“历史表明，社会大变革的时代，一定是哲学社会科学大发展的时代。”从马克思主义哲学角度来看，这是因为（）。<br>A. 认识是实践的基础<br>B. 认识是实践的归宿<br>C. 实践是认识的来源<br>D. 实践是认识发展的动力<br>正确答案：CD</p>
</li>
<li><p>马克思在《关于费尔巴哈的提纲》中提出：“关于思维——离开实践的思维——的现实性或非现实性的争论，是一个纯粹经院哲学的问题。”这说明（）。<br>A. 思维不具备现实性<br>B. 思维是否具有真理性不能从自身得到证实<br>C. 实践是检验认识真理性的唯一标准<br>D. 认识的真理性只有在实践中才能得到验证<br>正确答案：BCD</p>
</li>
<li><p>“求之而后得，为之而后成”，这属于（）。<br>A. 唯物主义认识路线<br>B. 唯心主义认识路线<br>C. 反映论<br>D. 天赋观念论<br>正确答案：AC</p>
</li>
<li><p>旧唯物主义认识论的缺陷包括（）。<br>A. 认为认识是理念的产物<br>B. 认为认识是无本之木<br>C. 离开实践考察认识问题<br>D. 不了解认识的辩证本性<br>正确答案：CD</p>
</li>
<li><p>辩证唯物主义认识论的突出特点有（）。<br>A. 把实践的观点引入认识论<br>B. 把辩证法应用于反映论考察认识的发展过程<br>C. 坚持意识对物质的决定作用<br>D. 认识到意识自身的不动性和永恒性<br>正确答案：AB</p>
</li>
<li><p>理性认识是认识的高级阶段，具有（）的特点。<br>A. 抽象性<br>B. 具体性<br>C. 间接性<br>D. 直接性<br>正确答案：AC</p>
</li>
<li><p>感觉. 知觉. 表象的依次发展，初步显现出（）。<br>A. 认识的发展是不断进行质的飞跃的趋势<br>B. 认识发展从部分到全体的发展趋势<br>C. 认识发展从直接到间接的发展趋势<br>D. 认识发展从感性认识到理性认识发展的趋势<br>正确答案：BCD</p>
</li>
<li><p>认识的第二次飞跃是更为重要的飞跃，其重要性在于（）。<br>A. “生动的直观”是认识过程的起始环节<br>B. 认识世界的目的是改造世界<br>C. 认识的真理性只有在实践中才能得到检验<br>D. 理性认识以事物本质为内容<br>正确答案：BC</p>
</li>
<li><p>习近平指出：“科学理论是我们推动工作. 解决问题的‘金钥匙’”，这句话强调（）。<br>A. 做好认识的第一次飞跃的重要性<br>B. 做好认识的第二次飞跃的重要性<br>C. 科学理论是认识的最终目的<br>D. 科学理论对于实践具有指导作用<br>正确答案：AD</p>
</li>
<li><p>习近平指出：“实践没有止境，理论创新也没有止境。”这是（）。<br>A. 针对当前具体事物. 现实而言的<br>B. 针对实践和认识运动过程向前推移向前发展而言的<br>C. 看到了客观世界的发展变化<br>D. 体现了实践认识的辩证发展过程<br>正确答案：BCD</p>
</li>
<li><p>一个正确的思想，往往需要经历由实践到认识，由认识到实践的多次反复才能形成，这是因为（）。<br>A. 认识主体存在着自身的局限性<br>B. 事物本质的暴露是一个过程<br>C. 人的认识受社会历史条件的限制<br>D. 认识是一个过程<br>正确答案：ABCD</p>
</li>
<li><p>列宁在十月革命胜利后指出：“对俄国来说，根据书本争论社会主义纲领的时代已经过去了，我深信已经一去不复返了。今天只能根据经验来谈社会主义。”对这句话的正确理解有（）。<br>A. 应该在实践中不断丰富发展社会主义理论<br>B. 社会主义建设不需要任何纲领<br>C. 必须由实践来检验社会主义理论<br>D. 对社会主义的认识应该由经验代替理论<br>正确答案：AC</p>
</li>
<li><p>“按图索骥”就是指照图上画的样子去寻求好马，这种方法的错误在于（）。<br>A. 理论脱离实际<br>B. 教条主义<br>C. 经验论<br>D. 唯理论<br>正确答案：ABD</p>
</li>
<li><p>割裂感性认识和理性认识的统一会导致（）。<br>A. 诡辩论<br>B. 唯理论<br>C. 经验论<br>D. 反映论<br>正确答案：BC</p>
</li>
<li><p>下列各项中，能正确说明感性认识和理性认识的联系的有（）。<br>A. 理性认识依赖于感性认识<br>B. 感性认识可以自然而然地上升到理性认识<br>C. 感性认识有待于发展到理性认识<br>D. 理性认识是在感性认识指导下进行的<br>正确答案：AC</p>
</li>
<li><p>同一棵大树，木匠看到的是木材，画家看到的是色彩和色调，植物学家看到的是它的形态特征，这是由于（）。<br>A. 人的感觉受理性指导<br>B. 人的认识具有能动性<br>C. 理性认识是感性认识的基础<br>D. 已有的认识影响感觉活动<br>正确答案：ABD</p>
</li>
<li><p>孙中山先生指出，认识过程是“以行而求知，因知以进行”“行其所不知以致其所知”“因其已知而更进于行”。其中所表达的思想有（）。<br>A. 知行相互促进<br>B. 行先知后<br>C. 知行不可分割<br>D. 知行合一<br>正确答案：ABCD</p>
</li>
<li><p>毛泽东强调：“一个正确的认识，往往需要经过由物质到精神，由精神到物质，即由实践到认识，由认识到实践这样多次的反复，才能够完成。”这说明实践. 认识的辩证运动过程也就是（）。<br>A. 通过实践发现真理的过程<br>B. 通过实践证实真理的过程<br>C. 通过实践发展真理的过程<br>D. 通过实践走向最高理念的过程<br>正确答案：ABC</p>
</li>
<li><p>强调“有用即是真理”的实用主义真理观的局限在于（）。<br>A. 夸大了真理的主观性<br>B. 夸大了真理的客观性<br>C. 夸大了真理的相对性<br>D. 夸大了真理的绝对性<br>正确答案：AC</p>
</li>
<li><p>“一个观念是真的，只要它能帮助我们和我们经验别的部分，得到圆满的关系”，这种真理观（）。<br>A. 属于辩证唯物主义真理观<br>B. 属于实用主义真理观<br>C. 忽视了真理的客观性<br>D. 忽视了真理的主观性<br>正确答案：BC</p>
</li>
<li><p>“认为我们的感觉是外部世界的映像；承认客观真理；坚持唯物主义认识论的观点——这都是一回事”，这说明（）。<br>A. 坚持真理的客观性是真理问题上的唯物论<br>B. 真理的客观性是唯物主义反映论在真理问题上的贯彻<br>C. 辩证唯物主义和旧唯物主义真理观没有区别<br>D. 承认真理的客观性就是否认真理的主观性<br>正确答案：AB</p>
</li>
<li><p>真理的绝对性的含义是指（）。<br>A. 任何真理都标志着主观与客观相符合<br>B. 人类认识能够正确认识无限发展的物质世界<br>C. 真理都是有用的<br>D. 真理永恒不变<br>正确答案：AB</p>
</li>
<li><p>“对自然界的一切真实的认识，都是对永恒的东西. 无限的东西的认识”，这说明（）。<br>A. 真理具有相对性<br>B. 真理具有绝对性<br>C. 世界是可知的<br>D. 世界是不可知的<br>正确答案：BC</p>
</li>
<li><p>真理的相对性的含义是指（）。<br>A. 人不能正确认识无限发展着的世界<br>B. 任何真理都只是对客观世界的某一阶段. 某一部分的正确认识<br>C. 任何真理都只是对客观对象一定方面. 一定层次和一定程度的正确认识<br>D. 世界一直发展变化不存在相对静止<br>正确答案：BC</p>
</li>
<li><p>真理在一定条件下会转化为谬误，这是因为（）。<br>A. 真理本身不具备客观性<br>B. 真理只是相对真理<br>C. 真理是一定条件下的真理<br>D. 真理是同其他原理联系在一起的真理<br>正确答案：CD</p>
</li>
<li><p>“失败常常是成功之母”说明（）。<br>A. 谬误在一定条件下能够向真理转化<br>B. 谬误必然转化为真理<br>C. 真理与谬误的对立是相对的<br>D. 真理与谬误的对立是绝对的<br>正确答案：AC</p>
</li>
<li><p>认识自身不能作为检验真理的标准是因为（）。<br>A. 检验真理是检验主观同客观的符合程度<br>B. 认识检验认识始终实在主观范围内兜圈子<br>C. 已经被证明为正确的理论的适用范围仍需被实践检验<br>D. 真理不具备主观性<br>正确答案：ABC</p>
</li>
<li><p>逻辑证明不能成为检验真理的标准是因为（）。<br>A. 逻辑证明不能回答结论是不是符合实际的问题<br>B. 逻辑证明了的东西还必须经过实践检验<br>C. 逻辑证明对获得正确认识没有帮助<br>D. 逻辑证明作为感性认识不能认识本质<br>正确答案：AB</p>
</li>
<li><p>实践的相对性是指（）。<br>A. 实践受主客观条件制约，不可能完全证实一切认识<br>B. 实践是社会的历史的<br>C. 具体实践往往只能总体上证实认识的真理性<br>D. 实践不能最终检验认识是否具有真理性<br>正确答案：ABC</p>
</li>
<li><p>坚持实践是检验真理的唯一标准，就要（）。<br>A. 看到实践标准的确定性<br>B. 反对唯心主义. 怀疑主义. 相对主义<br>C. 看到实践标准的不确定性<br>D. 反对教条主义和独断论<br>正确答案：ABCD</p>
</li>
<li><p>价值的主体性是指（）。<br>A. 价值直接与主体相联系<br>B. 价值关系的形成依赖于主体的存在<br>C. 价值关系的形成依赖于主体的创造<br>D. 价值始终以主体为中心<br>正确答案：ABCD</p>
</li>
<li><p>价值的客观性是指（）。<br>A. 在一定条件下客体对于主体的意义不依赖主体的主观意识而存在<br>B. 主体的存在和需要是客观的<br>C. 客体的存在. 属性及作用是客观的<br>D. 客体能否满足主体需要是由客体客观存在的性质属性等决定的<br>正确答案：ABCD</p>
</li>
<li><p>正确的价值评价要（）。<br>A. 以真理为根据<br>B. 与社会历史发展的客观规律相一致<br>C. 以最广大人民的需要和利益为根本<br>D. 超越客体进行价值创造<br>正确答案：ABC</p>
</li>
<li><p>价值评价的特点是（）。<br>A. 以主客体的价值关系为认识对象<br>B. 评价结果与评价主体直接相关<br>C. 评价结果的正确与否依赖于对客体状况和主体需要的认识<br>D. 有科学与非科学之分<br>正确答案：ABCD</p>
</li>
<li><p>具有同样的化学知识，有的人为人类造福，有的人制造毒品危害社会，这说明（）。<br>A. 知识对人的行为没有影响<br>B. 科学知识不能保证行为正确<br>C. 价值观有正确错误之分<br>D. 知识与价值观之间没有联系<br>正确答案：BC</p>
</li>
<li><p>马克思主义价值观以（）为标准。<br>A. 是否满足绝大多数人的利益<br>B. 社会的进步<br>C. 人类的彻底解放<br>D. 集团政治利益<br>正确答案：ABC</p>
</li>
<li><p>社会主义核心价值观科学回答了（）等重大问题。<br>A. 建设什么样的国家<br>B. 建设什么样的社会<br>C. 培育什么样的公民<br>D. 如何实现共产主义<br>正确答案：ABC</p>
</li>
<li><p>尽管历史上罗马教廷把哥白尼的“日心说”当作“异端邪说”加以打击，但这既不能改变地球绕太阳运转的规律，也不能阻止人们接受“日心说”。这一事实说明（）。<br>A. 客观规律不以人的意志为转移<br>B. 规律是客观的<br>C. 人在客观规律面前无能为力<br>D. 真理中包含着不依赖于人的客观内容<br>正确答案：ABD</p>
</li>
<li><p>人类创造历史的两种基本活动是（）。<br>A. 认识世界<br>B. 改造世界<br>C. 创造规律<br>D. 摆脱客观世界束缚<br>正确答案：AB</p>
</li>
<li><p>改造世界包括（）。<br>A. 改造世界运行规律<br>B. 改造物质的根本属性<br>C. 改造主观世界<br>D. 改造客观世界<br>正确答案：CD</p>
</li>
<li><p>以下关于客观世界与主观世界关系的说法中，正确的有（）。<br>A. 客观世界与主观世界具有不同的存在方式<br>B. 客观世界与主观世界发展具有不完全同步性<br>C. 主观世界与客观世界的运动规律具有同一性<br>D. 在一定条件下二者可以相互转化<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义关于在改造客观世界的同时改造主观世界的观点的重要意义有（）。<br>A. 有助于提高认识世界的能力<br>B. 有助于更好地处理主观世界与客观世界的关系<br>C. 有助于提高思想修养和精神境界<br>D. 有助于在改造外部世界的同时重视并努力实现人自身的改造<br>正确答案：ABCD</p>
</li>
<li><p>自觉的实现自我改造需要（）。<br>A. 勇于以自我革命的精神打造和锻炼自己<br>B. 增强自我净化. 自我完善的能力<br>C. 增强自我革命. 自我提高的能力<br>D. 完全专注于主观世界<br>正确答案：ABC</p>
</li>
<li><p>任性不是自由，无知不能获得自由，自由是有条件的。自由的条件包括（）。<br>A. 对客观事物的正确认识<br>B. 能够将获得的规律性认识运用于指导实践<br>C. 摆脱客观必然性<br>D. 完全顺从客观必然性<br>正确答案：AB</p>
</li>
<li><p>实现自由的三重含义包括（）。<br>A. 人与自然关系中的自由<br>B. 人与社会关系中的自由<br>C. 人与自身关系中的自由<br>D. 人在创造规律中自由<br>正确答案：ABC</p>
</li>
<li><p>实现人与自然关系中的自由，就要（）。<br>A. 尊重和把握自然规律<br>B. 实现人与自然和谐统一<br>C. 被动地顺应自然<br>D. 完全摆脱自然的束缚<br>正确答案：AB</p>
</li>
<li><p>实现人与社会关系中的自由，就要（）。<br>A. 把握社会规律<br>B. 以真理为根据<br>C. 以最广大人民的需要和利益为根本<br>D. 实现人与社会的和谐统一<br>正确答案：ABCD</p>
</li>
<li><p>实现人与自身关系中的自由，就要（）。<br>A. 自觉摆脱人的自我束缚<br>B. 追求更高境界的精神解放<br>C. 实现身心和谐统一<br>D. 发明本心，认识到“吾心即是宇宙”<br>正确答案：ABC</p>
</li>
<li><p>人类认识世界和改造世界的根本目标是（）。<br>A. 发明本心<br>B. 达到最高理念<br>C. 认识必然<br>D. 争取自由<br>正确答案：CD</p>
</li>
<li><p>从实际出发就是（）。<br>A. 从变化发展着的客观实际出发<br>B. 从特定的社会历史条件出发<br>C. 按照世界的本来面目认识世界<br>D. 从客观事物存在和发展的规律出发<br>正确答案：ABCD</p>
</li>
<li><p>中国共产党人在领导人民进行革命. 建设. 改革的长期实践中所确立的思想路线的内涵包括（）。<br>A. 一切从实际出发<br>B. 理论联系实际<br>C. 实事求是<br>D. 在实践中检验和发展真理<br>正确答案：ABCD</p>
</li>
<li><p>习近平指出：“时代课题是理论创新的驱动力。马克思. 恩格斯. 列宁等都是通过思考和回答时代课题来推进理论创新的。”这说明（）。<br>A. 理论创新决定了实践创新<br>B. 马克思主义已经过时<br>C. “问题倒逼”是不断进行理论创新的助推器<br>D. 时代的变化和实践发展是理论创新的源头活水<br>正确答案：CD</p>
</li>
<li><p>“实践发展永无止境，解放思想永无止境”。坚持马克思主义就是要（）。<br>A. 坚持马克思主义的科学原理和科学精神. 创新精神<br>B. 善于根据客观情况的变化不断从人民群众实践中汲取营养<br>C. 不断丰富和发展马克思主义<br>D. 运用理论指导实践<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-2"><a href="#判断-2" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>目的性是实践能动性的主要表现。<br>对</p>
</li>
<li><p>实践的社会性决定了它的历史性。<br>对</p>
</li>
<li><p>在自然经济占主导的时期，生产以满足自身需要为目的，这一时期的实践不具有社会性。<br>错</p>
</li>
<li><p>人脑中观念的存在变为现实的存在是通过实践实现的。<br>对</p>
</li>
<li><p>人在实践中的结果，在实践开始时就在头脑中以观念的形式存在着，这说明实践是主观的. 观念的活动。<br>错</p>
</li>
<li><p>知识性因素是实践主体的首要的能力。<br>对</p>
</li>
<li><p>实践主体是指所有的自然人。<br>错</p>
</li>
<li><p>实践客体是指自然界。<br>错</p>
</li>
<li><p>客观实在性特征将实践活动和认识活动区分开来，使实践主体和客体. 认识主体和客体产生本质上的区别。<br>错</p>
</li>
<li><p>人类一切实践活动的结果都是主体客体化的结果。<br>对</p>
</li>
<li><p>人类实践活动就是主体客体化。<br>错</p>
</li>
<li><p>物质生产实践解决的是人与自然的矛盾，决定着社会的基本性质和面貌。<br>对</p>
</li>
<li><p>社会政治实践就是指社会革命。<br>错</p>
</li>
<li><p>社会政治实践决定了人的物质生产实践。<br>错</p>
</li>
<li><p>精神文化的生产是一个纯粹的意识过程。<br>错</p>
</li>
<li><p>教育活动之所以是一种实践活动，是因为通过教育实际地改变了受教育者的存在状态。<br>对</p>
</li>
<li><p>人在网络世界的活动因其虚拟性而不是一种人类实践。<br>错</p>
</li>
<li><p>虚拟实践的实质是主体与客体通过数字化中介系统在虚拟空间进行的双向对象化活动。<br>对</p>
</li>
<li><p>一切真知都是从直接经验发源的。<br>对</p>
</li>
<li><p>认识的最终目的是为实践服务。<br>对</p>
</li>
<li><p>认识是否具有真理性可以从认识本身和认识对象中得到回答。<br>错</p>
</li>
<li><p>直观反映论的局限性，最根本的是它看不到主观和客观之间的矛盾及其相互作用。<br>对</p>
</li>
<li><p>人的认识不论表现形式多么抽象和复杂，归根结底是对客观对象的反映，这表明这种反映具有客观性。<br>对</p>
</li>
<li><p>辩证唯物主义认为，认识就是主观对客观的照镜子式的原物映现。<br>错</p>
</li>
<li><p>人类所创造的众多科技成果，都彰显了认识的创造性的重大意义，体现了创造性是人类认识基本规定性的地位。<br>错</p>
</li>
<li><p>人认识一定事物的过程是从实践到认识，再从认识到实践的过程。<br>对</p>
</li>
<li><p>知觉是整个认识过程的起始环节。<br>错</p>
</li>
<li><p>感性认识以事物现象的内部联系为内容，深入到对事物本质的认识。<br>错</p>
</li>
<li><p>理性认识以反映事物的本质为内容，因而是深刻的。<br>对</p>
</li>
<li><p>认识的第二次能动飞跃是指从认识到实践的飞跃。<br>对</p>
</li>
<li><p>认识的第一次飞跃解决了认识是否正确的问题。<br>错</p>
</li>
<li><p>认识到实践的最后一个环节，是对人民群众进行组织宣传让理论为群众所掌握。<br>对</p>
</li>
<li><p>人们只要参加社会实践，就一定能获得对客观事物及其规律的正确认识。<br>错</p>
</li>
<li><p>在实践与认识的辩证运动中，主观必须统一于客观，认识必须统一于实践。<br>对</p>
</li>
<li><p>真理是通过人的能动的反映活动而实现的，并且必然随着人类实践的发展而拓展和深化。<br>对</p>
</li>
<li><p>真理的客观性指的是真理的内容对客观事物及其规律的正确反映。<br>对</p>
</li>
<li><p>真理之所以称之为真理，就在于其内容和形式都是客观的。<br>错</p>
</li>
<li><p>真理的客观性决定了真理的一元性。<br>对</p>
</li>
<li><p>真理的一元性是指就整个世界而言，真理性认识只有一个。<br>错</p>
</li>
<li><p>真理是内容上的一元性与形式上的多样性的统一。<br>对</p>
</li>
<li><p>任何真理都是绝对性与相对性的统一。<br>对</p>
</li>
<li><p>真理的相对性是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的。<br>对</p>
</li>
<li><p>任何真理的相对性之中都包含着真理的绝对性。<br>对</p>
</li>
<li><p>真理的绝对性和相对性根源于人类认识世界能力的无限性和有限性. 绝对性与相对性的矛盾。<br>对</p>
</li>
<li><p>马克思主义作为客观真理是绝对性和相对性的统一。<br>对</p>
</li>
<li><p>谬误是同客观事物及其发展规律相违背的认识，不是对客观世界的反映。<br>错</p>
</li>
<li><p>认识的发展与真理的获得，正是在对谬误的不断纠正中实现的。<br>对</p>
</li>
<li><p>在确定条件下，一种认识可以既是真理又是谬误。<br>错</p>
</li>
<li><p>在根本意义上，实践是检验真理的标准，此外还有诸多特定标准。<br>错</p>
</li>
<li><p>真理是对客观事物的正确反映，因此客观事物本身是检验真理的标准。<br>错</p>
</li>
<li><p>只有能够把主观和客观联系起来加以比较对照的东西，才能充当检验真理的标准，具有这种特性的东西，只能是社会实践。<br>对</p>
</li>
<li><p>实践的直接现实性品格是实践能够成为检验真理唯一标准的主要根据。<br>对</p>
</li>
<li><p>实践是检验认识真理性的唯一标准，所以逻辑推理在检验真理过程中毫无作用。<br>错</p>
</li>
<li><p>实践标准的绝对性是由实践标准的客观性和唯一性所决定的。<br>对</p>
</li>
<li><p>实践是检验认识真理性的唯一标准，这种检验是一次完成的。<br>错</p>
</li>
<li><p>价值是客体对个人. 群体乃至整个社会的生活和活动所具有的积极意义。<br>对</p>
</li>
<li><p>价值是主体的欲望. 情趣和兴趣，与客体无关。<br>错</p>
</li>
<li><p>价值具有客观性，是一种客观存在，始终以客体为中心。<br>错</p>
</li>
<li><p>主客体之间的价值关系是一种自然的现成关系。<br>错</p>
</li>
<li><p>价值的主体性以价值的客观性为前提。<br>对</p>
</li>
<li><p>价值是一种客观存在，独立于人们对它的认识和评价。<br>对</p>
</li>
<li><p>价值是一种客观存在，因此价值评价能够避免主体间的差异性。<br>错</p>
</li>
<li><p>正确反映和把握价值关系，需要对“主体”进行区分，需要处理好个体评价标准和社会评价标准之间的关系。<br>对</p>
</li>
<li><p>能否做出正确的价值判断，取决于人对客体和主体的双重认识。<br>对</p>
</li>
<li><p>对民族与国家来说，最持久. 最深层的力量是全社会共同认可的核心价值观。<br>对</p>
</li>
<li><p>核心价值观是一个国家的重要稳定器。<br>对</p>
</li>
<li><p>实践的真理尺度体现了人的活动的目的性。<br>错</p>
</li>
<li><p>人的活动是具有目的性的活动，因而真理尺度必须以价值尺度为前提。<br>错</p>
</li>
<li><p>脱离了价值尺度，真理就缺失了主体意义。<br>对</p>
</li>
<li><p>坚持主观与客观. 认识与实践的统一，归根到底是要将认识世界和改造世界密切结合起来。<br>对</p>
</li>
<li><p>正确的认识世界是改造世界的必要前提。<br>对</p>
</li>
<li><p>人的自由限度是在认识必然性的基础上自由活动。<br>对</p>
</li>
<li><p>认识了客观必然性就达到了自由。<br>错</p>
</li>
<li><p>从实际出发，关键是要注重事实，从事实出发。<br>对</p>
</li>
<li><p>只有理论. 思想才可以成为研究问题和作决策. 办事情的出发点。<br>错</p>
</li>
<li><p>坚持实事求是，最基础的工作在于搞清楚“实事”，关键在于“求是”。<br>对</p>
</li>
<li><p>当前我国，一切从实际出发，就是一切要从中国特色社会主义进入了新时代这个我国发展新的历史方位出发。<br>对</p>
</li>
<li><p>在理论创新与实践创新的相互关系中，实践创新具有基础性的意义。<br>对</p>
</li>
</ol>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="单选-3"><a href="#单选-3" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>社会历史观的基本问题是（）。<br>A. 社会存在和社会意识的关系问题<br>B. 生产力和生产关系的关系问题<br>C. 物质与意识的关系问题<br>D. 真理与价值的关系问题<br>正确答案：A</p>
</li>
<li><p>社会存在是社会生活的物质方面，其中的（）提供了社会生活和生产资料的来源。<br>A. 自然地理环境<br>B. 人口因素<br>C. 社会心理<br>D. 意识形态<br>正确答案：A</p>
</li>
<li><p>之所以坚持人与自然和谐共生，建设生态文明，从唯物史观的角度来看，是因为（）。<br>A. 人在自然面前是无能为力的<br>B. 自然地理环境是社会存在和发展的决定力量<br>C. 自然生态平衡对社会生活起着重要作用<br>D. 自然地理环境决定社会结构和面貌<br>正确答案：C</p>
</li>
<li><p>为调整我国人口结构，提高人口质量，2021年我国出台了三孩政策。从唯物史观的视角看，这体现了（）。<br>A. 人口是社会生活的决定力量<br>B. 人口数量越大对社会发展作用越大<br>C. 人口提供了社会生活和生产资料的来源<br>D. 人口的数量. 质量和结构对生产发展和社会进步起加速或延缓作用<br>正确答案：D</p>
</li>
<li><p>“任何一个民族，如果停止劳动，不用说一年，就是几个星期，也要灭亡……”，这说明（）。<br>A. 自然地理环境对社会存在与发展的重要性<br>B. 人口因素对社会存在发展的重要性<br>C. 物质生产方式对社会存在发展的重要性<br>D. 资本主义雇佣劳动对社会存在发展的重要性<br>正确答案：C</p>
</li>
<li><p>（）是最直接. 最集中地反映经济基础的意识形态，在意识形态中居于核心地位，发挥主导作用。<br>A. 政治法律思想<br>B. 社会心理<br>C. 人口因素<br>D. 自然地理环境<br>正确答案：A</p>
</li>
<li><p>《新时代公民道德建设实施纲要》倡导自觉传承中华传统美德，从唯物史观角度看，这体现了（）。<br>A. 道德是永恒不变的<br>B. 道德具有继承性<br>C. 道德是独立发展的，不反映经济基础<br>D. 不同时代具有相同的道德<br>正确答案：B</p>
</li>
<li><p>“在原始社会，人们只有朴素的公有观念，不知‘私有’为何物。随着以生产资料私有制为基础的生产方式的出现和原始社会的瓦解，私有观念才得以产生。”这说明（）。<br>A. 社会意识是历史的具体的<br>B. 社会意识消极地受制于社会存在<br>C. 社会意识决定社会存在<br>D. 社会意识具有相对独立性<br>正确答案：A</p>
</li>
<li><p>马克思指出：“正像古代各民族是在想象中. 在神话中经历了自己的史前时期一样，我们德国人在思想中. 在哲学中经历了自己的未来的历史”，这说明（）。<br>A. 社会意识受制于社会存在<br>B. 社会意识能够摆脱社会存在<br>C. 社会意识具有相对独立性<br>D. 社会意识决定社会存在<br>正确答案：C</p>
</li>
<li><p>“法国人的浪漫. 德国人的严谨。不同民族有其不同的思维特点和习惯”，这说明（）。<br>A. 自然地理环境决定社会意识<br>B. 社会意识决定社会发展方式<br>C. 共同的社会意识是民族形成的基础<br>D. 社会意识具有历史继承性<br>正确答案：D</p>
</li>
<li><p>“在中国，‘让’是一种传统美德，文明出行的道德基础，就是‘礼让’。”传统的“让”作为现代文明出行的道德基础，体现了（）。<br>A. 道德的永恒性<br>B. 道德具有继承性<br>C. 道德在社会意识中居于核心<br>D. 道德水平决定社会发展<br>正确答案：B</p>
</li>
<li><p>马克思指出：“理论一经掌握群众，也会变成物质力量。”从唯物史观角度看，这说明（）。<br>A. 社会意识对社会存在具有反作用<br>B. 社会意识决定社会存在<br>C. 群体意识是意识形态的主导<br>D. 哲学理论不具有阶级性<br>正确答案：A</p>
</li>
<li><p>马克思指出：“思想本身根本不能实现什么东西。思想得到实现，就要有使用实践力量的人。”这说明（）。<br>A. 社会意识对社会存在没有影响<br>B. 社会意识不能转化为物质力量<br>C. 社会意识的能动作用是通过指导人们的实践活动实现的<br>D. 人口因素是社会意识产生发展的决定力量<br>正确答案：C</p>
</li>
<li><p>唯物史观和唯心史观的根本分野是（）。<br>A. 对社会存在社会意识关系问题的不同回答<br>B. 对意识和物质关系的不同回答<br>C. 对真理与价值关系的不同回答<br>D. 对认识来源问题的不同回答<br>正确答案：A</p>
</li>
<li><p>在人类思想史上第一次正确回答了社会历史观的基本问题，宣告唯心史观的彻底破产的是（）。<br>A. 费尔巴哈的唯物主义历史观<br>B. 黑格尔的唯心主义历史观<br>C. 马克思主义历史观<br>D. 机械唯物主义历史观<br>正确答案：C</p>
</li>
<li><p>习近平指出：“中华民族从来不是一帆风顺的，遇到了无数艰难困苦，但我们都挺过来. 走过来了，其中一个很重要的原因就是世世代代的中华儿女培育和发展了独具特色. 博大精深的中华文化。”这说明（）。<br>A. 文化是社会发展的决定力量<br>B. 文化为社会发展提供精神动力<br>C. 文化决定其他一切社会关系<br>D. 文化都具有积极作用<br>正确答案：B</p>
</li>
<li><p>科学技术突飞猛进，人工智能和生物技术加速发展，人类社会正进入一个前所未有的历史性变化，在这场技术驱动的大变局中，出现了哲学“无用”的哲学终结论。这种观点的局限性在于（）。<br>A. 弱化了社会存在的决定力量<br>B. 夸大了社会意识的相对独立性<br>C. 忽视了社会意识的能动作用<br>D. 割裂了社会意识的历史继承性<br>正确答案：C</p>
</li>
<li><p>马克思指出：“一旦人开始生产自己的生活资料，即迈出由他们的肉体组织所决定的这一步的时候，人本身就开始把自己和动物区别开来。”这说明（）。<br>A. 人的肉体组织是人类历史的物质基础<br>B. 生产力是人类生活和历史的物质基础<br>C. 人与动物分别是生产的目的<br>D. 人与动物的生产是同的<br>正确答案：B</p>
</li>
<li><p>劳动资料也称劳动手段，是人们在劳动过程中所运用的物质资料或物质条件，其中最重要的是（）。<br>A. 生产工具<br>B. 劳动技能<br>C. 劳动意识<br>D. 科学知识<br>正确答案：A</p>
</li>
<li><p>在生产力的基本要素中，（）是生产力中最活跃的因素。<br>A. 劳动者<br>B. 生产工具<br>C. 劳动对象<br>D. 劳动产品<br>正确答案：A</p>
</li>
<li><p>利用无人机作业喷药防控与常规喷雾. 烟雾防治相比较，可提高喷药速度. 减少人工成本，提高防治效果. 减少农药使用量，极大地提高了农业植保效率。这说明（）。<br>A. 科学知识是生产力中最活跃的因素<br>B. 科学技术是社会发展的基础和决定力量<br>C. 科学技术是第一生产力<br>D. 科学技术一定有利于人类社会发展<br>正确答案：C</p>
</li>
<li><p>人们解决社会同自然矛盾的实际能力如何主要取决于（）。<br>A. 主观意志的坚定与否<br>B. 理论思维的发展程度<br>C. 生产工具的质量和数量<br>D. 自然界的发展阶段<br>正确答案：C</p>
</li>
<li><p>区分不同生产方式. 判定社会经济结构性质的客观依据是（）。<br>A. 生产工具的性质<br>B. 生产资料所有制<br>C. 劳动者发展程度<br>D. 科学技术水平<br>正确答案：B</p>
</li>
<li><p>马克思在《政治经济学批判》中指出：“经济学研究的不是物，而是人和人之间的关系”，这说明生产关系（）。<br>A. 不具有客观实在性<br>B. 属于社会意识领域<br>C. 是人在物质生产过程中所形成的联系和关系<br>D. 以人的意志为转移<br>正确答案：C</p>
</li>
<li><p>马克思曾说：“手推磨产生的是封建社会，蒸汽磨产生的是工业资本家的社会。”这说明（）。<br>A. 生产工具是生产力中最活跃的因素<br>B. 生产工具的性质是区分不同社会形态的标志<br>C. 生产力状况决定生产关系的性质<br>D. 科学技术的发展是社会形态更替的主要标志<br>正确答案：C</p>
</li>
<li><p>马克思曾说：“（人们）在行会制度及各种规则的保护下积累了资本，发展了海上贸易，建立了殖民地，而人们如果想把这些果实赖以成熟起来的那些形式保存下去，他们就会失去这一切果实。”这说明（）。<br>A. 生产力的发展决定生产关系的变化<br>B. 生产关系不能促进生产力的发展<br>C. 社会制度是社会关系中最基本的关系<br>D. 生产关系的作用只在资本原始积累阶段发生<br>正确答案：A</p>
</li>
<li><p>在生产力与生产关系的矛盾运动中内在的. 本质的. 必然的联系，就是（）。<br>A. 生产关系决定生产力定律<br>B. 上层建筑决定经济基础规律<br>C. 意识决定物质规律<br>D. 生产关系一定要适合生产力状况的规律<br>正确答案：D</p>
</li>
<li><p>（）是政治上层建筑的核心。<br>A. 经济体制<br>B. 国家政权<br>C. 政治法律思想<br>D. 劳动者<br>正确答案：B</p>
</li>
<li><p>马克思认为国家是社会矛盾不可调和的产物，国家的实质是（）。<br>A. 生产力的主要标志<br>B. 绝对理念的伦理实体<br>C. 阶级统治的工具<br>D. 社会发展的最高形式<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“不管是在波斯和印度兴起和衰落的专制政府有多少，每一个专制政府都十分清楚地知道它们首先是河谷灌溉的总管。”这说明（）。<br>A. 地理环境决定上层建筑<br>B. 国家是为经济基础所服务的<br>C. 专制制度没有适应过生产力发展<br>D. 农业只能在专制制度下存在<br>正确答案：B</p>
</li>
<li><p>指明社会各阶级在国家中的地位，表明国家政权掌握在哪个阶级手里的是（）。<br>A. 政体<br>B. 法律<br>C. 国体<br>D. 宗教<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯指出：“某一个地域创造出来的生产力，特别是发明，在往后的发展中是否会失传，完全取决于交往拓展的情况。”这说明（）。<br>A. 交往决定社会形态<br>B. 交往是科学技术发展的基础<br>C. 交往决定生产力的发展水平<br>D. 交往有益于生产力成果的保存<br>正确答案：D</p>
</li>
<li><p>马克思. 恩格斯指出：“一个人的发展取决于和他直接或间接进行交往的其他一切人的发展”，这说明（）。<br>A. 交往能够促进人的全面发展<br>B. 交往是社会关系中最基本的关系<br>C. 交往是人的本质<br>D. 个人被动地受制于社会<br>正确答案：A</p>
</li>
<li><p>唯物史观视域中的“世界历史”是指（）。<br>A. 自然界迄今为止的运动变化过程<br>B. 人类文明迄今为止的运动变化过程<br>C. 绝对精神的辩证运动过程<br>D. 各民族. 国家通过普遍交往，打破孤立隔绝的状态，进入相互依存. 相互联系的世界整体化的历史<br>正确答案：D</p>
</li>
<li><p>世界历史形成和发展的基础是（）。<br>A. 人类理性的觉醒<br>B. 生产方式的发展变革<br>C. 民主制度的大力推行<br>D. 法律的普及程度<br>正确答案：B</p>
</li>
<li><p>世界历史的基本特征是（）。<br>A. 理性至上<br>B. 国家消亡<br>C. 普遍交往<br>D. 实现共产主义<br>正确答案：C</p>
</li>
<li><p>社会形态包括经济形态. 政治形态和意识形态，其中（）是社会形态的基础。<br>A. 经济形态<br>B. 政治形态<br>C. 意识形态<br>D. 社会心理<br>正确答案：A</p>
</li>
<li><p>社会形态更替的统一性与多样性，根源于（）。<br>A. 经济基础和上层建筑的矛盾<br>B. 生产力和生产关系的矛盾<br>C. 社会形态和社会制度的矛盾<br>D. 社会发展的客观必然性和人的历史选择性相统一的过程<br>正确答案：D</p>
</li>
<li><p>社会形态更替的过程归根结底是社会基本矛盾运动的结果，其中（）的发展具有最终决定意义。<br>A. 经济基础<br>B. 自然地理环境<br>C. 生产力<br>D. 上层建筑<br>正确答案：C</p>
</li>
<li><p>资本主义制度在欧洲而并非在封建制度高度发展完善的中国等东方国家首先取得胜利，这说明（）。<br>A. 社会形态更替具有顺序性<br>B. 社会形态更替具有统一性<br>C. 社会形态更替与旧制度发展程度无关<br>D. 社会形态更替具有跨越性<br>正确答案：D</p>
</li>
<li><p>我国农村推广多种形式的承包责任制之所以促进了生产力的发展，在于它遵循了（）。<br>A. 生产关系适合生产力状况的规律<br>B. 上层建筑适合经济基础的规律<br>C. 社会存在决定社会意识的规律<br>D. 阶级斗争推动阶级社会发展的规律<br>正确答案：A</p>
</li>
<li><p>在现代化建设的新时期，党和国家进行社会主义核心价值观教育，形成了强大的凝聚力，这在哲学上的依据是（）。<br>A. 生产力对生产关系的决定作用原理<br>B. 社会意识对社会存在的能动反作用原理<br>C. 经济基础决定上层建筑的原理<br>D. 社会意识决定社会存在原理<br>正确答案：B</p>
</li>
<li><p>“许多事情我们可以讲一千个理由. 一万个理由，但老百姓吃不上饭，就没有理由。‘民以食为天’”。这段话表明（）。<br>A. 人们首先必须吃. 喝. 住. 穿，然后才能从事政治. 科技. 艺术. 宗教等等活动<br>B. 人的生理需求是历史的基础<br>C. 人的自然属性决定着人的本质<br>D. 人的物质欲望是社会发展的根本动力<br>正确答案：A</p>
</li>
<li><p>人类社会发展和进步的最终决定力量是（）。<br>A. 自我意识<br>B. 绝对精神<br>C. 经济基础<br>D. 生产力<br>正确答案：D</p>
</li>
<li><p>恩格斯指出：“17世纪和18世纪从事制造蒸汽机的人们也没有料到，他们制作的工具，比其他任何东西都能更使全世界的社会状态发生革命。”这说明（）。<br>A. 生产工具是生产力中最活跃的因素<br>B. 生产力决定世界发展的历史进程<br>C. 人不能认识生产力和生产关系的运动规律<br>D. 社会革命只能由生产工具更替引起<br>正确答案：B</p>
</li>
<li><p>衡量社会进步的根本尺度是（）。<br>A. 社会的道德文明程度<br>B. 人的理智发展程度<br>C. 经济制度的完善程度<br>D. 生产力的发展程度<br>正确答案：D</p>
</li>
<li><p>在人的物质生产中存在着双重关系，其中生产关系中所体现的是（）。<br>A. 人与自然的关系<br>B. 人与人的关系<br>C. 意识与意识的关系<br>D. 共性与个性的关系<br>正确答案：B</p>
</li>
<li><p>社会物质文明发展的基本内容是（）。<br>A. 人的理智发展<br>B. 人的体力的发展<br>C. 生产力的发展<br>D. 普遍交往的发展<br>正确答案：C</p>
</li>
<li><p>以下社会矛盾中，更为基本的矛盾是（）。<br>A. 经济基础与上层建筑之间的矛盾<br>B. 生产力与生产关系之间的矛盾<br>C. 社会形态更替的统一性与多样性之间的矛盾<br>D. 资产阶级与无产阶级之间的矛盾<br>正确答案：B</p>
</li>
<li><p>马克思. 恩格斯指出：“一切历史冲突都根源于生产力和交往形式之间的矛盾”，这说明（）。<br>A. 生产力和生产关系决定着其他矛盾的存在和发展<br>B. 经济基础和上层建筑的矛盾在社会基本矛盾中更为基本<br>C. 由于基本矛盾的存在社会形态更替必然采取社会革命的形式<br>D. 交往形式是衡量社会进步的根本尺度<br>正确答案：A</p>
</li>
<li><p>在同一社会形态的发展中，社会基本矛盾通常是通过（）的方式来解决的。<br>A. 革命<br>B. 冲突<br>C. 改革<br>D. 妥协<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“为了达到伟大的目标和团结，为此所必需的千百万大军应当时刻记住主要的东西，不因那些无畏的吹毛求疵而迷失方向。”这句话旨在强调要（）。<br>A. 抓住社会基本矛盾<br>B. 抓住社会主要矛盾<br>C. 认识社会非主要矛盾<br>D. 避免社会矛盾<br>正确答案：B</p>
</li>
<li><p>（）是阶级社会发展的直接动力。<br>A. 科学技术<br>B. 社会改革<br>C. 制度改良<br>D. 阶级斗争<br>正确答案：D</p>
</li>
<li><p>阶级斗争根源于阶级之间（）的根本对立。<br>A. 意识形态<br>B. 政治制度<br>C. 物质利益<br>D. 社会心理<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯在《共产党宣言》中指出：“至今一切社会的历史都是阶级斗争的历史”，这说明（）。<br>A. 阶级矛盾是社会基本矛盾<br>B. 阶级斗争永远存在<br>C. 阶级斗争是阶级社会发展的直接动力<br>D. 阶级斗争是历史的创造者<br>正确答案：C</p>
</li>
<li><p>（）是最有前途. 最富有革命彻底性的阶级。<br>A. 资产阶级<br>B. 地主阶级<br>C. 农民阶级<br>D. 无产阶级<br>正确答案：D</p>
</li>
<li><p>列宁指出：“马克思主义提供了一条指导性线索，是我们能在这种看来扑朔迷离. 一团混乱的状态中发现规律性。……只有研究某一社会或某几个社会的全体成员的意向的总和，才能科学地确定这些意向的结果。”这条“线索”是指（）。<br>A. 辩证法理论<br>B. 劳动价值论<br>C. 唯物反映论<br>D. 阶级斗争理论<br>正确答案：D</p>
</li>
<li><p>（）是实现社会形态变革的首要. 基本的标志。<br>A. 国家意识形态采取新的形式<br>B. 社会经济体制发生变革<br>C. 社会基本矛盾彻底解决<br>D. 国家政权转移到革命阶级手里<br>正确答案：D</p>
</li>
<li><p>社会革命根源于（）。<br>A. 社会意识形态对立的极端化<br>B. 社会基本矛盾的尖锐化<br>C. 社会主要矛盾的转化<br>D. 国家政体的变化<br>正确答案：B</p>
</li>
<li><p>马克思指出：“于是这些关系便由生产力的发展形式变成生产力的桎梏。那时社会革命的时代就到来了。”这说明（）。<br>A. 只有在生产关系不适合生产力发展时，社会基本矛盾才起作用<br>B. 只要社会基本矛盾存在就一定发生革命<br>C. 社会革命根源于社会基本矛盾的尖锐化<br>D. 生产力的发展只能通过革命的手段<br>正确答案：C</p>
</li>
<li><p>马克思指出：“革命是历史的火车头”，这说明（）。<br>A. 社会革命是历史的创造者<br>B. 社会革命是历史发展的根本动力<br>C. 改良对社会发展毫无作用<br>D. 社会革命是社会进步的强大推力<br>正确答案：D</p>
</li>
<li><p>（）是指对自然. 社会和人类思维的正确认识，是反映客观事实和客观规律的知识体系及其相关的活动。<br>A. 技术<br>B. 实践<br>C. 意识<br>D. 科学<br>正确答案：D</p>
</li>
<li><p>马克思指出科学是“最明显的字面意义而言的革命力量”，这说明（）。<br>A. 科学是社会革命的集中表现<br>B. 科学是社会形态更替的决定性环节<br>C. 科学具有推动社会发展的强大力量<br>D. 科学发展是社会革命的根源<br>正确答案：C</p>
</li>
<li><p>随着北京再次申奥成功，冰雪运动成为中国人民关注的热点，在此次冰雪运动热潮中，大批网络滑雪小组. 论坛涌现，通过网络“寻友组队”成为大部分滑雪爱好者的第一需求。从唯物史观角度看，这体现了（）。<br>A. 虚拟交往是交往的主要形式<br>B. 现代信息技术革命对生活方式产生巨大影响<br>C. 精神交往是物质交往的基础<br>D. 科学技术革命改变生产方式<br>正确答案：B</p>
</li>
<li><p>正确认识和运用科学技术，首要的就是有（）。<br>A. 高度发达的科技水平<br>B. 大批科研工作者<br>C. 合理的社会制度<br>D. 哲学等意识形态的辅助<br>正确答案：C</p>
</li>
<li><p>人们自己创造自己的历史，因此历史发展的方向是由人自觉选定的，这是（）。<br>A. 历史唯物主义的观点<br>B. 宿命论观点<br>C. 唯意志论观点<br>D. 机械唯物主义观点<br>正确答案：C</p>
</li>
<li><p>群众追随英雄创造历史，这是（）。<br>A. 辩证唯物主义的观点<br>B. 历史唯心主义的观点<br>C. 机械决定论的观点<br>D. 二元论的观点<br>正确答案：B</p>
</li>
<li><p>坚持无产阶级政党的群众观点，就是坚信（）。<br>A. 人民群众的意见全都是正确的<br>B. 人民群众自己解放自己<br>C. 人民群众都有高度的共产主义觉悟<br>D. 人民群众永远能天然地认识历史发展规律<br>正确答案：B</p>
</li>
<li><p>唯物史观和唯心史观在谁是历史创造者问题上的根本对立在于是否承认（）。<br>A. 人的意识在历史活动中有能动作用<br>B. 人民群众是历史的创造者<br>C. 杰出人物在历史上的突出作用<br>D. 知识分子在历史上起决定作用<br>正确答案：B</p>
</li>
<li><p>马克思主义揭示人的本质的出发点是（）。<br>A. 人的自身需要<br>B. 人类的共同利益<br>C. 人的社会关系<br>D. 人的自然属性<br>正确答案：C</p>
</li>
<li><p>人民群众创造历史的活动，首先是（）。<br>A. 政治活动<br>B. 科学活动<br>C. 生产活动<br>D. 艺术活动<br>正确答案：C</p>
</li>
<li><p>（）是社会革命的主力军，他们在社会形态更替的过程中发挥了巨大作用。<br>A. 人民群众<br>B. 资产阶级<br>C. 思想家<br>D. 统治阶级<br>正确答案：A</p>
</li>
<li><p>历史人物在历史上的作用表现为（）。<br>A. 改变历史发展的方向<br>B. 改变历史发展的规律<br>C. 决定历史时代的根本特点<br>D. 加速或延缓历史的发展<br>正确答案：D</p>
</li>
<li><p>人民群众对历史的创造作用总是受到社会历史条件的制约，其根本的条件是指（）。<br>A. 人们的生活水平<br>B. 人们头脑中的意识<br>C. 科学文化水平<br>D. 生产力和生产关系的状况<br>正确答案：D</p>
</li>
<li><p>英雄人物的活动是理解历史发展的基本线索，这种观点是（）。<br>A. 辩证主义的观点<br>B. 唯物史观的观点<br>C. 历史主义的观点<br>D. 历史唯心主义<br>正确答案：D</p>
</li>
<li><p>社会精神财富的源泉是（）。<br>A. 人民群众的社会实践<br>B. 脑力劳动者的集体智慧<br>C. 思想家们的创造性思维<br>D. 客观的物质世界<br>正确答案：A</p>
</li>
<li><p>马克思主义认为，人的本质在其现实性上是（）。<br>A. 一切社会关系的总和<br>B. 政治关系的总和<br>C. 一切思想关系的总和<br>D. 自然属性和社会属性的总和<br>正确答案：A</p>
</li>
<li><p>（）第一次科学回答了谁是历史的创造者. 怎样看待人民群众和个人的历史作用等问题。<br>A. 黑格尔辩证法的历史观<br>B. 费尔巴哈唯物主义的历史观<br>C. 马克思主义唯物史观<br>D. 现代自然科学历史观<br>正确答案：C</p>
</li>
<li><p>从认识根源看，英雄史观之所以产生，主要是因为（）。<br>A. 认识不能正确反映世界<br>B. 认识只能是对自然的认识<br>C. 人们的认识停留在历史现象的表面<br>D. 人们的认识对历史进行了抽象把握<br>正确答案：C</p>
</li>
<li><p>（）最终决定历史发展的结局。<br>A. 自然地理环境的发展限度<br>B. 人类理性的觉醒程度<br>C. 国家体制的完善程度<br>D. 人民群众的社会实践<br>正确答案：D</p>
</li>
<li><p>一切精神财富. 精神产品形成和发展的源泉是（）。<br>A. 绝对理念的实体化<br>B. 意识形态家的理性创造<br>C. 人民群众的生活. 实践<br>D. 情感等非理性因素<br>正确答案：C</p>
</li>
<li><p>在诸多阶级组织中，最集中. 最严密. 最高级的形式是（）。<br>A. 集团<br>B. 行会<br>C. 政党<br>D. 同盟<br>正确答案：C</p>
</li>
<li><p>马克思曾批判雨果的《小拿破仑》，认为“他认为这个事变只是某一个人的暴力行为。他没有觉察到，当他说这个人表现了世界历史上空前强大的个人主动性时，他就不是把这个人写成小人物而是写成巨人了。”这说明马克思认为雨果在这里（）。<br>A. 忽视了意识的能动作用<br>B. 混淆了谁是历史的创造者<br>C. 否认了社会革命的推动作用<br>D. 抹杀了杰出人物的历史作用<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选-3"><a href="#多选-3" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>唯心史观的主要缺陷有（）。<br>A. 没有考究思想动机背后的物质动因和经济根源<br>B. 把社会历史看成精神发展史<br>C. 不懂社会历史的客观规律<br>D. 不懂人民群众在社会历史发展中的决定作用<br>正确答案：ABCD</p>
</li>
<li><p>社会存在主要是指社会物质生活条件，是社会生活的物质方面，主要包括（）。<br>A. 社会心理<br>B. 自然地理环境<br>C. 人口因素<br>D. 物质生产方式<br>正确答案：BCD</p>
</li>
<li><p>物质生产方式是社会发展的决定力量，体现在（）。<br>A. 物质生产活动及生产方式是人类社会赖以生存和发展的基础<br>B. 物质生产活动及生产方式决定着社会的结构. 性质和面貌<br>C. 物质生产活动及生产方式制约着人们的经济生活. 政治生活和精神生活<br>D. 物质生产活动及生产方式的变化发展决定整个社会历史的变化发展<br>正确答案：ABCD</p>
</li>
<li><p>根据不同的层次，社会意识可以分为（）。<br>A. 社会心理<br>B. 社会意识形式<br>C. 个体意识<br>D. 群体意识<br>正确答案：AB</p>
</li>
<li><p>以下各项中，属于意识形态的有（）。<br>A. 政治法律思想<br>B. 道德<br>C. 艺术<br>D. 自然科学<br>正确答案：ABC</p>
</li>
<li><p>马克思唯物史观的“两个划分”和“两个归结”对于正确认识社会历史具有重要意义，以下各项中，属于“两个划分”与“两个归结”的有（）。<br>A. 从社会生活各领域中划分出经济领域<br>B. 从一切社会关系中划分出生产关系<br>C. 把一切社会关系归结于生产关系<br>D. 把生产关系归结于生产力发展<br>正确答案：ABCD</p>
</li>
<li><p>文化对社会发展的重要作用表现在（）。<br>A. 文化为社会发展提供思想保证<br>B. 文化为社会发展提供精神动力<br>C. 文化为社会发展提供智力支持<br>D. 文化为社会发展提供凝聚力量<br>正确答案：ABCD</p>
</li>
<li><p>恩格斯说：“一个民族要想站在科学的最高峰，就一刻也不能没有理论思维。”哲学社会科学的重要性在于（）。<br>A. 反映一个民族的思维能力. 精神品格. 文明素质，体现了一个国家的综合国力和国际竞争力<br>B. 一个国家的发展水平，既取决于自然科学发展水平，也取决于哲学社会科学发展水平<br>C. 是人们认识世界. 改造世界的重要工具<br>D. 是推动历史发展和社会进步的重要力量<br>正确答案：ABCD</p>
</li>
<li><p>人类社会的基本矛盾是（）。<br>A. 共性与个性的矛盾<br>B. 客观规律性与主观能动性的矛盾<br>C. 生产力与生产关系的矛盾<br>D. 经济基础与上层建筑之间的矛盾<br>正确答案：CD</p>
</li>
<li><p>人类社会发展的基本规律是（）。<br>A. 能量守恒定律<br>B. 剩余价值规律<br>C. 生产力与生产关系的矛盾运动规律<br>D. 经济基础与上层建筑之间的矛盾运动规律<br>正确答案：CD</p>
</li>
<li><p>深入理解生产力范畴，需要把握生产力的水平. 性质. 状况和发展要求等重要方面，以下各项中正确的有（）。<br>A. 生产力的水平表现为生产发展的现实程度<br>B. 生产力的性质取决于生产的物质技术性质<br>C. 生产力的状况表现为生产力的运行状态和发展态势<br>D. 生产力的发展要求指现实的生产力不断获得解放和发展的基本要求<br>正确答案：ABCD</p>
</li>
<li><p>生产力的基本要素包括（）。<br>A. 劳动意识<br>B. 劳动资料<br>C. 劳动对象<br>D. 劳动者<br>正确答案：BCD</p>
</li>
<li><p>科学技术对生产力发展的重要意义在于（）。<br>A. 科学技术能够转化为实际生产能力<br>B. 科学技术会引起劳动资料. 劳动对象和劳动者素质的深刻变革和巨大进步<br>C. 科学技术能大幅提高管理效率和劳动生产率<br>D. 科学技术是先进生产力的集中体现和主要标志<br>正确答案：ABCD</p>
</li>
<li><p>依据生产资料所有制性质，生产关系区分为以生产资料私有制为基础的生产关系和以生产资料公有制为基础的生产关系，后者的根本特征是（）。<br>A. 生产资料为劳动者共同占有<br>B. 人们在生产过程中处于平等地位<br>C. 在产品分配上不存在剥削<br>D. 只在共产主义社会中存在<br>正确答案：ABC</p>
</li>
<li><p>关于生产关系对生产力能动的反作用，下列说法中正确的有（）。<br>A. 当生产关系适合生产力发展的客观要求时，对生产力起推动作用<br>B. 当生产关系不适合生产力发展的客观要求时，对生产力起阻碍作用<br>C. 生产关系推动生产力发展<br>D. 生产关系阻碍生产力发展<br>正确答案：AB</p>
</li>
<li><p>以下各项中，属于上层建筑的有（）。<br>A. 经济体制<br>B. 法律<br>C. 哲学<br>D. 政体<br>正确答案：BCD</p>
</li>
<li><p>关于观念上层建筑和政治上层建筑的关系，下列说法中正确的有（）。<br>A. 政治上层建筑是在一定意识形态指导下建立的<br>B. 政治上层建筑一旦形成就会影响并制约人们的思想理论观点<br>C. 在整个上层建筑中观念上层建筑居于主导地位<br>D. 在整个上层建筑中政治上层建筑居于主导地位<br>正确答案：ABD</p>
</li>
<li><p>关于国体和政体的关系，下列说法中正确的有（）。<br>A. 国体决定政体<br>B. 政体为国体服务<br>C. 政体决定国体<br>D. 国体为政体服务<br>正确答案：AB</p>
</li>
<li><p>社会主义民主是其他任何国家形态的民主都不能比拟的最广泛的民主，这是因为（）。<br>A. 社会主义民主的本质和核心是人民当家做主<br>B. 人民民主是社会主义的生命<br>C. 社会主义民主是对资产阶级民主的辩证否定<br>D. 社会主义民主是民主发展的历史性飞跃<br>正确答案：ABCD</p>
</li>
<li><p>关于经济基础上层建筑的辩证关系，下列认识中正确的有（）。<br>A. 经济基础决定上层建筑<br>B. 上层建筑对经济基础具有反作用<br>C. 经济基础与上层建筑相互作用构成二者的矛盾运动<br>D. 经济基础上层建筑之间构成了上层建筑一定要适合经济基础状况的规律<br>正确答案：ABCD</p>
</li>
<li><p>经济基础上层建筑之间构成了上层建筑一定要适合经济基础状况的规律，这里的“一定要适合”指的是（）。<br>A. 经济基础状况决定上层建筑的发展方向<br>B. 经济基础状况决定上层建筑相应的调整或变革<br>C. 上层建筑只能被动地适应经济基础，不具有反作用<br>D. 上层建筑的反作用必须取决于和服从于经济基础的性质和客观要求<br>正确答案：ABD</p>
</li>
<li><p>交往是指一定历史条件下的现实的个人. （）之间在物质和精神上相互往来. 相互作用. 彼此联系的活动。<br>A. 群体<br>B. 阶级<br>C. 民族<br>D. 国家<br>正确答案：ABCD</p>
</li>
<li><p>总体上说可以将交往划分为物质交往和精神交往，关于二者关系，下列认识中正确的有（）。<br>A. 物质交往是精神交往的基础和根源<br>B. 物质交往是精神交往的产物<br>C. 精神交往渗透与物质交往之中<br>D. 精神交往是物质交往的基础和根源<br>正确答案：AC</p>
</li>
<li><p>交往对社会生活的重要影响包括（）。<br>A. 促进生产力发展<br>B. 促进社会关系的进步<br>C. 促进文化的发展与传播<br>D. 促进人的全面发展<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯认为共产主义“是以生产力的普遍发展和与此相联系的世界交往为前提的”，这是因为（）。<br>A. 随着交往和竞争的扩大，生产力空前发展<br>B. 世界历史促使无产阶级走向联合<br>C. 交往是社会形态更替的基础<br>D. 共产主义就是世界历史的特征<br>正确答案：AB</p>
</li>
<li><p>关于社会制度和社会形态的关系，下列说法中正确的有（）。<br>A. 一定的社会形态总要以一定的社会制度形式呈现出来<br>B. 社会制度能够集中体现社会形态的性质<br>C. 人们往往用社会制度指代社会形态<br>D. 社会制度决定了社会形态<br>正确答案：ABC</p>
</li>
<li><p>依据经济基础特别是生产关系的不同性质，社会历史可划分为原始社会. （）。<br>A. 奴隶社会<br>B. 封建社会<br>C. 资本主义社会<br>D. 社会主义社会<br>正确答案：ABCD</p>
</li>
<li><p>人们的历史选择性是指（）。<br>A. 社会发展的客观必然性为人们的历史选择提供了基础. 范围和可能性空间<br>B. 社会形态更替的过程是一个主观能动性与客观规律性相统一的过程<br>C. 人们的历史选择性归根结底是人民群众的选择<br>D. 人们的历史选择性能够创造和改变历史规律<br>正确答案：ABC</p>
</li>
<li><p>面临环境日益被污染的状况，人类越来越重视环境问题，这是因为（）。<br>A. 地理环境是人类物质生活的必要条件<br>B. 地理环境直接决定社会的发展<br>C. 地理环境能决定社会的性质<br>D. 地理环境通过物质生产制约社会发展<br>正确答案：AD</p>
</li>
<li><p>意大利历史学家克罗齐认为：“一切历史都是思想史”，这种观点（）。<br>A. 夸大了思想因素在历史中的作用<br>B. 本质上是唯心史观<br>C. 承认了人民群众在历史发展中的决定作用<br>D. 肯定了历史发展的客观规律性<br>正确答案：AB</p>
</li>
<li><p>英国资产阶级革命开始于1640年，但在战胜封建制度以后，接着就出现了1660年的旧王朝复辟，直到1688年，英国的资本主义社会形态才稳固下来。这说明（）。<br>A. 社会形态更替的前进性<br>B. 社会形态更替的曲折性<br>C. 社会形态更替的多样性<br>D. 社会形态更替的统一性<br>正确答案：AB</p>
</li>
<li><p>马克思指出：“一个社会即使探索到本身运动的自然规律，……它还是既不能跳过也不能用法令取消自然的发展阶段。但是它能缩短和减轻分娩的痛苦。”这表明（）。<br>A. 人类社会的发展是合规律性与合目的性的统一<br>B. 人的自觉选择在社会发展中具有重要作用<br>C. 社会发展过程与自然界演变过程一样都是自觉的<br>D. 人类总体历史进程是不可超越的<br>正确答案：ABD</p>
</li>
<li><p>恩格斯指出旧唯物主义“认为在历史领域中起作用的精神的动力是最终原因，而不去研究……这些动力的动力是什么”，从根本上来说“这些动力的动力”是（）。<br>A. 自然地理环境与人的主观能动性的矛盾<br>B. 绝对理念与自我意识的矛盾<br>C. 生产力和生产关系的矛盾运动<br>D. 经济基础和上层建筑的矛盾运动<br>正确答案：CD</p>
</li>
<li><p>之所以说社会基本矛盾是推动社会历史发展的根本动力，是因为（）。<br>A. 社会基本矛盾决定了各种社会矛盾的产生和发展<br>B. 社会基本矛盾决定了各种社会矛盾之间的关系及其转变<br>C. 社会基本矛盾决定了社会形态由低级向高级的发展<br>D. 阶级斗争. 社会革命. 社会改革等都根源于社会基本矛盾<br>正确答案：ABCD</p>
</li>
<li><p>经济基础和上层建筑的矛盾之所以会影响和制约生产力和生产关系的矛盾，是因为（）。<br>A. 生产力与生产关系的矛盾的最终解决有赖于经济基础和上层建筑矛盾的解决<br>B. 生产关系的变化受制于上层建筑的变化<br>C. 当上层建筑不适应经济基础状况时，只有解决了经济基础和上层建筑的矛盾才能解放生产力<br>D. 经济基础上层建筑之间的矛盾是更为基本的矛盾<br>正确答案：ABC</p>
</li>
<li><p>在社会发展一定阶段上，由于社会经济. 政治. 文化等因素的变化，原有社会主要矛盾会朝着（）等方面转化。<br>A. 社会主要矛盾双方的内容发生一定变化<br>B. 矛盾地位发生变化<br>C. 成为基本矛盾<br>D. 决定基本矛盾<br>正确答案：AB</p>
</li>
<li><p>党的十九大指出，新时代我国社会主要矛盾已经发生转化，这种转化的客观依据有（）。<br>A. 人民美好生活需要日益广泛<br>B. 在民主. 法治. 公平. 正义. 安全. 环境等方面的要求日益增长<br>C. 发展的不平衡不充分成为满足人民日益增长的美好生活需要的主要制约因素<br>D. 社会基本矛盾在我国已经得到解决<br>正确答案：ABC</p>
</li>
<li><p>社会革命的实质是（）。<br>A. 革命阶级推翻反动阶级的统治<br>B. 新的社会制度代替旧的社会制度<br>C. 解放生产力<br>D. 推动社会发展<br>正确答案：ABCD</p>
</li>
<li><p>革命对社会发展的巨大作用包括（）。<br>A. 社会革命是实现社会形态更替的重要手段<br>B. 社会革命能充分发挥人民群众创造历史的积极和伟大作用<br>C. 无产阶级革命将为消除阶级对抗，并充分利用全人类的文明成果促进社会全面进步创造条件<br>D. 社会革命促进生产力和生产关系达到新的平衡，最终彻底消除二者矛盾<br>正确答案：ABC</p>
</li>
<li><p>改革在社会历史发展中的作用表现在（）。<br>A. 一定程度上解决社会基本矛盾<br>B. 是促进生产力发展的有效途径<br>C. 是推动社会进步手段<br>D. 是社会形态更替的决定性环节<br>正确答案：ABC</p>
</li>
<li><p>科技革命对生产方式的影响体现在（）。<br>A. 使人从生产主体向生产中介转化<br>B. 改变了社会生产力的构成要素<br>C. 改变了人们的劳动形式<br>D. 改变了社会经济结构<br>正确答案：BCD</p>
</li>
<li><p>科学技术革命所引起的变化包括（）。<br>A. 对生产方式产生深刻影响<br>B. 对生活方式产生巨大影响<br>C. 促进思维方式的变革<br>D. 推动社会发展<br>正确答案：ABCD</p>
</li>
<li><p>从历史观的角度看，“时势造英雄”与“英雄造时势”这两种观点的关系和差异为（）。<br>A. 两种根本对立的历史观<br>B. 前者是唯物史观，后者是唯心史观<br>C. 前者是唯心史观，后者是唯物史观<br>D. 两种不成立的错误观点<br>正确答案：AB</p>
</li>
<li><p>历史发展是“合力”作用的结果，这就是说（）。<br>A. 历史发展无规律可循<br>B. 历史发展是无法认识的<br>C. 历史发展的因素是复杂的<br>D. 社会中的每个人都是“合力”的一部分<br>正确答案：CD</p>
</li>
<li><p>马克思主义群众观点的主要内容包括（）。<br>A. 坚信人民群众自己解放自己<br>B. 全心全意为人民服务<br>C. 一切向人民群众负责<br>D. 虚心向群众学习<br>正确答案：ABCD</p>
</li>
<li><p>正确评价历史人物应该坚持（）。<br>A. 以成败论英雄的方法<br>B. 荣誉分析的方法<br>C. 历史分析方法<br>D. 阶级分析方法<br>正确答案：CD</p>
</li>
<li><p>下列各项中，属于无产阶级政党的群众路线内容的有（）。<br>A. 一切依靠群众<br>B. 一切按照群众的意见和要求办<br>C. 一切为了群众<br>D. 从群众中来，到群众中去<br>正确答案：ACD</p>
</li>
<li><p>唯物史观在考察谁是历史的创造者时坚持的原则包括（）。<br>A. 立足于现实的人及其本质来把握历史的创造者<br>B. 立足于整体的社会历史过程来探究谁是历史的创造者<br>C. 从社会历史发展的必然性入手来考察和说明谁是历史的创造者<br>D. 从人与历史关系的不同层次上考察谁是历史的创造者<br>正确答案：ABCD</p>
</li>
<li><p>在当代中国，人民群众包括（）。<br>A. 全体社会主义劳动者<br>B. 社会主义事业的建设者<br>C. 拥护社会主义的爱国者<br>D. 拥护祖国统一和致力于中华民族伟大复兴的爱国者<br>正确答案：ABCD</p>
</li>
<li><p>毛泽东指出：“人民，只有人民，才是创造世界历史的动力”，从唯物史观来看这是因为（）。<br>A. 生产力的发展必须借助人民的力量<br>B. 人民是社会革命的主力军<br>C. 人民推动了生产关系变革<br>D. 人民是社会历史发展的根本动力<br>正确答案：ABC</p>
</li>
<li><p>“我们党打江山. 守江山，守的就是人民的心。”这是因为（）。<br>A. 人民是历史的创造者<br>B. 社会心理是社会历史发展的决定力量<br>C. 中国共产党为人民而生. 因人民而兴<br>D. 中国共产党根基在人民. 血脉在人民<br>正确答案：ACD</p>
</li>
<li><p>关于群众. 阶级. 政党. 领袖的关系，下列说法中正确的是（）。<br>A. 群众是划分阶级的<br>B. 阶级通常是由政党领导的<br>C. 政党是由领袖来主持的<br>D. 群众. 阶级. 政党. 领袖构成一个有机整体<br>正确答案：ABCD</p>
</li>
<li><p>群众. 阶级. 政党. 领袖环环相扣. 相互依存，这启示我们，发展中国特色社会主义事业要（）。<br>A. 坚持党的群众观点群众路线<br>B. 巩固党的阶级基础和群众基础<br>C. 确保党的坚强领导核心地位<br>D. 更好发挥人民领袖的领导作用<br>正确答案：ABCD</p>
</li>
<li><p>唯物史观在考察谁是历史的创造者时坚持的原则有（）。<br>A. 立足于现实的人及其本质来把握历史的创造者<br>B. 从社会历史发展的偶然性入手来考察和说明谁是历史的创造者<br>C. 立足于整体的社会历史过程来探究谁是历史的创造者<br>D. 从人与历史关系的不同层次上考察谁是历史的创造者<br>正确答案：ACD</p>
</li>
</ol>
<h3 id="判断-3"><a href="#判断-3" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>自然地理环境是人类社会生存和发展永恒的. 必要的条件。<br>对</p>
</li>
<li><p>人口是重要的社会物质条件，对社会的性质和社会形态更替起决定作用。<br>错</p>
</li>
<li><p>相较于社会心理，社会意识形式是更低层次的社会意识，是自发的. 不系统的，不定型的社会意识。<br>错</p>
</li>
<li><p>在阶级社会中，占统治地位的思想文化，本质上是经济上占统治地位的阶级的意识形态，具有鲜明的政治属性。<br>对</p>
</li>
<li><p>文化蕴含着人类的思想智慧. 价值追求和审美情趣，是一个国家. 一个民族的灵魂。<br>对</p>
</li>
<li><p>文化自信是更基础. 更广泛. 更深厚的自信，是更基本. 更深沉. 更持久的力量。<br>对</p>
</li>
<li><p>中国特色社会主义文化积淀着中华民族最深层的精神追求，代表着中华民族独特的精神标识，是中国人民胜利前行的强大精神力量。<br>对</p>
</li>
<li><p>文化的核心是价值观。<br>对</p>
</li>
<li><p>生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。<br>对</p>
</li>
<li><p>一切自然物质都是现实的劳动对象。<br>错</p>
</li>
<li><p>在高新技术领域，脑力劳动和体力劳动具有直接同一的趋势。<br>对</p>
</li>
<li><p>在生产关系中，生产资料所有制关系是最基本的，它是人们进行物质资料生产的前提。<br>对</p>
</li>
<li><p>生产力和生产关系的有机统一，构成社会的生产方式，其中生产力是居支配地位. 起决定作用的方面。<br>对</p>
</li>
<li><p>新的生产关系总是完全适应生产力的发展状况。<br>错</p>
</li>
<li><p>生产力是推动社会进步的最活跃. 最革命的要素。<br>对</p>
</li>
<li><p>社会主义的根本任务是解放和发展社会生产力。<br>对</p>
</li>
<li><p>特定社会的发展阶段上往往只存在一种生产关系。<br>错</p>
</li>
<li><p>经济体制与生产力发展的关系更为直接. 更为具体，它在实践中总是与社会的基本经济制度结合在一起。<br>对</p>
</li>
<li><p>国家是一定历史阶段的产物，从原始社会开始就已经存在。<br>错</p>
</li>
<li><p>国家是经济上占支配地位的阶级为维护其根本利益而建立起来的强制性暴力机关。<br>对</p>
</li>
<li><p>经过无产阶级专政这种过渡形态，随着阶级消亡，国家才会消亡。<br>对</p>
</li>
<li><p>同一国体只能采取同一政体，同一政体只能适应固定的国体。<br>错</p>
</li>
<li><p>孤立. 封闭. 隔绝总是与落后的社会生产力水平相联系，而交流. 交往. 开放则往往与先进的社会生产力水平相联系。<br>对</p>
</li>
<li><p>人类历史向世界历史的转变是资本主义生产方式出现和向世界扩张的结果。<br>对</p>
</li>
<li><p>世界历史最重要的是强调整个世界的相互关联，任何民族. 任何国家都不能拒斥普遍交往。<br>对</p>
</li>
<li><p>社会历史形态更替的统一性表明，某一国家在发展过程中无法超越某一社会形态而实现跨越式发展。<br>错</p>
</li>
<li><p>观念上层建筑是观念结构中的主要部分。<br>对</p>
</li>
<li><p>生产力是社会进步的根本内容。<br>对</p>
</li>
<li><p>只有在生产力发展的基础上，才有可能充分满足人民群众的物质生活和精神生活的需要。<br>对</p>
</li>
<li><p>在阶级社会中，社会基本矛盾往往会通过一定社会的阶层或阶级的矛盾表现出来。<br>对</p>
</li>
<li><p>社会主要矛盾是其他一切社会矛盾的根源。<br>错</p>
</li>
<li><p>阶级斗争对社会发展的作用突出地表现在社会形态的更替中。<br>对</p>
</li>
<li><p>阶级斗争归根结底是围绕经济利益展开，因此各阶级都是从自身利益出发，不存在为全人类解放而斗争的阶级。<br>错</p>
</li>
<li><p>新中国成立之后，我国已经不存在阶级斗争了。<br>错</p>
</li>
<li><p>从量变质变规律来看，改革只能带来量变，质变只能依靠革命。<br>错</p>
</li>
<li><p>相较于革命，改革适用于解决现存的社会基本制度问题，把生产力从已经不能容纳它的旧的生产关系中解放出来。<br>错</p>
</li>
<li><p>改革有的是局部的. 浅层次的，但也有的是对生产关系和上层建筑有深层触动和调整。<br>对</p>
</li>
<li><p>科学技术都有利于人的发展。<br>错</p>
</li>
<li><p>生产力的发展和旧的生产关系. 经济基础的发展和旧的上层建筑之间出现矛盾冲突，是社会革命爆发的根本原因。<br>对</p>
</li>
<li><p>人民群众是历史的创造者，所以不受社会历史条件的制约。<br>错</p>
</li>
<li><p>先进的科学文化和思想道德对人民群众创造历史的活动具有积极的促进作用。<br>对</p>
</li>
<li><p>群众路线是我们党在革命. 建设. 改革时期不断取得胜利的重要法宝。<br>对</p>
</li>
<li><p>杰出人物是历史的创造者。<br>错</p>
</li>
<li><p>现实的人及其活动是社会历史存在和发展的前提。<br>对</p>
</li>
<li><p>人民群众创造历史的活动受到一定社会历史条件的制约，其中政治条件对于人民群众创造历史的活动有着首要的. 决定性的影响。<br>错</p>
</li>
<li><p>从质上看，人民群众是指全体社会人口。<br>错</p>
</li>
<li><p>人民群众创造历史的作用是同社会基本矛盾运动推动社会前进的过程相一致的。<br>对</p>
</li>
<li><p>人民群众的总体意愿和行动代表了历史发展的方向。<br>对</p>
</li>
<li><p>知识分子主要从事意识形态的生产，在物质资料生产中没有作用。<br>错</p>
</li>
<li><p>意识形态作为观念上层建筑是统治阶级进行统治的工具，因此只有统治阶级的意识形态家们才是精神生产活动的主体。<br>错</p>
</li>
<li><p>在阶级社会中，群众不是一个绝对同一的整体，而是由不同的阶级构成的。<br>对</p>
</li>
<li><p>一个阶级的政党要领导本阶级进行有组织的活动，就必须有自己的领袖。<br>对</p>
</li>
<li><p>没有政党领导的阶级，不能形成统一的意志和行动。<br>对</p>
</li>
<li><p>无产阶级政党是最广大人民群众利益的最忠实代表。<br>对</p>
</li>
<li><p>先进阶级的政治代表人物能够在革命斗争起着领导核心的作用。<br>对</p>
</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="单选-4"><a href="#单选-4" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>商品经济经历了简单商品经济与发达商品经济两个阶段，其中简单商品经济以生产资料私有制和（）为基础。<br>A. 雇佣劳动<br>B. 个体劳动<br>C. 抽象劳动<br>D. 具体劳动<br>正确答案：B</p>
</li>
<li><p>从政治经济学角度看，自然经济与商品经济的主要区别在于（）。<br>A. 生产主体不同<br>B. 生产方式不同<br>C. 生产工具不同<br>D. 生产目的不同<br>正确答案：D</p>
</li>
<li><p>商品的使用价值反映的是（）。<br>A. 人与人之间的社会关系<br>B. 人与自然之间的物质关系<br>C. 人与世界之间的认识关系<br>D. 人与社会之间交往关系<br>正确答案：B</p>
</li>
<li><p>一切劳动产品所共有的属性是（）。<br>A. 价值<br>B. 交换价值<br>C. 使用价值<br>D. 历史价值<br>正确答案：C</p>
</li>
<li><p>（）构成社会财富的物质内容。<br>A. 抽象劳动<br>B. 使用价值<br>C. 具体劳动<br>D. 价值<br>正确答案：B</p>
</li>
<li><p>（）表现为一种使用价值同另一种使用价值交换的量的比例。<br>A. 使用价值<br>B. 剩余价值<br>C. 交换价值<br>D. 社会价值<br>正确答案：C</p>
</li>
<li><p>从政治经济学来看，阳光不具有价值，但利用太阳能所发的电具有价值，产生这种区别的原因是（）。<br>A. 阳光不是劳动产品，而太阳能发的电是劳动产品<br>B. 阳光不能满足人的需要，而太阳能发的电可以<br>C. 阳光是具体劳动的产物，太阳能发的电是抽象劳动的产物<br>D. 阳光是私人劳动的产物，而太阳能发的电是社会劳动的产物<br>正确答案：A</p>
</li>
<li><p>马克思指出：“一切劳动，一方面是人类劳动力在生理学意义上的耗费，……另一方面是人类劳动力在有一定目的的形式上的耗费”，后者指的是劳动二重性中的（）。<br>A. 抽象劳动<br>B. 具体劳动<br>C. 私人劳动<br>D. 社会劳动<br>正确答案：B</p>
</li>
<li><p>商品价值的量是由（）决定的。<br>A. 商品能满足人的需要的程度<br>B. 商品的自然属性<br>C. 生产商品所耗费的劳动量<br>D. 生产商品所采取的手段和方式<br>正确答案：C</p>
</li>
<li><p>生产商品所耗费的劳动量是按照（）来计量的。<br>A. 劳动者的疲劳程度<br>B. 劳动所耗费的原材料数量<br>C. 生产出的劳动产品的数量<br>D. 劳动所耗费的时间<br>正确答案：D</p>
</li>
<li><p>某企业提高了劳动生产率，生产单位商品的时间大大缩短，但其所生产的单位商品的价值却没有减小，这是因为（）。<br>A. 商品的价值量与劳动时间无关<br>B. 劳动生产率只能影响生产的数量，不能影响生产的质量<br>C. 商品的价值是在交换中形成确定的，和生产无关<br>D. 商品的价值量由社会必要劳动时间决定，而不是个别劳动时间<br>正确答案：D</p>
</li>
<li><p>复杂劳动等于自乘的或多倍的简单劳动，在商品经济条件下，这种换算是（）。<br>A. 劳动者之间的约定<br>B. 小商品生产者通过计算规定的<br>C. 行会等社会组织规定的<br>D. 在商品交换过程中自发实现的<br>正确答案：D</p>
</li>
<li><p>货币是商品经济内在矛盾发展的产物，货币的本质体现了一种（）。<br>A. 自然关系<br>B. 社会关系<br>C. 认识关系<br>D. 政治关系<br>正确答案：B</p>
</li>
<li><p>马克思指出：“商品价值从商品体跳到金体上，像我在别处说过的，是商品的惊险跳跃。这个跳跃如果不成功，摔坏的不是商品，但一定是商品占有者”，这里的“惊险跳跃”指的是（）。<br>A. 商品转化为货币<br>B. 价值转化为使用价值<br>C. 抽象劳动转化为具体劳动<br>D. 社会劳动转化为私人劳动<br>正确答案：A</p>
</li>
<li><p>“不少菜比肉还贵”，这是2021年国庆节后很多消费者的感受，专家分析季节性. 雨水等多重因素导致菜价上涨。从政治经济学角度看，“蔬菜涨价”说明（）。<br>A. 价值规律不起作用<br>B. 市场供求影响了商品的价格<br>C. 商品交换以价格为基础<br>D. 供求决定商品的价值量<br>正确答案：B</p>
</li>
<li><p>马克思指出商品经济的“规则只能作为没有规则性的盲目起作用的平均数规律来为自己开辟道路”，这说明（）。<br>A. 商品经济没有可认识和把握的规律<br>B. 上下波动的价格的平均数与价值相一致<br>C. 价值规律的调节具有自觉性<br>D. 价值与价格无法一致<br>正确答案：B</p>
</li>
<li><p>商品经济的基本矛盾是（）。<br>A. 价值与使用价值的矛盾<br>B. 具体劳动与抽象劳动的矛盾<br>C. 私人劳动与社会劳动的矛盾<br>D. 价值与价格的矛盾<br>正确答案：C</p>
</li>
<li><p>商品经济的交换本质是由（）决定的。<br>A. 私人劳动和社会劳动的矛盾<br>B. 价值和使用价值的矛盾<br>C. 具体劳动和抽象劳动的矛盾<br>D. 生产资料私人占有制和社会化大生产的矛盾<br>正确答案：A</p>
</li>
<li><p>解决私人劳动和社会劳动之间矛盾的唯一途径是（）。<br>A. 生产<br>B. 交换<br>C. 分配<br>D. 消费<br>正确答案：B</p>
</li>
<li><p>相对于英国古典政治经济学，马克思劳动价值论的创新之处在于（）。<br>A. 认识到了商品具有价值和使用价值的二因素<br>B. 提出了社会必要劳动量决定商品价值量<br>C. 区分了具体劳动和抽象劳动<br>D. 提出了劳动创造价值的观点<br>正确答案：C</p>
</li>
<li><p>15世纪后30年，在西欧开始的资本原始积累，就是以（）使生产者与生产资料相分离，资本迅速集中于少数人手中。<br>A. 商品交换<br>B. 暴力手段<br>C. 雇佣劳动<br>D. 社会化生产<br>正确答案：B</p>
</li>
<li><p>马克思指出：“美洲金银产地的发现，土著居民的被剿灭. 被奴役和被埋葬于矿井，对东印度开始进行的征服和掠夺，非洲变成商业性地猎获黑人的场所——这一切标志着资本主义生产时代的曙光”，这说明（）。<br>A. 资本主义改变了土著居民的悲惨命运<br>B. 掠夺黑奴是资本主义的根本规律<br>C. 资本主义通过暴力手段完成原始积累<br>D. 掠夺与暴力是资本主义的绝对规律<br>正确答案：C</p>
</li>
<li><p>表明资本运动的一般目的的资本总公式是（）。<br>A. 商品-货币-商品<br>B. 货币-商品-增殖后的货币<br>C. 劳动-货币-商品<br>D. 原材料-货币-商品<br>正确答案：B</p>
</li>
<li><p>（）是指人的劳动能力，是人的脑力和体力的总和。<br>A. 劳动<br>B. 具体劳动<br>C. 劳动力<br>D. 私人劳动<br>正确答案：C</p>
</li>
<li><p>（）标志着简单商品生产发展到资本主义商品生产的新阶段。<br>A. 劳动力成为商品<br>B. 资本主义制度的确立<br>C. 私人劳动和社会劳动矛盾的解决<br>D. 商品完成“惊险的跳跃”<br>正确答案：A</p>
</li>
<li><p>马克思说：“罗马的奴隶是由锁链，雇佣工人则由看不见的线系在自己的所有者手里。”这里的“看不见的线”指的是（）。<br>A. 市场价值规律<br>B. 以土地为基础的人身依附关系<br>C. 暴力掠夺的资本原始积累<br>D. 在“自由”“平等”形式下的资本家对工人的支配和剥削<br>正确答案：D</p>
</li>
<li><p>劳动力商品的突出特点在于（）。<br>A. 它的使用价值是价值的源泉<br>B. 不具有使用价值<br>C. 不具有价值<br>D. 它的使用价值决定交换价值<br>正确答案：A</p>
</li>
<li><p>劳动力的价值，也就是工人的工资的最低界限是（）。<br>A. 由政府强制规定的<br>B. 资本家按照利润率计算出来的<br>C. 由工人生活上不可缺少的生活资料的价值决定的<br>D. 由工人集体商讨划定的<br>正确答案：C</p>
</li>
<li><p>资本主义生产的直接目的和决定性动机是（）。<br>A. 扩大社会物质财富<br>B. 提高劳动生产率<br>C. 无休止地获取尽可能多的剩余价值<br>D. 实现人的自由全面的发展<br>正确答案：C</p>
</li>
<li><p>资本主义生产过程具有二重性，即（）。<br>A. 既是具体劳动又是抽象劳动<br>B. 既是劳动过程又是价值增殖过程<br>C. 既是商品生产过程又是商品交换过程<br>D. 既是自给自足过程又是交换过程<br>正确答案：B</p>
</li>
<li><p>关于资本主义劳动过程，下列说法中正确的是（）。<br>A. 劳动成果或产品全部归资本家所有<br>B. 是工人自由创造的劳动过程<br>C. 生产以满足资本家的生活需要为目的<br>D. 生产以满足工人的生活需要为目的<br>正确答案：A</p>
</li>
<li><p>所谓价值增殖过程，就是指超过一定点儿延长了的价值形成过程，这里的“一定点儿”指的是（）。<br>A. 资本家的全部投入<br>B. 原材料的价值<br>C. 工人创造的剩余价值<br>D. 对劳动力价值的补偿<br>正确答案：D</p>
</li>
<li><p>在价值增殖过程中，雇佣工人的劳动分为必要劳动和剩余劳动两个部分，其中剩余劳动用于（）。<br>A. 偿还劳动力价值<br>B. 无偿生产剩余价值<br>C. 完成规定工作任务之外的附加任务<br>D. 为雇佣工人创造价值<br>正确答案：B</p>
</li>
<li><p>以下各项中，在资本主义生产过程中属于可变资本的是（）。<br>A. 石油<br>B. 砂糖<br>C. 纱布<br>D. 劳动力<br>正确答案：D</p>
</li>
<li><p>确定资本家对工人的剥削程度，应该用剩余价值和（）相比。<br>A. 全部资本<br>B. 不变资本<br>C. 可变资本<br>D. 固定资本<br>正确答案：C</p>
</li>
<li><p>在必要劳动时间不变的条件下，由于延长工作日的长度或提高劳动强度而生产的剩余价值叫做（）。<br>A. 绝对剩余价值<br>B. 相对剩余价值<br>C. 平均剩余价值<br>D. 垄断剩余价值<br>正确答案：A</p>
</li>
<li><p>马克思在批判资本主义生产方式曾指出：“它靠缩短工人的寿命，在一定期限内延长工人的生产时间”，这是在评价（）的生产方法。<br>A. 相对剩余价值<br>B. 绝对剩余价值<br>C. 价值<br>D. 劳动力价值<br>正确答案：B</p>
</li>
<li><p>相对剩余价值的生产是通过提高（）实现的。<br>A. 个别劳动时间<br>B. 社会必要劳动时间<br>C. 个别劳动生产率<br>D. 社会必要劳动生产率<br>正确答案：D</p>
</li>
<li><p>全社会劳动生产率的提高，是资本家追逐（）的结果。<br>A. 绝对剩余价值<br>B. 平均剩余价值<br>C. 超额剩余价值<br>D. 垄断剩余价值<br>正确答案：C</p>
</li>
<li><p>在无人工厂中，进行生产的自动化的生产线或机器人的价值（）。<br>A. 由其自身再创造出来<br>B. 转移到产品中去<br>C. 成为剩余价值的源泉<br>D. 发生增殖<br>正确答案：B</p>
</li>
<li><p>（）是资本主社会失业现象的根源。<br>A. 资本积累<br>B. 具体劳动和抽象劳动的矛盾<br>C. 私人劳动和社会劳动的矛盾<br>D. 资本集中<br>正确答案：A</p>
</li>
<li><p>（）是资本从一种形式出发，经过一系列形式的变化，又回到原来出发点的运动。<br>A. 资本循环<br>B. 资本周转<br>C. 资本垄断<br>D. 资本平衡<br>正确答案：A</p>
</li>
<li><p>以下各项中，在资本主义生产过程中属于固定资本的是（）。<br>A. 面粉<br>B. 砂糖<br>C. 织布机<br>D. 布料<br>正确答案：C</p>
</li>
<li><p>资本主义条件下，工资的本质是（）。<br>A. 劳动的价值或价格<br>B. 劳动力的价值或价格<br>C. 工人剩余劳动创造的价值<br>D. 工人形成对资本家人身依附的条件<br>正确答案：B</p>
</li>
<li><p>剩余价值在资本家眼中就是利润，利润率反映的是预付资本的增值程度，通过剩余价值与（）相比来计算。<br>A. 可变资本<br>B. 不变资本<br>C. 全部预付资本<br>D. 流动资本<br>正确答案：C</p>
</li>
<li><p>（）是资本主义的基本矛盾。<br>A. 抽象劳动和具体劳动的矛盾<br>B. 私人劳动和社会劳动的矛盾<br>C. 生产资料私人占有和生产社会化之间的矛盾<br>D. 社会存在和社会意识的矛盾<br>正确答案：C</p>
</li>
<li><p>生产过剩是资本主义经济危机的本质特征，这种过剩是（）。<br>A. 相对于人类实际需要来说<br>B. 相对于劳动人民有支付能力的需求来说<br>C. 相对于资本主义生产条件来说<br>D. 相对于社会再生产的实物补偿来说<br>正确答案：B</p>
</li>
<li><p>资本主义经济危机爆发的根本原因是（）。<br>A. 货币作为流通手段和支付手段<br>B. 私人劳动与社会劳动之间的矛盾<br>C. 绝对过剩人口的存在<br>D. 无产阶级对资产阶级的对抗<br>正确答案：B</p>
</li>
<li><p>资产阶级意识形态的核心是（）。<br>A. 文学. 艺术和宗教<br>B. 政治思想和法律思想<br>C. 道德. 伦理<br>D. 哲学. 历史<br>正确答案：B</p>
</li>
<li><p>资本主义国家服务于资本主义经济基础，其对资本主义生产关系的调整（）。<br>A. 加剧了资本主义的基本矛盾<br>B. 表明了资本主义的生命力<br>C. 有利于资本主义社会生产力的发展<br>D. 缓和了社会主义和资本主义的矛盾<br>正确答案：C</p>
</li>
<li><p>资本主义国家的选举的实质是（）。<br>A. 资产阶级和无产阶级分权<br>B. 每个公民都能通过竞选参与政治活动，表达自己的愿望和要求<br>C. 协调统治阶级内部利益关系和矛盾的重要措施<br>D. 人民当家作主<br>正确答案：C</p>
</li>
<li><p>资本主义法律体系的支柱是（）原则。<br>A. 私有制<br>B. 公有制<br>C. 分权制衡<br>D. 中央集权<br>正确答案：A</p>
</li>
<li><p>资本主义意识形态是资产阶级的（）的集中体现。<br>A. 阶级意识<br>B. 社会心态<br>C. 个人意识<br>D. 自然科学<br>正确答案：A</p>
</li>
<li><p>最鲜明体现资本主义国家实质的国家职能是（）。<br>A. 对外交往职能<br>B. 经济职能<br>C. 社会职能<br>D. 政治统治职能<br>正确答案：D</p>
</li>
<li><p>资本主义国家的政权组织形式是（）。<br>A. 政治协商<br>B. 权力分散<br>C. 民主集中<br>D. 分权制衡<br>正确答案：D</p>
</li>
<li><p>资本主义国家的职能以（）为根本内容。<br>A. 服务工人阶级<br>B. 实现人的自由而全面的发展<br>C. 实现绝对理念<br>D. 服务于资本主义制度和资产阶级利益<br>正确答案：D</p>
</li>
<li><p>恩格斯指出：“现代国家，不管它的形式如何，本质上都是资本主义的机器，资本主义的国家，理想的总资本家”，这句话意在表明（）。<br>A. 只有资本主义国家能实现现代化<br>B. 只有现代国家是阶级统治的工具<br>C. 资本主义国家服务于资产阶级统治<br>D. 资本主义国家是人类发展最高形式<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯在《共产党宣言》中指出：“你们的法不过是被奉为法律的你们这个阶级的意志”，这说明资本主义的法律（）。<br>A. 实现了人人平等的理想<br>B. 反映全人类的普遍诉求<br>C. 服务和维护资产阶级特权<br>D. 只有资产阶级遵守<br>正确答案：C</p>
</li>
<li><p>“（美国）政治里面有两件东西最重要，一个是金钱；另一个，我想不起来。”1895年，俄亥俄州议员马克·汉纳如此解释美国政治的运转方式，这说明（）。<br>A. 资本主义政治同经济生产直接同一<br>B. 资本主义民主是金钱操纵下的民主<br>C. 资本主义政治重视实际的人人平等<br>D. 资本主义政治是绝对的民主<br>正确答案：B</p>
</li>
<li><p>列宁指出：“牧师的使命是安慰被压迫者，给他描绘一幅保存阶级统治的条件下减少苦难和牺牲的前景。”这说明（）。<br>A. 意识形态是服务被统治阶级的<br>B. 意识形态通过论证社会制度合理性维护阶级统治<br>C. 意识形态不具有阶级性<br>D. 意识形态决定社会性质<br>正确答案：B</p>
</li>
<li><p>资本主义政党制度的实质是（）。<br>A. 资产阶级选择自己的国家管理者，实现其内部利益平衡的政治机制<br>B. 允许马克思主义政党独立执政<br>C. 不受资本主义国家政权的资本主义性质制约<br>D. 无产阶级专政的现实形式<br>正确答案：A</p>
</li>
</ol>
<h3 id="多选-4"><a href="#多选-4" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>商品经济得以产生的社会历史条件包括（）。<br>A. 生产资料公有制<br>B. 生产资料和劳动产品属于不同的所有者<br>C. 存在社会分工<br>D. 个体生产自给自足<br>正确答案：BC</p>
</li>
<li><p>商品具有（）两个因素。<br>A. 剩余价值<br>B. 价值<br>C. 使用价值<br>D. 附加价值<br>正确答案：BC</p>
</li>
<li><p>价值和使用价值之间具有对立性，二者不可兼得，这指的是（）。<br>A. 商品只能具有其中一个因素<br>B. 要获得商品的价值就必须放弃商品的使用价值<br>C. 要获得商品的使用价值就必须放弃商品的价值<br>D. 二者不具有统一性<br>正确答案：BC</p>
</li>
<li><p>生产商品的劳动的二重性指的是（）。<br>A. 私人劳动<br>B. 社会劳动<br>C. 抽象劳动<br>D. 具体劳动<br>正确答案：CD</p>
</li>
<li><p>影响劳动生产率的因素包括（）。<br>A. 劳动者的平均熟练程度<br>B. 科学技术的发展水平<br>C. 生产过程的社会结合<br>D. 生产资料的规模和效能<br>正确答案：ABCD</p>
</li>
<li><p>货币具有价值尺度. （）等职能。<br>A. 流通手段<br>B. 贮藏手段<br>C. 支付手段<br>D. 世界货币<br>正确答案：ABCD</p>
</li>
<li><p>价值规律是商品生产和商品交换的基本规律，其主要内容和客观要求有（）。<br>A. 商品的价值量由生产商品的社会必要劳动时间决定<br>B. 商品的价值量由生产商品的个别必要劳动时间决定<br>C. 商品交换以价值量为基础<br>D. 商品交换按照等价交换的原则进行<br>正确答案：ACD</p>
</li>
<li><p>马克思指出：“在私人劳动产品的偶然的不断变动的交换比例中，生产这些产品的社会必要劳动时间作为起调节作用的自然规律强制为自己开辟道路”，这说明（）。<br>A. 商品价值决定商品交换价值<br>B. 价值规律支配商品的生产与流通<br>C. 商品的价格与价值始终相等<br>D. 商品的价值形式始终是偶然的<br>正确答案：AB</p>
</li>
<li><p>价值规律在市场配置资源过程中的作用表现在（）。<br>A. 自发地调节生产资料和劳动力在社会各生产部门之间的分配比例<br>B. 自发地刺激社会生产力的发展<br>C. 自发地调节社会收入分配<br>D. 自发地控制商品流通<br>正确答案：ABC</p>
</li>
<li><p>价值规律在对经济活动调节时的消极后果包括（）。<br>A. 导致不同企业相互竞争<br>B. 导致社会资源浪费<br>C. 阻碍技术进步<br>D. 导致收入两极分化<br>正确答案：BCD</p>
</li>
<li><p>在商品经济条件下商品拜物教产生的必然性在于（）。<br>A. 劳动产品只有采取商品的形式才能进行交换<br>B. 劳动量只有采取价值量这一物的形式才能进行计算和比较<br>C. 生产者的劳动关系的社会性质只有采取物与物之间相交换的形式才能间接表现出来<br>D. 商品. 价值. 货币不具有社会属性只具有自然属性<br>正确答案：ABC</p>
</li>
<li><p>关于马克思劳动价值论的理论和实践意义，下列说法中正确的有（）。<br>A. 扬弃了英国古典政治经济学的观点<br>B. 揭示了私有制条件下商品经济的基本矛盾，为认识物与物关系背后的人与人的关系提供了理论依据<br>C. 揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义<br>D. 为剩余价值论的创立奠定了基础<br>正确答案：ABCD</p>
</li>
<li><p>资本主义产生的途径包括（）。<br>A. 从小商品经济分化出来<br>B. 从商人和高利贷者转化而来<br>C. 从破产农民发展而来<br>D. 从无产阶级转变而来<br>正确答案：AB</p>
</li>
<li><p>在西欧，资本原始积累开始于15世纪后30年，一直到19世纪才告结束。资本原始积累的途径包括（）。<br>A. 通过等价交换获取原材料<br>B. 通过土地依附关系占有农民剩余劳动<br>C. 用暴力手段剥夺农民的土地<br>D. 用暴力手段掠夺货币财富<br>正确答案：CD</p>
</li>
<li><p>劳动力成为商品的基本条件包括（）。<br>A. 资本家完全占有劳动者<br>B. 劳动者在法律上是自由人<br>C. 劳动者没有任何生产资料<br>D. 劳动者失去劳动能力<br>正确答案：BC</p>
</li>
<li><p>劳动力的价值由（）几个部分组成。<br>A. 维持劳动者本人生存所必需的生活资料的价值<br>B. 维持劳动者家属的生存所必需的生活资料的价值<br>C. 劳动者接受教育和训练所支出的费用<br>D. 劳动者在劳动中所创造的剩余价值<br>正确答案：ABC</p>
</li>
<li><p>关于所有制和所有权的关系，下列说法中正确的有（）。<br>A. 所有权是所有制的基础<br>B. 所有制是所有权的基础<br>C. 所有制是所有权的法律形态<br>D. 所有权是所有制的法律形态<br>正确答案：BD</p>
</li>
<li><p>在资本主义生产过程中，生产资料的价值（）。<br>A. 由劳动工人创造出来<br>B. 通过工人的具体劳动转移到产品中<br>C. 发生增殖<br>D. 不发生增殖<br>正确答案：BD</p>
</li>
<li><p>资本积累的源泉是剩余价值，资本积累规模的大小取决于（）。<br>A. 资本家对工人的剥削程度<br>B. 劳动生产率的高低<br>C. 所用资本和所费资本之间的差额<br>D. 资本家预付资本的大小<br>正确答案：ABCD</p>
</li>
<li><p>资本积累所造成的结果包括（）。<br>A. 社会财富集中在少数人手中<br>B. 社会财富占有两极分化<br>C. 产生社会失业现象<br>D. 价值规律失效<br>正确答案：ABC</p>
</li>
<li><p>某年，铁矿石社会生产效率提高. 价格下降，某钢铁企业趁此机会投入更多资金大量采购铁矿石，并提高了劳动生产率，在没有增加人力成本的情况下，完成了钢铁生产。这家钢铁企业的资本构成中发生变化的有（）。<br>A. 价值构成<br>B. 技术构成<br>C. 有机构成<br>D. 形式构成<br>正确答案：ABC</p>
</li>
<li><p>某创业公司筹集了300万资金，购入了原材料和机器设备。此处资本所执行的职能和在资本循环中所处的阶段分别是（）。<br>A. 商品资本职能<br>B. 生产阶段<br>C. 货币资本职能<br>D. 购买阶段<br>正确答案：CD</p>
</li>
<li><p>在产业资本运动中，在空间上并存，在时间上继起的三种职能形式是（）。<br>A. 货币资本<br>B. 生产资本<br>C. 商品资本<br>D. 借贷资本<br>正确答案：ABC</p>
</li>
<li><p>以下各项中，在社会生产中属于生产生产资料的部门有（）。<br>A. 开采铁矿石的矿场<br>B. 种植棉花的农场<br>C. 餐饮公司<br>D. 服装厂<br>正确答案：AB</p>
</li>
<li><p>社会再生产的顺利进行，要求实现“两个补偿”，即（）。<br>A. 生产资料和消费资料得到实物补偿<br>B. 资本耗费得到价值补偿<br>C. 资本家投入的精力的精神补偿<br>D. 工人提高劳动技能的知识补偿<br>正确答案：AB</p>
</li>
<li><p>马克思剩余价值理论的意义在于（）。<br>A. 揭露了资本主义生产关系的剥削本质<br>B. 阐明了资产阶级与无产阶级之间阶级斗争的经济根源<br>C. 指出了无产阶级革命的历史必然性<br>D. 成为无产阶级反对资产阶级的重要理论武器<br>正确答案：ABCD</p>
</li>
<li><p>社会资本再生产的周期包括（）几个阶段。<br>A. 危机<br>B. 萧条<br>C. 复苏<br>D. 高涨<br>正确答案：ABCD</p>
</li>
<li><p>资产阶级政党在国家政治生活中发挥着很大作用，包括（）。<br>A. 代表资产阶级执掌政权，对政府施加影响. 控制议会。<br>B. 制定和推行符合资产阶级利益的方针. 政策。<br>C. 操纵选举<br>D. 控制群众团体和舆论宣传<br>正确答案：ABCD</p>
</li>
<li><p>列宁说：“民主共和制是资本主义所能采用的最好的政治外壳。”这句话应理解为，民主共和制（）。<br>A. 便于掩盖资产阶级专政的实质。<br>B. 有利于维护资产阶级的统治。<br>C. 与资本主义经济制度相适应。<br>D. 有利于调节资产阶级内部各个集团之间的矛盾。<br>正确答案：ABCD</p>
</li>
<li><p>资本主义政治制度的历史和阶级的局限性主要表现在（）。<br>A. 资本主义的民主是金钱操纵下的民主，实际上是资产阶级精英统治下的民主。<br>B. 法律名义上的平等掩盖着事实上的不平等。<br>C. 资本主义国家的政党制是一种维护阶级统治的政治制度。<br>D. 资本主义国家多党制本质上仍然是资产阶级选择自己的国家管理者，实现内部利益平衡的政治机制。<br>正确答案：ABCD</p>
</li>
<li><p>在饱受疫情困扰的情况下，2020年美国大选的花费将近140亿美元，达到历史新高，这在某种程度上说明（）。<br>A. 资本主义选举事实上是有钱人的游戏<br>B. 资本主义选举投入更多也更科学<br>C. 资本主义政党为讨好选民忽视国家整体利益和长远利益<br>D. 资本主义选举本质上是资本玩弄民意的过程<br>正确答案：ACD</p>
</li>
<li><p>之所以说资本主义意识形态是资产阶级意识的集中体现，是因为（）。<br>A. 意识形态来自统治阶级的实践<br>B. 意识形态可以称为统治阶级进一步进行阶级统治的指导思想<br>C. 资产阶级意识形态服务于全人类的解放<br>D. 资产阶级意识形态主张实际的人人平等<br>正确答案：AB</p>
</li>
</ol>
<h3 id="判断-4"><a href="#判断-4" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>商品经济在任何社会形态中都占据主导地位。<br>错</p>
</li>
<li><p>一切商品都必须具有使用价值，离开了使用价值商品就不复存在。<br>对</p>
</li>
<li><p>商品的使用价值是用来满足商品生产者的需要的。<br>错</p>
</li>
<li><p>使用价值的大小，或者说对人的需要的满足程度决定了商品交换的比例。<br>错</p>
</li>
<li><p>价值是一切劳动产品所共有的社会属性。<br>错</p>
</li>
<li><p>商品之所以能按一定比例进行交换，是因为它们满足人的需求程度成一定比例。<br>错</p>
</li>
<li><p>劳动形成商品的价值，这意味着只要是劳动的产物就具有价值。<br>错</p>
</li>
<li><p>劳动的二重性决定商品的二因素，其中抽象劳动形成商品的价值。<br>对</p>
</li>
<li><p>商品的价值量与生产商品所耗费的劳动生产率成反比。<br>对</p>
</li>
<li><p>在货币产生后，一切商品只要转化为货币，商品使用价值和价值的矛盾就能解决。<br>对</p>
</li>
<li><p>在商品经济中，价值规律的表现形式是，商品的价格围绕商品的价值自发波动。<br>对</p>
</li>
<li><p>商品生产者的劳动的社会性质是由社会分工决定的。<br>对</p>
</li>
<li><p>具体劳动能否还原为抽象劳动，在根本上取决于私人劳动和社会劳动能否实现统一。<br>对</p>
</li>
<li><p>马克思所说的“商品拜物教”指的是商品. 价值. 货币的运动采取了人与人之间社会关系的虚幻形式。<br>错</p>
</li>
<li><p>理解政治经济的枢纽是劳动二重性理论。<br>对</p>
</li>
<li><p>资产阶级政治统治的建立和资本主义生产方式支配地位的形成，标志着资本主义制度的最终确立。<br>对</p>
</li>
<li><p>货币就是资本，资本就是货币。<br>错</p>
</li>
<li><p>没有人的劳动，任何社会生产都不能进行。<br>对</p>
</li>
<li><p>资本不是一种物，而是一种以物为中介的人和人之间的社会关系。<br>对</p>
</li>
<li><p>一旦货币购买的劳动力带来剩余价值，货币也就变成了资本。<br>对</p>
</li>
<li><p>经济意义上的所有制是指事实上生产资料归谁所有. 归谁支配，并凭借这种所有和支配实现生产和获得剩余产品。<br>对</p>
</li>
<li><p>资本主义对工人的剥削，建立在工人对资本家人身依附关系形成的基础上。<br>错</p>
</li>
<li><p>雇佣劳动者的剩余劳动是剩余价值的唯一源泉。<br>对</p>
</li>
<li><p>资本积累就是剩余价值的资本化。<br>对</p>
</li>
<li><p>资本家获得无偿占有的剩余价值后，并不是将其完全用于个人消费，而是将一部分转化为资本，用以购买追加的生产资料和劳动力，这就是资本主义简单再生产。<br>错</p>
</li>
<li><p>资本积累的本质就是资本家不断利用无偿占有的工人创造的剩余价值来扩大自己的资本规模。<br>对</p>
</li>
<li><p>在资本主义生产过程中，资本有机构成提高是一般趋势。<br>对</p>
</li>
<li><p>资本积累会导致相对过剩人口的出现，所谓相对过剩人口是指为社会生产所不需要的人口。<br>错</p>
</li>
<li><p>资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利。<br>对</p>
</li>
<li><p>平均利润的形成体现了资本家们在榨取更大剩余价值这一点上有着共同的阶级利益。<br>对</p>
</li>
<li><p>生产价格形成后，市场价格不再以价值为中心，这说明价值规律在资本主义条件下不再有效。<br>错</p>
</li>
<li><p>经济危机通过强制实现社会再生产平衡的方式，根除了资本主义基本矛盾。<br>错</p>
</li>
<li><p>经济危机实际上是资本主义条件下以强制的方式解决社会再生产的实现问题的途径。<br>对</p>
</li>
<li><p>资本主义的民主是金钱操纵下的民主，实际上是资产阶级精英统治下的民主。<br>对</p>
</li>
<li><p>资本主义政治制度是在资本主义经济基础之上建立的，它反映了资本主义社会的经济关系，反映了政治上占统治地位的资产阶级的要求。<br>对</p>
</li>
<li><p>资本主义国家是剥削阶级对人民群众进行阶级统治和阶级压迫的工具。<br>对</p>
</li>
<li><p>资本主义国家的宪法是在私有制原则. “主权在民”原则. 分权与制衡原则以及人权原则的基础上建立起来的。<br>对</p>
</li>
<li><p>资本主义国家的对外职能是对内职能的延伸。<br>对</p>
</li>
<li><p>资产阶级所说的“法律面前人人平等”只是名义上的平等。<br>对</p>
</li>
<li><p>资产阶级政党制度允许工人阶级政党存在和参与国家生活，说明资产阶级政党制度不服务于特定阶级。<br>错</p>
</li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="单选-5"><a href="#单选-5" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>（）是指生产资料. 劳动力和商品的生产日益集中于少数大企业的过程。<br>A. 生产集中<br>B. 资本积累<br>C. 资本循环<br>D. 资本周转<br>正确答案：A</p>
</li>
<li><p>（）是指大资本吞并小资本，或由许多小资本合并而成大资本的过程。<br>A. 生产集中<br>B. 资本集中<br>C. 扩大再生产<br>D. 资本循环<br>正确答案：B</p>
</li>
<li><p>尽管垄断组织的形式多种多样，但其本质上是一样的，即操纵垄断价格，以攫取高额（）。<br>A. 平均利润<br>B. 垄断利润<br>C. 使用价值<br>D. 交换价值<br>正确答案：B</p>
</li>
<li><p>垄断条件下，垄断企业商品按照（）出售。<br>A. 生产价格<br>B. 价值<br>C. 垄断价格<br>D. 使用价值<br>正确答案：C</p>
</li>
<li><p>相比于自由竞争，垄断下的竞争以（）为主要目的。<br>A. 榨取剩余价值<br>B. 获得平均利润<br>C. 获得垄断利润<br>D. 实现价值补偿<br>正确答案：C</p>
</li>
<li><p>（）是指操纵国民经济命脉，并实际控制国家政权的少数垄断资本家或垄断资本家集团。<br>A. 金融资本<br>B. 金融寡头<br>C. 统治阶级<br>D. 私人资本家<br>正确答案：B</p>
</li>
<li><p>金融寡头在经济领域的统治主要是通过（）实现的。<br>A. 参与制<br>B. 绝对剩余价值<br>C. 相对剩余价值<br>D. 商品交换<br>正确答案：A</p>
</li>
<li><p>垄断利润是垄断资本家凭借其在社会生产和流通中的垄断地位而获得的（）的高额利润。<br>A. 低于平均利润<br>B. 等于平均利润<br>C. 超过平均利润<br>D. 等于生产价格<br>正确答案：C</p>
</li>
<li><p>垄断资本所获得的高额利润，归根到底来自于（）。<br>A. 垄断资本家的预付资本<br>B. 垄断资本家所制定的垄断价格<br>C. 劳动工人所创造的剩余价值<br>D. 转移到产品中生产资料价值<br>正确答案：C</p>
</li>
<li><p>国家垄断资本主义的实质是（）。<br>A. 国家利用垄断组织造福民生<br>B. 私人垄断资本主义利用国家机器为其发展服务<br>C. 超越资本主义的新的社会形态<br>D. 消除基本矛盾后的资本主义运行机制<br>正确答案：B</p>
</li>
<li><p>某赛车在日本筹集资金，在意大利设计，在美国生产电子元件，在德国生产零配件，在法国完成组装。这体现了（）。<br>A. 金融全球化<br>B. 生产全球化<br>C. 福利制度全球化<br>D. 意识形态全球化<br>正确答案：B</p>
</li>
<li><p>导致经济及全球化迅猛发展的因素有多种，其中提供物质基础和根本推动力的是（）。<br>A. 跨国公司的发展<br>B. 资本主义意识形态<br>C. 科学技术的发展和生产力的发展<br>D. 国际组织的发展<br>正确答案：C</p>
</li>
<li><p>习近平指出：“面对经济全球化大势，像鸵鸟一样把头埋在沙里假装视而不见，或像堂吉诃德一样挥舞长矛加以抵制，都违背了历史规律。”这说明（）。<br>A. 经济全球化对发展中国家只有负面影响<br>B. 人不能认识和把握经济全球化发展规律<br>C. 经济全球化发展是不可阻挡的历史必然性<br>D. 各国只能被动的受经济全球化影响<br>正确答案：C</p>
</li>
<li><p>第二次世界大战之后，国家资本所有制形成并发挥重要作用，国家资本所有制就其性质而言（）。<br>A. 是一种生产资料公有制<br>B. 体现国家超越阶级实现平等的职能<br>C. 体现着总资本家剥削雇佣劳动者的关系<br>D. 是一种社会主义形式<br>正确答案：C</p>
</li>
<li><p>当代资本主义产生变化的根本推动力是（）。<br>A. 资本家的慈善活动<br>B. 生产力的发展和科学技术革命<br>C. 改良主义政党<br>D. 工人阶级的反抗<br>正确答案：B</p>
</li>
<li><p>从当代资本主义发展的实际情况来看，（）依然是资本主义的基本经济制度。<br>A. 生产资料公有制<br>B. 生产资料集体所有制<br>C. 生产资料私有制<br>D. 生产资料共有制<br>正确答案：C</p>
</li>
<li><p>由美国次贷危机引发的2008年国际金融危机对西方国家的经济生活. 政治生活和社会民生等方面都造成了消极影响，其背后深层次的根源是（）。<br>A. 资本主义的基本矛盾<br>B. 资本主义意识形态<br>C. 资本主义政治制度<br>D. 资本主义改良政党<br>正确答案：A</p>
</li>
<li><p>正确认识资本主义的历史过渡性要（）。<br>A. 否定资本主义生产关系的一切改良<br>B. 借鉴资本主义社会中反映人类文明进步的改良<br>C. 对资本主义采取全面肯定的态度<br>D. 发展资本主义的经济制度<br>正确答案：B</p>
</li>
<li><p>资本主义的发展在各个国家是极不平衡的，而且在商品生产下也只能是这样。由此得出一个必然的结论是（）。<br>A. 社会主义很难实现<br>B. 社会主义不能在所有国家内同时获得胜利<br>C. 社会主义必须在所有国家内同时获得胜利<br>D. 经济和政治发展的不平衡是资本主义的基本矛盾<br>正确答案：B</p>
</li>
<li><p>社会化大生产的程度提高，客观上要求（），以保持再生产顺利进行，同生产资料的私人占有形成了矛盾。<br>A. 攫取更高的剩余价值<br>B. 各生产部门间形成平均利润<br>C. 生产资料和劳动产品由全社会共有和支配<br>D. 形成垄断组织<br>正确答案：C</p>
</li>
<li><p>马克思曾这样描述资本家和工人：“一个笑容满面，雄心勃勃；一个战战兢兢，畏缩不前，像在市场上出卖了自己的皮一样，只有一个前途——让人家来鞣”。这段话意在说明（）。<br>A. 资本家与工人在天赋能力上的差异<br>B. 资本家超越常人的毅力和精神是其成功的根本<br>C. 资本主义社会呈两极分化趋势<br>D. 工人缺少伟大志向和理想<br>正确答案：C</p>
</li>
<li><p>马克思指出：“生产资料的集中和劳动的社会化，达到了同它的资本主义外壳不能相容的地步。这个外壳就要炸毁了。”这说明（）。<br>A. 资本主义必须发展为垄断形式才能化解资本主义基本矛盾<br>B. 资本主义的基本矛盾最终将否定资本主义自身<br>C. 资本主义作为外壳只具有上层建筑意义<br>D. 资本主义生产方式不会推动生产社会化<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选-5"><a href="#多选-5" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>私人垄断资本主义是在（）基础上发展起来的。<br>A. 生产集中<br>B. 资本集中<br>C. 分散生产<br>D. 投资分散<br>正确答案：AB</p>
</li>
<li><p>垄断产生的原因包括（）。<br>A. 当生产集中发展到相当高的程度，极少数企业就会联合起来<br>B. 企业规模巨大，形成对竞争的限制<br>C. 激烈的竞争给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协<br>D. 当生产率提高，相对过剩人口扩大<br>正确答案：ABC</p>
</li>
<li><p>关于垄断下的竞争的特点，下列说法中正确的有（）。<br>A. 以获取平均利润为目的<br>B. 采取非经济手段进行竞争<br>C. 竞争范围扩大到经济以外<br>D. 停止商品交换<br>正确答案：ABC</p>
</li>
<li><p>金融寡头实现对经济命脉和国家机器控制的手段包括（）。<br>A. 通过“参与制”控制经济领域<br>B. 通过“个人联合”控制国家机器<br>C. 通过建立政策咨询机构等方式影响政府政策<br>D. 掌握新闻出版. 广播电视等各个领域<br>正确答案：ABCD</p>
</li>
<li><p>垄断利润的来源有（）等几个方面。<br>A. 对本国无产阶级和其他劳动人民剥削的加强获得更多利润<br>B. 由于垄断资本可以通过垄断高价和垄断低价来控制市场，使得它能获得一些其他企业特别是非垄断企业的利润<br>C. 通过加强对其他国家劳动人民的剥削和掠夺从国外获取利润<br>D. 通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民创造的国民收入的一部分变成垄断资本的收入<br>正确答案：ABCD</p>
</li>
<li><p>国家垄断资本主义形成的原因包括（）。<br>A. 社会生产力发展，要求资本主义生产资料在更大范围内被支配<br>B. 经济波动和经济危机深化<br>C. 缓和社会矛盾<br>D. 协调利益关系<br>正确答案：ABCD</p>
</li>
<li><p>国家垄断资本主义的主要形式包括国家所有并直接经营企业. （）。<br>A. 国家与私人共有. 合营企业<br>B. 国家通过多种形式此案与私人垄断资本的再生产过程<br>C. 宏观调节<br>D. 微观规制<br>正确答案：ABCD</p>
</li>
<li><p>国家垄断资本主义微观规制的类型主要有（）。<br>A. 反托拉斯法<br>B. 公共事业规制<br>C. 社会经济规制<br>D. 意识形态规制<br>正确答案：ABC</p>
</li>
<li><p>（）是金融垄断资本得以形成和壮大的重要制度条件。<br>A. 金融管控<br>B. 反托拉斯法<br>C. 金融自由化<br>D. 金融创新<br>正确答案：CD</p>
</li>
<li><p>金融垄断资本的发展带来的结果包括（）。<br>A. 促进资本主义经济的发展<br>B. 实现事实上的人人平等<br>C. 造成了经济过度虚拟化<br>D. 消除了资本主义基本矛盾<br>正确答案：AC</p>
</li>
<li><p>垄断资本向世界范围内的扩展，反映了资本主义发展的必然逻辑，也反映了资本主义发展的本质。垄断资本向世界范围扩展的动因有（）。<br>A. 将国内过剩的资本输出<br>B. 将部分非要害的技术转移到国外<br>C. 争夺商品销售市场<br>D. 确保原材料和能源的可靠来源<br>正确答案：ABCD</p>
</li>
<li><p>垄断资本向世界范围扩展的基本形式包括（）。<br>A. 借贷资本输出<br>B. 核心技术输出<br>C. 生产资本输出<br>D. 商品资本输出<br>正确答案：ACD</p>
</li>
<li><p>垄断资本向世界范围扩展过程中，对资本输入国带来的影响包括（）。<br>A. 产业结构调整受制于外资投资战略<br>B. 促进了对外贸易的发展<br>C. 付出环境污染. 能源耗费的代价<br>D. 冲击本国民族产业<br>正确答案：ABCD</p>
</li>
<li><p>第二次世界大战以来，从事国际经济协调. 维护国际经济秩序的国际经济组织主要有（）。<br>A. 国际货币基金组织<br>B. 世界银行<br>C. 世界贸易组织<br>D. 七国集团<br>正确答案：ABC</p>
</li>
<li><p>关于国际协调组织的作用，下列说法中正确的有（）。<br>A. 加快了资本. 技术等生产要素在国际的流动<br>B. 有效缓解全球范围内的经济波动和经济危机<br>C. 加强各国之间的经济联系<br>D. 促进经济全球化发展<br>正确答案：ACD</p>
</li>
<li><p>列宁所归纳的帝国主义的基本特征包括垄断组织在经济生活中起决定作用. （）。<br>A. 在金融资本的基础上形成金融寡头的统治<br>B. 资本输出有了特别重要的意义<br>C. 瓜分世界的资本家国际垄断联盟已经形成<br>D. 最大资本主义大国已把世界上的领土瓜分完毕<br>正确答案：ABCD</p>
</li>
<li><p>经济全球化是指在（）的情况下，世界各国. 各地区的经济活动越来越超出某一国家和地区的范围而相互联系. 相互依赖的过程。<br>A. 生产不断发展<br>B. 科技加速进步<br>C. 社会分工和国际分工不断深化<br>D. 生产的社会化和国际化程度不断提高<br>正确答案：ABCD</p>
</li>
<li><p>经济全球化的表现包括（）。<br>A. 生产全球化<br>B. 福利全球化<br>C. 贸易全球化<br>D. 金融全球化<br>正确答案：ACD</p>
</li>
<li><p>导致经济全球化迅猛发展的因素主要有（）。<br>A. 科学技术的进步和生产力的发展<br>B. 跨国公司的发展<br>C. 各国经济体制的变革<br>D. 国际经济组织的发展<br>正确答案：ABCD</p>
</li>
<li><p>经济全球化对发展中国家的积极作用表现为（）。<br>A. 为发展中国家提供先进技术和管理经验<br>B. 为发展中国家提供更多的就业机会<br>C. 推动发展中国家贸易共享<br>D. 使发展中国家成为世界贸易最大受益者<br>正确答案：ABC</p>
</li>
<li><p>经济全球化是一把“双刃剑”，它在促进经济发展的同时也带来了一些负面影响，包括（）。<br>A. 发达国家与发展中国家在地位. 收益上的不平衡<br>B. 加剧发展中国家资源短缺和环境污染<br>C. 增加了经济风险<br>D. 增加全球经济的不稳定性<br>正确答案：ABCD</p>
</li>
<li><p>关于法人资本所有制，下列说法中正确的有（）。<br>A. 在第二次世界大战后崛起并居主导地位<br>B. 使公司资本的所有权与控制权重新趋于合一<br>C. 有企业法人资本所有制和机构法人资本所有制两种形式<br>D. 是一种基于资本雇佣劳动的垄断资本集体所有制<br>正确答案：ABCD</p>
</li>
<li><p>随着社会生产力的发展和工人阶级反抗力量的不断扩大，资本家开始采取一些缓和劳资关系的激励制度，具体包括（）。<br>A. 职工参与决策<br>B. 终身雇佣<br>C. 职工持股<br>D. 职工选举任命公司管理者<br>正确答案：ABC</p>
</li>
<li><p>在当代资本主义生产关系中，社会阶层. 阶级结构发生了新变化，包括（）。<br>A. 资产阶级与工人阶级之间不再具有剥削关系<br>B. 资本家一般不再直接经营和管理企业<br>C. 高级职业经理成为大公司经营活动的实际控制者<br>D. 知识型和服务型劳动者的数量不断增加<br>正确答案：BCD</p>
</li>
<li><p>20世纪70年代以来，资本主义经济危机所呈现出的新特点包括（）。<br>A. 去工业化和产业空心化日趋严重<br>B. 虚拟经济与实体经济严重脱节<br>C. 两极分化和社会对了加剧<br>D. 周期性危机与结构性危机交织在一起<br>正确答案：ABCD</p>
</li>
<li><p>第二次世界大战后资本主义变化的原因包括（）。<br>A. 科学技术革命和生产力的发展<br>B. 工人阶级争取自身权利和利益的斗争<br>C. 社会主义制度初步显现的优越性对资本主义产生了影响<br>D. 主张改良主义的政党起到了重要作用<br>正确答案：ABCD</p>
</li>
<li><p>第二次世界大战后资本主义发生的变化从根本上说是（）作用的结果。<br>A. 人类社会发展一般规律<br>B. 资本主义经济规律<br>C. 资产阶级的改良调整<br>D. 无产阶级的妥协让步<br>正确答案：AB</p>
</li>
<li><p>2008年国际金融危机所造成的影响包括（）。<br>A. 经济发展失调<br>B. 政治体制失灵<br>C. 社会流动性退化<br>D. 社会极端思想抬头<br>正确答案：ABCD</p>
</li>
<li><p>2008年爆发的国际金融危机暴露出了西方国家民主的弊端和局限，主要有（）。<br>A. 西式选举往往难以选贤<br>B. 政党利益可能凌驾于国家利益之上<br>C. “民主陷阱”会阻碍国家治理<br>D. 传统精英政治走向衰落<br>正确答案：ABCD</p>
</li>
<li><p>社会主义取代资本主义将是一个长期的历史过程，这是由于（）。<br>A. 资本主义基本矛盾的运动具有复杂性和曲折性<br>B. 资本主义生产关系的调整，在一定程度上还能容纳生产力继续发展<br>C. 资本主义已经积累了雄厚的经济实力和丰富的统治经验<br>D. 资本主义经济和政治发展不平衡规律的作用<br>正确答案：ABCD</p>
</li>
<li><p>同封建社会相比，资本主义显现的巨大历史进步性包括（）。<br>A. 将科学技术转变为强大的生产力<br>B. 资本追逐剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展<br>C. 资本主义意识形态推动了社会生产力发展<br>D. 实现了人的自由而全面发展<br>正确答案：ABC</p>
</li>
<li><p>当今世界，坚持和发展社会主义要（）。<br>A. 认清社会主义必然取代资本主义的历史趋势<br>B. 认识资本主义的自我调节能力<br>C. 充分估计西方西方发达国家在经济科技等方面长期占据优势的客观事实<br>D. 做好两种社会制度长期合作和斗争的各方面准备<br>正确答案：ABCD</p>
</li>
<li><p>“资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大”。这说明（）。<br>A. 当生产关系适合生产力状况时，生产力会得到迅速发展<br>B. 在资本主义社会，资产阶级是历史的创造者<br>C. 资本主义生产关系代替封建制度是历史的进步<br>D. 资本主义生产关系的建立在一定程度上解放了社会生产力<br>正确答案：ACD</p>
</li>
</ol>
<h3 id="判断-5"><a href="#判断-5" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>垄断是指少数资本主义大企业为获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产. 销售和价格进行操纵和控制。<br>对</p>
</li>
<li><p>垄断一旦形成，竞争就会消失。<br>错</p>
</li>
<li><p>垄断必须通过竞争来维持。<br>对</p>
</li>
<li><p>相比于垄断下的竞争，自由竞争的破坏性更大。<br>错</p>
</li>
<li><p>垄断价格是垄断组织凭借其垄断地位规定的，一定时期内背离了价值和生产价格。<br>对</p>
</li>
<li><p>垄断价格实现了垄断利润，也增加了社会的价值总量。<br>错</p>
</li>
<li><p>垄断价格的产生否定了价值规律。<br>错</p>
</li>
<li><p>国家垄断资本主义的出现从根本上改变了垄断资本主义的性质。<br>错</p>
</li>
<li><p>帝国主义的实质即垄断资本凭借垄断地位，获取高额垄断利润。<br>对</p>
</li>
<li><p>经济全球化是生产力发展和社会化大生产的必然要求。<br>对</p>
</li>
<li><p>第二次世界大战后，实体经济停滞，正是金融垄断资本主义的兴起破解了生产停滞的难题。<br>错</p>
</li>
<li><p>金融垄断资本主义的发展导致金融危机频繁发生，给全球经济带来灾难。<br>对</p>
</li>
<li><p>当代资本主义政治制度出现多元化的趋势，公民权利有所扩大。<br>对</p>
</li>
<li><p>第二次世界大战后，资本主义发生的变化导致剩余价值规律已不再起作用。<br>错</p>
</li>
<li><p>当代资本主义追逐剩余价值的本性没有改变，改变的只是获取剩余价值的方式和方法。<br>对</p>
</li>
<li><p>二战后，西方资本主义国家大多提高社会福利制度，从根本上改变了社会财富占有两极分化的现象。<br>错</p>
</li>
<li><p>真理是在一定条件下的真理，资本主义的新变化表明马克思主义政治经济学所适用的条件已经改变，马克思主义关于资本主义的基本论断已经过时。<br>错</p>
</li>
<li><p>社会主义必然代替资本主义的主要依据是生产的社会化与资本主义私人占有制之间的矛盾。<br>对</p>
</li>
<li><p>社会主义制度代替资本主义制度是生产关系一定要适应生产力发展规律的要求。<br>对</p>
</li>
<li><p>资产阶级的灭亡和无产阶级的胜利是同样不可避免的。<br>对</p>
</li>
<li><p>资本家通过用剩余价值做慈善事业而化解了资本主义的历史局限性。<br>错</p>
</li>
<li><p>资本主义最终消亡. 社会主义最终胜利，必然是一个很长的历史过程。<br>对</p>
</li>
<li><p>资本主义的局限性不可能根本消除，这决定了资本主义生产方式的历史过渡性。<br>对</p>
</li>
<li><p>只有用社会主义的生产方式取代资本主义生产方式，生产社会化和生产资料私人占有制之间的矛盾才能根本解决。<br>对</p>
</li>
<li><p>社会主义必然胜利是不可逆转的总趋势，但社会主义的最终胜利必然是一个很长的历史过程。<br>对</p>
</li>
<li><p>资本国有化将为社会主义革命提供直接的物质前提，是无产阶级社会主义革命的入口处。<br>对</p>
</li>
<li><p>反托拉斯法. 公共事业规制. 财政政策都属于国家垄断资本主义的宏观调控形式。<br>错</p>
</li>
<li><p>垄断价格包括垄断高价和垄断低价两种形式。<br>对</p>
</li>
<li><p>自由竞争资本主义逐步向垄断资本主义过渡是因为资本主义基本矛盾的逐渐消除。<br>错</p>
</li>
<li><p>垄断条件下，因为消除了竞争，所以损害了经济发展。<br>错</p>
</li>
<li><p>垄断价格不受价值规律影响，因此在经济上造成恶劣影响。<br>错</p>
</li>
<li><p>美国主导建立的布雷顿森林体系对促进世界经经济的恢复和发展发挥了重要作用，对推动世界多极化，去霸权化起到积极意义。<br>错</p>
</li>
<li><p>在垄断资本向世界扩张的过程中，资本输出国主要是发展中国家。<br>错</p>
</li>
<li><p>随着资本输出的不断增加，各国之间的经济联系日益密切，矛盾逐渐消除。<br>错</p>
</li>
<li><p>由于各国经济发展总是不平衡的，国际垄断同盟从经济上瓜分世界的趋势，还会在一定时间内持续。<br>对</p>
</li>
<li><p>2008年爆发的金融危机说明，建立国际经济新秩序. 改革现有国际经济协调机制. 加强全球治理已势在必行。<br>对</p>
</li>
<li><p>金融自由化浪潮的兴起和信息技术在金融领域的广泛应用，推动了金融全球化进程。<br>对</p>
</li>
<li><p>经济全球化是资本主义强国为扩张而创造出来的。<br>错</p>
</li>
<li><p>从历史的角度看，资本主义生产资料所有制是不断演进和变化的。<br>对</p>
</li>
<li><p>国家资本所有制就其性质而言，是生产资料公有制。<br>错</p>
</li>
<li><p>金融垄断资本主义是二战后资本主义垄断资本形式的新变化。<br>对</p>
</li>
<li><p>在资本主义条件下，在表面平等的交换关系背后，是资本对劳动的实际支配和控制。<br>对</p>
</li>
<li><p>“泰罗制”和“福特制”是适应资本主义工厂流水线作业的两种工资制度，他们的出现弱化工人阶级被控制和剥削的程度。<br>错</p>
</li>
<li><p>资本主义采取职工参与决策的方法激励工人，改变了工人被剥削的地位。<br>错</p>
</li>
<li><p>当代资本主义社会的社会阶层和阶级结构发生了变化，资本家不再直接管理公司，劳动工人成为公司经营活动的实际控制者。<br>错</p>
</li>
<li><p>第二次世界大战以后，资本主义国家经历了先加强政府干预经济，后弱化政府干预经济的过程。<br>对</p>
</li>
<li><p>正确认识资本主义的新变化，有助于我们进一步完善和发展社会主义制度。<br>对</p>
</li>
<li><p>当代资本主义存在诸多乱象，这些乱象的原因归根结底还在于资本主义制度本身。<br>对</p>
</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="单选-6"><a href="#单选-6" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>1516年英国人托马斯·莫尔所著（）是空想社会主义的开山之作。<br>A. 《乌托邦》<br>B. 《道德情操论》<br>C. 《反杜林论》<br>D. 《哥达纲领批判》<br>正确答案：A</p>
</li>
<li><p>1864年，国际工人协会即（）成立，促进了马克思主义的传播，初步确立了马克思主义在工人运动中的指导地位。<br>A. 第一国际<br>B. 第二国际<br>C. 第三国际<br>D. 共产主义者同盟<br>正确答案：A</p>
</li>
<li><p>1871年爆发的（），是无产阶级夺取政权的第一次伟大尝试。<br>A. 里昂工人起义<br>B. 京汉铁路大罢工<br>C. 十月革命<br>D. 巴黎公社革命<br>正确答案：D</p>
</li>
<li><p>1889年7月，在恩格斯的指导下，国际社会主义者在巴黎举行代表大会，标志着（）。<br>A. 第一国际的诞生<br>B. 第二国际的诞生<br>C. 十月革命的爆发<br>D. 正义者同盟改组完成<br>正确答案：B</p>
</li>
<li><p>列宁深刻论述了社会主义革命可以首先在一个或者几个国家获得胜利，丰富和发展了马克思主义，其作出这一论断的依据是（）。<br>A. 马克思. 恩格斯理论中的逻辑漏洞<br>B. 资本主义的发展在各个国家是不平衡的<br>C. 资本主义基本矛盾在列宁时期已经化解<br>D. 剩余价值规律作用的消失<br>正确答案：B</p>
</li>
<li><p>（）实现了社会主义从理想到现实的伟大飞跃。<br>A. 十月革命<br>B. 巴黎公社革命<br>C. 第一国际<br>D. 第二国际<br>正确答案：A</p>
</li>
<li><p>1918年夏到1921年春，苏维埃政权实施了一系列特殊又带有强制性的非常措施，后来列宁说：“为了拯救国家，拯救军队，拯救工农政权，当时必须这样做”，“这样”指代的是（）。<br>A. 反抗俄国沙皇统治的二月革命<br>B. 为建立社会主义制度而进行的十月革命<br>C. 为应对帝国主义武装干涉和国内战争而采取的战时共产主义政策<br>D. 在国民经济恢复期实行的新经济政策<br>正确答案：C</p>
</li>
<li><p>苏联解体. 苏东剧变的最根本原因是（）方向出了问题。<br>A. 经济<br>B. 政治<br>C. 科学文化<br>D. 教育<br>正确答案：B</p>
</li>
<li><p>提出社会主义革命可能在一国或数国首先取得胜利论断的是（）。<br>A. 恩格斯<br>B. 马克思<br>C. 列宁<br>D. 莫尔<br>正确答案：C</p>
</li>
<li><p>列宁说：“如果社会主义在经济上尚未成熟，任何起义也创造不出社会主义来。”这就是说（）。<br>A. 社会主义革命只能在经济发达的国家发生和取得胜利<br>B. 经济力量是实现社会主义的唯一条件<br>C. 社会主义革命需要一定的物质前提<br>D. 社会主义革命能够在资本主义内部自发产生<br>正确答案：C</p>
</li>
<li><p>世界上第一个社会主义国家是（）。<br>A. 巴黎公社<br>B. 苏维埃俄国<br>C. 中华人民共和国<br>D. 巴伐利亚苏维埃共和国<br>正确答案：B</p>
</li>
<li><p>资本主义社会为自身被新的社会制度所取代而准备的精神条件是（）。<br>A. 社会化大生产<br>B. 现代无产阶级<br>C. 马克思主义理论<br>D. 市场经济体制<br>正确答案：C</p>
</li>
<li><p>我国在社会主义建设时期，以（）和《关于正确处理人民内部矛盾的问题》为主要标志，党对怎样建设社会主义有了自己的新认识。<br>A. 《井冈山的斗争》<br>B. 《论十大关系》<br>C. 《星星之火，可以燎原》<br>D. 《矛盾论》<br>正确答案：B</p>
</li>
<li><p>1978年12月，党的十一届三中全会重新确立了（）的思想路线。<br>A. 以阶级斗争为纲<br>B. 不唯上只唯书<br>C. 解放思想. 实事求是<br>D. 全盘西化<br>正确答案：C</p>
</li>
<li><p>1978年以后，经过实践探索，我们党提出了社会主义初级阶段等理论，第一次比较系统地初步回答了（）。<br>A. 社会主义如何从空想到科学<br>B. 如何建立社会主义政权<br>C. 在中国这样经济文化比较落后的国家如何建设. 巩固社会主义<br>D. 如何建设社会主义现代化强国<br>正确答案：C</p>
</li>
<li><p>社会主义经济制度的基础是（）。<br>A. 生产资料私人占有制<br>B. 国家垄断资本所有制<br>C. 社会主义公有制<br>D. 多种所有制共同发展<br>正确答案：C</p>
</li>
<li><p>马克思主义政党的最高纲领和最终奋斗目标是（）。<br>A. 建立社会主义制度<br>B. 成为社会主义事业的领导核心<br>C. 实现共产主义<br>D. 建立无产阶级专政<br>正确答案：C</p>
</li>
<li><p>下列选项中，体现社会主义的本质属性和要求的是（）。<br>A. 追求剩余价值<br>B. 坚持等价交换原则<br>C. 以土地为基础形成农民人身依附关系<br>D. 促进人的全面发展和社会和谐<br>正确答案：D</p>
</li>
<li><p>社会主义的根本目的在于（）。<br>A. 镇压资产阶级的反抗<br>B. 建立无产阶级专政<br>C. 无限扩大资本积累<br>D. 消灭剥削. 消除两极分化，最终达到共同富裕<br>正确答案：D</p>
</li>
<li><p>（）是指无产阶级以夺取政权为目的的斗争，它是无产阶级反对整个资产阶级的斗争形式。<br>A. 经济斗争<br>B. 文化斗争<br>C. 思想斗争<br>D. 政治斗争<br>正确答案：D</p>
</li>
<li><p>无产阶级革命的根本问题是（）。<br>A. 国家政权问题<br>B. 农民问题<br>C. 武装斗争问题<br>D. 统一战线中的领导权问题<br>正确答案：A</p>
</li>
<li><p>无产阶级政党的组织原则是（）。<br>A. 民主集中制<br>B. 理论联系实际<br>C. 实事求是<br>D. 政党利益至上<br>正确答案：A</p>
</li>
<li><p>邓小平指出：“绝不能要求马克思为解决他去世之后上百年. 几百年所产生的问题提供现成答案。列宁同样也不能承担为他去世以后五十年. 一百年所产生的问题提供现成答案的任务。”这表明（）。<br>A. 紧跟时代和实践的发展，在不断总结新鲜经验中进一步丰富和发展科学社会主义基本原则<br>B. 因为各国革命和建设实际情况的不同，科学社会主义不再有基本原则<br>C. 始终坚持科学社会主义基本原则，反对任何背离科学社会主义基本原则的错误倾向<br>D. 马克思主义理论不再适应于时代的变化发展<br>正确答案：A</p>
</li>
<li><p>（）是指无产阶级为改善劳动和生活条件而进行的斗争。<br>A. 经济斗争<br>B. 文化斗争<br>C. 思想斗争<br>D. 政治斗争<br>正确答案：A</p>
</li>
<li><p>（）是科学社会主义的核心命题。<br>A. 人民群众是历史的创造者<br>B. 社会基本矛盾是社会发展的根本动力<br>C. 资本主义必然灭亡，社会主义必然胜利<br>D. 无产阶级是最先进最革命的阶级<br>正确答案：C</p>
</li>
<li><p>“资本主义必然灭亡，社会主义必然胜利”提出的根本依据是（）。<br>A. 唯物史观<br>B. 剩余价值理论<br>C. 人类社会发展规律<br>D. 价值规律<br>正确答案：C</p>
</li>
<li><p>无产阶级是最先进最革命的阶级，是因为（）。<br>A. 无产阶级在时间上是新的阶级<br>B. 无产阶级人数众多<br>C. 无产阶级受到剥削和压迫最深<br>D. 无产阶级的理性觉醒程度最高<br>正确答案：C</p>
</li>
<li><p>（）是无产阶级反抗资产阶级斗争的最高形式。<br>A. 社会主义思想<br>B. 无产阶级革命<br>C. 参与制<br>D. 工会<br>正确答案：B</p>
</li>
<li><p>无产阶级革命是以（）为核心的社会革命。<br>A. 文化革命<br>B. 法律革命<br>C. 政治革命<br>D. 经济革命<br>正确答案：C</p>
</li>
<li><p>（）是造成资本主义罪恶的总根源。<br>A. 社会化再生产必须保持的比例关系<br>B. 科学技术推动下的资本有机构成不断提高<br>C. 强调私有财产神圣不容侵犯的资本主义法律<br>D. 生产资料私人占有制<br>正确答案：D</p>
</li>
<li><p>马克思. 恩格斯深入研究了生态问题产生的根源. 本质和表现，指出（）是造成生态问题的根本原因。<br>A. 实践中的主体客体化过程<br>B. 自然资源本身的有限性<br>C. 资本主义制度<br>D. 人类中心论<br>正确答案：C</p>
</li>
<li><p>习近平在《生物多样性公约》第十五次缔约方大会领导人峰会上指出：“人不负青山，青山定不负人。生态文明是人类文明发展的历史趋势。”这所体现的科学社会主义基本原则是（）。<br>A. 社会主义社会要实现人与自然的和谐共生<br>B. 社会主义社会要在生产资料公有制基础上组织生产<br>C. 社会主义社会要实行按劳分配<br>D. 社会主义社会实行无产阶级专政<br>正确答案：A</p>
</li>
<li><p>“事实雄辩地证明，改革开放是决定当代中国命运的关键抉择，是发展中国特色社会主义. 实现中华民族伟大复兴的必由之路；……只有改革开放才能发展中国. 发展社会主义. 发展马克思主义。”这表明（）。<br>A. 改革是无产阶级反抗资产阶级斗争的最高形式<br>B. 改革对于社会主义社会的发展具有重要意义<br>C. 改革是推动社会主义社会发展的根本动力<br>D. 改革使中国已经跨越了社会主义初级阶段<br>正确答案：B</p>
</li>
<li><p>社会主义国家的改革的性质是（）。<br>A. 改变共产党的领导地位<br>B. 自下而上的革命<br>C. 从根本上改变社会主义制度<br>D. 社会主义社会的自我发展和完善<br>正确答案：D</p>
</li>
<li><p>国际共产主义运动的历史表明，社会主义的发展道路不是单一性的，而是（）的。<br>A. 阶段性<br>B. 全面性<br>C. 整体性<br>D. 多样性<br>正确答案：D</p>
</li>
<li><p>社会主义国家在经济上落后于发达资本主义国家，这就决定了在社会主义制度下必须把（）作为根本任务。<br>A. 完善无产阶级专政<br>B. 推进计划经济<br>C. 大力发展生产力<br>D. 加强对外扩张<br>正确答案：C</p>
</li>
<li><p>恩格斯在评论《资本论》第一卷出版时说过：“一些读者可能会以为他将从这本书里得知共产主义的千年王国到底是什么样子，谁指望得到这种乐趣，谁就大错特错。”这是因为（）。<br>A. 《资本论》没有关于共产主义的内容<br>B. 马克思没能预见未来社会的基本特征<br>C. 社会主义在这里还是空想形态<br>D. 马克思没有提供建设社会主义的现成方案<br>正确答案：D</p>
</li>
</ol>
<h3 id="多选-6"><a href="#多选-6" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>空想社会主义在19世纪上半叶发展到最高阶段，其主要代表人物有（）。<br>A. 傅立叶<br>B. 圣西门<br>C. 欧文<br>D. 恩格斯<br>正确答案：ABC</p>
</li>
<li><p>以三大空想社会主义者为代表的空想社会主义学说的进步性在于（）。<br>A. 对资本主义旧制度的批判中包含许多切中要害的见解<br>B. 对社会主义新制度的描述闪烁着诸多天才的火花<br>C. 反映了早期无产阶级改造现存社会的愿望<br>D. 是早期无产阶级意识和利益的先声<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯创立和发展了（），为实现社会主义从空想到科学的飞跃奠定了坚实的理论基础。<br>A. 劳动价值论<br>B. 辩证法<br>C. 剩余价值论<br>D. 唯物史观<br>正确答案：CD</p>
</li>
<li><p>之所以说马克思. 恩格斯实现了社会主义从空想到科学的伟大飞跃，是因为他们（）。<br>A. 科学论证了社会主义必然代替资本主义的历史必然性<br>B. 阐明了无产阶级的历史使命和革命斗争策略<br>C. 科学预见了未来社会的基本特征<br>D. 提出了从资本主义社会向共产主义社会过渡时期的理论<br>正确答案：ABCD</p>
</li>
<li><p>在巴黎公社失败后，马克思. 恩格斯根据巴黎公社的经验，提出的理论论断包括（）。<br>A. 无产阶级取得成功并保持胜利果实的收到条件是要有革命武装<br>B. 必须打碎旧的国家机器，建立无产阶级的新型国家<br>C. 无产阶级政权是为人民服务的机关<br>D. 必须建立无产阶级政党。发挥党的政治领导作用<br>正确答案：ABCD</p>
</li>
<li><p>关于十月革命的历史意义，下列说法中正确的有（）。<br>A. 使社会主义作为一种崭新的社会形态和社会制度登上历史舞台<br>B. 推动了受帝国主义压迫的国家的人民觉醒<br>C. 促进民族解放力量的崛起<br>D. 深刻改变了国际力量对比和世界格局<br>正确答案：ABCD</p>
</li>
<li><p>在俄国社会主义革命取得胜利的初期，特别是实行新经济政策期间，列宁提出了许多关于如何建设社会主义的精辟论述，包括（）。<br>A. 把建设社会主义作为一个长期探索. 不断实践的过程<br>B. 把大力发展生产力. 提高劳动生产率放在首要地位<br>C. 在多种经济成分并存的条件下，利用商品. 货币和市场发展经济<br>D. 利用资本主义建设社会主义<br>正确答案：ABCD</p>
</li>
<li><p>导致苏联解体. 苏东剧变的原因包括（）。<br>A. 西方国家的“和平演变”策略<br>B. 国内改革放弃了社会主义道路<br>C. 国内改革放弃了无产阶级专政<br>D. 否定了党的奋斗史，动摇了理想信念<br>正确答案：ABCD</p>
</li>
<li><p>在苏联的社会主义建设过程中形成了社会主义的苏联模式，对苏联模式的正确评价有（）。<br>A. 承认市场的作用，充分调动了企业和劳动者的积极性<br>B. 在当时促进了社会主义制度的巩固和发展<br>C. 在当时有力地推动了社会生产力的发展<br>D. 为苏联反法西斯战争的胜利提供了有力的物质和人员保障<br>正确答案：BCD</p>
</li>
<li><p>从世界角度看，中国特色社会主义进入新时代，意味着（）。<br>A. 科学社会主义焕发出强大的生机活力<br>B. 拓展了发展中国家走向现代化的途径<br>C. 为既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择<br>D. 为解决人类问题贡献了中国智慧和中国方案<br>正确答案：ABCD</p>
</li>
<li><p>在资本主义社会中，无产阶级和资产阶级之间斗争的形式有（）。<br>A. 经济斗争<br>B. 科研斗争<br>C. 政治斗争<br>D. 思想斗争<br>正确答案：ACD</p>
</li>
<li><p>无产阶级专政的任务包括（）。<br>A. 镇压剥削阶级的反抗和防御外敌入侵<br>B. 领导和组织国家建设<br>C. 发展社会主义民主<br>D. 推动社会全面进步<br>正确答案：ABCD</p>
</li>
<li><p>中国特色社会主义是根植于中国大地. 反映中国人民意愿. 适应中国和时代发展进步要求的科学社会主义，集中体现了（）的有机统一。<br>A. 科学社会主义基本原则<br>B. 当代中国实际<br>C. 中华优秀传统文化<br>D. 资本主义制度<br>正确答案：ABC</p>
</li>
<li><p>（）决定了我们必然要走出一条适合自身特点的社会主义发展道路。<br>A. 我国独特的历史文化传统<br>B. 现实的国情<br>C. 苏联模式的成功经验<br>D. 马克思共产主义理论的空想性<br>正确答案：AB</p>
</li>
<li><p>科学社会主义的基本原则是社会主义事业发展规律的集中体现，关于科学社会主义的基本原则，下列说法中正确的有（）。<br>A. 人类社会发展规律是“资本主义必然灭亡. 社会主义必然胜利”的根本依据。<br>B. 社会主义社会要对社会生产进行有计划的指导和调节，实行按需分配原则。<br>C. 无产阶级革命是无产阶级进行斗争的最高形式。<br>D. 社会主义社会要合乎自然规律地改造和利用自然，努力实现人与自然的和谐共生。<br>正确答案：ACD</p>
</li>
<li><p>社会主义的历史进程出现曲折. 弯路甚至重大挫折时，应该持（）态度。<br>A. 认识到一定曲折的不可避免性<br>B. 尽可能地避免某些曲折，使社会主义顺利发展<br>C. 直面曲折. 承认曲折<br>D. 总结经验教训，努力战胜和走出挫折<br>正确答案：ABCD</p>
</li>
<li><p>社会主义实现模式多样化的原因在于（）。<br>A. 政治经济水平的发展不同<br>B. 指导思想不同<br>C. 历史传统不同<br>D. 社会文化环境不同<br>正确答案：ACD</p>
</li>
<li><p>探索符合本国国情的发展道路必须（）。<br>A. 坚持对待马克思主义的科学态度<br>B. 从当时当地的历史条件出发<br>C. 充分吸收入类一切文明成果<br>D. 恪守科学社会主义所有经典论述<br>正确答案：ABC</p>
</li>
<li><p>“人民的伟力，是渡江战役的小木船，划出了改变历史的伟大胜利；人民的伟力，是‘小铁锹’挖出的大油田，把贫油的帽子甩到了太平洋；人民的伟力，是小岗村按下的‘红手印’，拉开了农村改革的历史大幕；……”这体现了（）。<br>A. 社会主义是亿万人民群众的伟大实践<br>B. 人民群众是社会历史的创造者<br>C. 必须紧紧依靠人民群众<br>D. 要凝聚起亿万人民群众的力量<br>正确答案：ABCD</p>
</li>
<li><p>社会主义在实践中开拓前进必须遵循（）。<br>A. 追逐剩余价值绝对规律<br>B. 人类社会发展规律<br>C. 社会主义建设规律<br>D. 共产党执政规律<br>正确答案：BCD</p>
</li>
<li><p>共产党执政规律的内容包括（）。<br>A. 始终站在人民大众的立场上<br>B. 坚持党中央权威和集中统一领导<br>C. 不断加强自身建设<br>D. 把党的政治建设摆在首位<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-6"><a href="#判断-6" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>19世纪初期的空想社会主义是科学社会主义的直接思想来源。<br>对</p>
</li>
<li><p>空想社会主义反映了早期无产阶级意识和利益，是科学的思想体系。<br>错</p>
</li>
<li><p>恩格斯晚年看到了资本主义的新变化，注重合法斗争，否定了暴力革命的作用。<br>错</p>
</li>
<li><p>社会主义发展史证明，苏联模式是特定历史条件下的产物，并不是社会主义的唯一模式。<br>对</p>
</li>
<li><p>中国革命的胜利，是继十月革命之后20世纪最重大的事件。<br>对</p>
</li>
<li><p>在世界社会主义遇到严重挫折的严峻考验面前，中国共产党成功把中国特色社会主义推向21世纪，向世界展示了社会主义的优越性。<br>对</p>
</li>
<li><p>新中国30年的探索取得了多方面的巨大成绩，为新时期开创中国特色社会主义提供了宝贵经验. 理论准备和物质基础。<br>对</p>
</li>
<li><p>只有将科学社会主义基本原则与本国国情相结合，才能创造性地回答和解决本国实际问题。<br>对</p>
</li>
<li><p>无产阶级政党是无产阶级反对资产阶级的斗争发展到一定阶段的产物。<br>对</p>
</li>
<li><p>建立在社会主义公有制基础上的社会是以人民为主体的社会，实现好. 维护好. 发展好人民群众的利益，是社会主义的本质要求。<br>对</p>
</li>
<li><p>生产资料公有制是社会主义经济制度的根基。<br>对</p>
</li>
<li><p>在共产主义的不同阶段，应当实行具有不同特征的分配制度。<br>对</p>
</li>
<li><p>实行单一的计划经济，忽略或排斥市场的作用，不利于社会主义社会生产力的发展。<br>对</p>
</li>
<li><p>马克思主义政党的根本宗旨是为人民群众谋利益。<br>对</p>
</li>
<li><p>社会阶级消灭的前提是生产高度发展。<br>对</p>
</li>
<li><p>“资产阶级的灭亡和无产阶级的胜利是同样不可避免的”是共产主义理想信念的核心要义。<br>对</p>
</li>
<li><p>“无论哪一个社会形态，在它所能容纳的全部生产力发挥岀来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的”是对“两个必然”的否定。<br>错</p>
</li>
<li><p>无产阶级不是一成不变的，而是会随着社会发展而有所变化，不断实现自身的发展和提高。<br>对</p>
</li>
<li><p>暴力革命是无产阶级革命的一般形式，在无产阶级反抗资产阶级的斗争中，和平地取得政权或进行社会改造是没有可能的。<br>错</p>
</li>
<li><p>共产主义是人类最美好的社会制度。<br>对</p>
</li>
<li><p>共产主义是人类最美好的境界，是真正的历史的终结。<br>错</p>
</li>
<li><p>坚定共产主义理想信念，坚守共产党人精神追求，始终是共产党人安身立命的根本。<br>对</p>
</li>
<li><p>习近平新时代中国特色社会主义思想，标志着我们党在自觉把科学社会主义基本原则与中国实际和时代特征相结合上达到了新的境界。<br>对</p>
</li>
<li><p>社会主义制度能够从根本上消除资本主义导致的两极分化和不公平不公正现象，为人的发展提供可靠的保障，这是我们对社会主义保持必胜信念的坚实根据。<br>对</p>
</li>
<li><p>不同国家试图用同样的“一条道路”“一种模式”发展社会主义是行不通的。<br>对</p>
</li>
<li><p>探索社会主义发展道路，必须坚持对待马克思主义的科学态度。<br>对</p>
</li>
<li><p>在社会主义建设取得了重大成就，社会主义制度有了长足进步之后，资本主义的进攻方式则往往转变为以“和平演变”为主。<br>对</p>
</li>
<li><p>探索社会主义发展道路，必须充分吸收入类一切文明成果。<br>对</p>
</li>
<li><p>除了生产力. 社会发展阶段以及时代和实践的不断发展之外，历史文化传统的差异性是造成不同国家社会主义发展道路多样性的重要条件。<br>对</p>
</li>
<li><p>从总体实力看，发达资本主义国家仍然比发展中的社会主义国家要强大。<br>对</p>
</li>
<li><p>在社会主义进程中产生的种种问题的根源并不在于制度本身，而相当程度上在于人们没有认识和掌握社会主义建设规律。<br>对</p>
</li>
<li><p>各个民族从历史上继承下来的经济. 政治. 文化条件的不同，决定了每个民族都必须从自己的实际出发，按照自己民族的特点进行社会主义建设。<br>对</p>
</li>
<li><p>苏联. 东欧社会主义的失败是社会主义本身的失败。<br>错</p>
</li>
<li><p>社会主义国家只有尽快发展经济，提高综合国力，才能摆脱落后挨打的局面。<br>对</p>
</li>
<li><p>共产党执政规律具有丰富的内涵和实践要求，执政最根本的是人心向背。<br>对</p>
</li>
</ol>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="单选-7"><a href="#单选-7" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>马克思主义展望未来社会的科学方法之一是（）。<br>A. 立足于既揭示未来社会的一般特征，又作详尽的细节描绘<br>B. 立足于揭示未来社会的详尽细节，而不作一般特征的描绘<br>C. 立足于描绘未来社会的全部特征，而不仅指出未来社会发展的方向<br>D. 立足于揭示未来社会的一般特征，而不作详尽的细节描绘<br>正确答案：D</p>
</li>
<li><p>共产主义社会实现的根本条件是（）。<br>A. 国家垄断资本主义的形成<br>B. 人类理性的高度觉醒<br>C. 人类19世纪创造的优秀理论成果<br>D. 生产力的高度发达<br>正确答案：D</p>
</li>
<li><p>在展望未来社会的问题上，马克思主义与空想社会主义的根本区别是（）。<br>A. 是否坚持科学的立场. 观点. 方法<br>B. 展望的目的和动机是否正确<br>C. 是否有预见未来社会详细特征<br>D. 是否包含着对现存制度的批判<br>正确答案：A</p>
</li>
<li><p>列宁指出，马克思提出共产主义问题“正像一个自然科学家已经知道某一新的生物变种是怎样产生以及朝着哪个方向演变才提出该生物变种的发展问题一样”，马克思对共产主义的描述（）。<br>A. 立足于对先天理念的回忆<br>B. 立足于对人类社会特别是资本主义社会发展规律的揭示<br>C. 是对人们已经知道的内容的重复<br>D. 是对自然界发展规律的揭示<br>正确答案：B</p>
</li>
<li><p>马克思曾说：“新思潮的优点又恰恰在于我们不想教条地预期未来，而只是想通过批判旧世界发现新世界”，这说明（）。<br>A. 马克思主义没有预见到未来社会的发展<br>B. 马克思主义只具有批判性不具有革命性<br>C. 马克思主义在剖析资本主义的基础上阐发未来新世界<br>D. 马克思主义不能指导人民建立新世界<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“共产主义者不是把某种哲学作为前提，而是把迄今为止的全部历史，特别是这一历史在文明各国造成的实际结果作为前提。”这说明（）。<br>A. 马克思主义哲学不是共产主义者的指导思想<br>B. 共产主义就是人类迄今为止的全部历史<br>C. 共产主义已经在各国实现<br>D. 共产主义思潮是人类历史发展的必然结果<br>正确答案：D</p>
</li>
<li><p>马克思. 恩格斯在展望未来社会时，总是只限于指出未来社会发展的方向. 原则和基本特征，这是因为（）。<br>A. 马克思主义具有局限性，不能科学预见未来<br>B. 共产主义本身不具有现实性和必然性<br>C. 未来的具体事情只能由未来的具体实践来回答<br>D. 马克思. 恩格斯个人十分谦逊<br>正确答案：C</p>
</li>
<li><p>马克思在《哥达纲领批判》中指出：“只有在那个时候，才能完全超出资产阶级权利的狭隘眼界，社会才能在自己的旗帜上写上：各尽所能，按需分配！”此处的“那个时候”可能指的是（）。<br>A. 社会生产力高度发展物质财富极大丰富的时候<br>B. 绝对精神完成实体化的时候<br>C. 无产阶级专政登上历史舞台的时候<br>D. 社会主义在各国普遍建立的时候<br>正确答案：A</p>
</li>
<li><p>共产主义社会的生产资料将实现（）。<br>A. 私人直接占有<br>B. 国家直接占有<br>C. 法人资本所有<br>D. 社会直接占有<br>正确答案：D</p>
</li>
<li><p>在共产主义社会，人与自然达成和谐，这意味着（）。<br>A. 人不再需要改造世界<br>B. 人彻底超脱自然规律<br>C. 人能够以合乎自然规律的方式改造和利用自然<br>D. 人与自然的运动达到绝对静止<br>正确答案：C</p>
</li>
<li><p>精神境界极大提高是共产主义新人的重要体现，这种精神境界主要表现为（）。<br>A. 自觉地为他人. 集体和社会服务和奉献<br>B. 万法唯识不动本心<br>C. 存理灭欲<br>D. 超脱万物<br>正确答案：A</p>
</li>
<li><p>（）是马克思主义追求的根本价值目标。<br>A. 批判资本主义社会<br>B. 认识人类社会发展规律<br>C. 建立无产阶级专政<br>D. 实现人的自由而全面的发展<br>正确答案：D</p>
</li>
<li><p>共产主义社会中人的自由而全面的发展指的是（）的发展。<br>A. 社会统治者<br>B. 少数社会精英<br>C. 社会管理者<br>D. 全体社会成员<br>正确答案：D</p>
</li>
<li><p>恩格斯指出，在共产主义社会，“支配着人们的自然规律而同人们相对立的规律，那时就将被人们熟练地运用”，这说明在共产主义社会（）。<br>A. 人可以创造和改变自然规律<br>B. 人完全摆脱自然规律的影响<br>C. 人实现了从必然王国向自由王国的飞跃<br>D. 规律不再具有认识价值<br>正确答案：C</p>
</li>
<li><p>共产主义理想之所以是能够实现的社会理想，是因为它（）。<br>A. 细节描绘充分<br>B. 是人类向往的美好境界<br>C. 具有客观必然性<br>D. 是人类不断追求的目标<br>正确答案：C</p>
</li>
<li><p>无产阶级特殊的社会地位和历史使命，决定了它只有解放（）才能使自己最后得到彻底解放。<br>A. 全人类<br>B. 资产阶级<br>C. 农民阶级<br>D. 地主阶级<br>正确答案：A</p>
</li>
<li><p>社会主义的任务中，最根本的是（）。<br>A. 发展生产力<br>B. 形成社会主义意识形态<br>C. 建立平等的法律制度<br>D. 实行按劳分配<br>正确答案：A</p>
</li>
<li><p>在全世界实现共产主义，首先将取决于（）。<br>A. 人类理性的觉醒<br>B. 绝对理念的发展阶段<br>C. 社会主义国家的巩固和发展<br>D. 对共产主义描绘的详尽性<br>正确答案：C</p>
</li>
<li><p>习近平指出：“共产主义决不是‘土豆烧牛肉’那么简单”，意在启示我们（）。<br>A. 共产主义的物质财富并不丰富<br>B. 实现共产主义需要长期实践探索<br>C. 共产主义不可实现<br>D. 共产主义社会人们不再有吃穿等生活需要<br>正确答案：B</p>
</li>
<li><p>（）是共产主义的低级阶段，也是实现共产主义的必由之路。<br>A. 资本主义<br>B. 社会主义<br>C. 无政府主义<br>D. 市场经济<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选-7"><a href="#多选-7" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>属于共产主义社会的特征的有（）。<br>A. 社会财富极大丰富，消费品按需分配<br>B. 社会关系高度和谐，人们的精神境界极大提高<br>C. 社会财富极大丰富，消费品按劳分配<br>D. 每个人自由而全面的发展<br>正确答案：ABD</p>
</li>
<li><p>“共产主义”一词具有多种含义，包括（）。<br>A. 共产主义思想体系<br>B. 绝对平均主义社会<br>C. 共产主义社会<br>D. 共产主义运动<br>正确答案：ACD</p>
</li>
<li><p>相较于以往人们对现实社会的批判，马克思. 恩格斯的高明之处在于（）。<br>A. 不做详尽的描述<br>B. 揭示社会弊端的根源<br>C. 揭示现实社会否定自身的力量<br>D. 在设想未来社会的基础上批判现实<br>正确答案：BC</p>
</li>
<li><p>关于“按劳分配”原则，下列说法中正确的有（）。<br>A. 就其用“劳动”代替资本作为分配标准而言是平等的<br>B. 就其把“劳动”这同一标准运用在不同情况的人身上是不平等的<br>C. 导致劳动能力不同的人在收入分配上的差距<br>D. 在某种意义上还是商品等价交换的原则<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，在共产主义社会中将会消失的有（）。<br>A. 阶级<br>B. 国家<br>C. 所有社会管理机构<br>D. 战争<br>正确答案：ABD</p>
</li>
<li><p>在共产主义社会，工业与农业. 城市与乡村. 脑力与体力的差别将会消失，这种消失是指（）。<br>A. 利益对立的消失<br>B. 利益划分的消失<br>C. 活动方式差异的消失<br>D. 环节划分的消失<br>正确答案：AB</p>
</li>
<li><p>分工是人类生产活动发展到一定阶段的产物，关于分工，下列说法中正确的有（）。<br>A. 分工对于提升劳动熟练程度具有重要作用<br>B. 在共产主义社会中，分工将会消失<br>C. 自然形成的分工限制了人的活动范围<br>D. 资本主义社会创造了消除旧式分工的条件<br>正确答案：ACD</p>
</li>
<li><p>在共产主义社会，劳动成为“生活的第一需要”，这意味着（）。<br>A. 劳动能力和劳动时间不再是分配的尺度<br>B. 劳动不再是固定. 僵化在一定范围内的劳动<br>C. 劳动不再具有强迫性<br>D. 劳动成为人生快乐的巨大源泉<br>正确答案：ABCD</p>
</li>
<li><p>人的自由而全面的发展，是在（）实现的。<br>A. 在多样化的生产劳动过程中<br>B. 没有法律的社会中<br>C. 在生产劳动之外的大量自由时间中<br>D. 在统一化的劳动生产过程中<br>正确答案：AC</p>
</li>
<li><p>关于共产主义理想，下列说法中正确的有（）。<br>A. 共产主义实现的可能十分渺茫<br>B. 共产主义是能够实现的理想<br>C. 在社会主义历史阶段不应树立共产主义理想<br>D. 共产主义理想的实现是一个漫长的历史过程<br>正确答案：BD</p>
</li>
<li><p>实现共产主义是一个长期的实践过程，因为（）。<br>A. 社会主义的充分发展需要很长的历史时期<br>B. 社会主义向共产主义的过渡需要很长的历史时期<br>C. 当代资本主义的灭亡是一个长期的过程<br>D. 资本主义灭亡向社会主义. 共产主义的转变也是一个长期的过程<br>正确答案：ABCD</p>
</li>
<li><p>对共产主义基本特征的认识应根据对（）等的认识来把握。<br>A. 人类社会结构<br>B. 生产力状况<br>C. 生产关系状况<br>D. 社会生活和精神生活<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义不仅从社会形态更替规律上对共产主义社会理想实现的必然性作了一般性的历史观论证，而且通过对资本主义的科学批判作了具体阐明，包括（）。<br>A. 揭示了资本主义生产方式的特点，论证了资本主义发展自我否定的趋势<br>B. 揭示了生产社会化与生产资料私人占有之间的基本矛盾，论证了资本主义的历史暂时性<br>C. 揭示了资本主义剥削的秘密与资本主义的非正义性，论证了工人阶级推翻旧世界. 建设新世界的历史使命<br>D. 揭示了工人阶级和资产阶级斗争的发展规律和趋势，论述了工人阶级解放斗争胜利的必然性<br>正确答案：ABCD</p>
</li>
<li><p>实现共产主义是人类最伟大的事业，它的实现（）。<br>A. 离不开工人阶级及其政党的能动性发挥<br>B. 离不开社会主义国家建设事业的推进<br>C. 离不开世界社会主义运动的发展<br>D. 必须找到现实的阶级力量<br>正确答案：ABCD</p>
</li>
<li><p>从层次上看，共产主义远大理想与中国特色社会主义共同理想的关系，是（）的关系。<br>A. 社会理想和个人理想<br>B. 最终理想和阶段性理想<br>C. 最高纲领与最低纲领<br>D. 全人类理想和全体中国人民理想<br>正确答案：BCD</p>
</li>
<li><p>关于共同理想与远大理想之间的关系，以下说法中正确的有（）。<br>A. 实现共同理想是实现远大理想的必经阶段<br>B. 实现远大理想是实现共同理想的必然趋势和最终目的<br>C. 共同理想和远大理想是辩证统一的<br>D. 实现了共同理想也就实现了远大理想<br>正确答案：ABC</p>
</li>
<li><p>当前，中国特色社会主义进入了新时代，为当代大学生提供了施展才华的历史机遇，大学生应该（）。<br>A. 坚定社会主义共同理想信念<br>B. 积极投身新时代中国特色社会主义事业<br>C. 做新时代的奋进者. 开拓者. 奉献者。<br>D. 用马克思主义信仰的力量开创美好未来。<br>正确答案：ABCD</p>
</li>
<li><p>关于远大理想和共同理想的关系，下列说法中正确的有（）。<br>A. 没有远大理想的指引，就不会有共同理想的确立和坚持<br>B. 没有共同理想的实现，远大理想就没有现实的基础<br>C. 忘记远大理想而只顾眼前，就会失去前进的方向<br>D. 离开现实工作而空谈远大理想，就会脱离实际<br>正确答案：ABCD</p>
</li>
<li><p>习近平指出：“青年是标志时代的最灵敏的晴雨表，时代的责任赋予青年，时代的光荣属于青年。”这说明（）。<br>A. 青年是祖国的未来. 民族的希望<br>B. 青年兴则国家兴，青年强则国家强<br>C. 青年的综合素质是一个国家发展活力的重要体现<br>D. 青年一代有理想. 有本领. 有担当，国家就有前途，民族就有希望<br>正确答案：ABCD</p>
</li>
<li><p>中国特色社会主义共同理想与共产主义远大理想的内在关系包括（）。<br>A. 最终理想与阶段性理想的关系<br>B. 最高纲领与最低纲领的关系<br>C. 少数人的理想与多数人的理想的关系<br>D. 全人类理想与全体中国人民理想的关系<br>正确答案：ABD</p>
</li>
<li><p>当代青年学习马克思主义基本原理和马克思主义中国化成果要坚持（）。<br>A. 学而信<br>B. 学而用<br>C. 学而行<br>D. 把学习成果转化为不可撼动的理想信念<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-7"><a href="#判断-7" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>在马克思主义产生以前，人们已掌握预见未来的科学方法，发现人类社会发展的客观规律。<br>错</p>
</li>
<li><p>在展望未来理想社会时，要在社会主义社会发展中不断深化对未来共产主义社会的认识。<br>对</p>
</li>
<li><p>共产主义社会里，由于部分有觉悟的人的无私奉献，一般人坐享其成成为可能。<br>错</p>
</li>
<li><p>共产主义社会将按照自然资源的情况和社会成员的需要，对生产进行有计划的组织和管理。<br>对</p>
</li>
<li><p>实现人的自由而全面的发展，是马克思主义追求的根本价值目标，也是共产主义社会的根本特征。<br>对</p>
</li>
<li><p>在共产主义社会，个人劳动直接成为社会劳动的一部分，个人利益直接在社会利益中得到实现。<br>对</p>
</li>
<li><p>在共产主义社会，劳动者个人的劳动通过交换价值的途径向社会劳动转化，社会成员之间的相互服务采取等价交换的形式来进行。<br>错</p>
</li>
<li><p>在共产主义社会，国家将消亡，所有的社会组织管理机构都随之消亡，军队. 警察. 监狱等也将失去作用。<br>错</p>
</li>
<li><p>在共产主义社会，与社会生产力的高度发展和社会关系的高度和谐相联系，人们的精神境界得到极大提高。<br>对</p>
</li>
<li><p>在共产主义社会，劳动不再是单调枯燥和具有强迫性的劳动，而成为人们乐于从事的自我实现的活动。<br>对</p>
</li>
<li><p>列宁对社会主义和共产主义做了区分，这是对马克思共产主义理论的否定。<br>错</p>
</li>
<li><p>共产主义社会，人不需要从事劳动，因而是自由的。<br>错</p>
</li>
<li><p>社会主义社会经过长期发展进入共产主义社会，这是一个客观必然的历史进程。<br>对</p>
</li>
<li><p>共产主义理想是以人类社会发展规律以及资本主义社会的基本矛盾发展为依据的。<br>对</p>
</li>
<li><p>社会主义社会和共产主义社会没有关联，社会主义革命的胜利无法被当作共产主义理想是可以实现的证据。<br>错</p>
</li>
<li><p>现代产业工人不占有生产资料而靠向资本家出卖劳动力为生，并通常处于某种贫困状态，所以是“无产阶级”。<br>对</p>
</li>
<li><p>从资本主义到社会主义有一个过渡时期，这是一个充满矛盾和斗争的复杂历史过程。<br>对</p>
</li>
<li><p>在完成资本主义向社会主义的转变以后，还要经历一个社会主义发展阶段，最后才能逐步走向共产主义。<br>对</p>
</li>
<li><p>现存的资本主义国家将来不论发达到何种程度，当其实现根本性制度变革的时候，也只能是首先进入共产主义社会的低级阶段即社会主义社会，而不可能直接达到共产主义社会的高级阶段。<br>对</p>
</li>
<li><p>社会主义是实现共产主义的必由之路。<br>对</p>
</li>
<li><p>进入社会主义时期的国家应该以具有自身特点的方式逐步向共产主义方面迈进。<br>对</p>
</li>
<li><p>无产阶级是先进生产力的代表，深受资产阶级的剥削和压迫，为争取自身的解放进行了不懈的斗争。<br>对</p>
</li>
<li><p>远大理想与共同理想的关系是最终理想与阶段性理想的关系。<br>对</p>
</li>
<li><p>共产主义远大理想体现的是全人类解放的共性，是面向全人类的。<br>对</p>
</li>
<li><p>中国悠久的历史和特殊的国情决定了走中国特色社会主义道路是中华民族通向共产主义的必由之路。<br>对</p>
</li>
<li><p>中国特色社会主义道路，就是在中国共产党的领导下，立足基本国情，以经济建设为中心，坚持四项基本原则，坚持改革开放，解放和发展社会生产力，逐步实现全体人民共同富裕，建设社会主义现代化强国。<br>对</p>
</li>
<li><p>中国特色社会主义是党的最高纲领和基本纲领的统一。<br>对</p>
</li>
<li><p>远大理想可以有多个，阶段性理想则只能有一个。<br>错</p>
</li>
<li><p>理想是指引人们奋斗方向的航标，也是推动人们前进的强大精神动力。<br>对</p>
</li>
<li><p>共产主义理想是人类最伟大的社会理想。<br>对</p>
</li>
<li><p>经过长期的探索，特别是经过改革开放以来的伟大实践，我们已经找到了中国特色社会主义这条正确道路。<br>对</p>
</li>
<li><p>中国特色社会主义道路是中华民族最终走向共产主义的必由之路。<br>对</p>
</li>
<li><p>党的最高纲领和最低纲领的区分最初是在革命年代做出的，在今天已经不再需要区分二者。<br>错</p>
</li>
<li><p>当讲到坚定中国特色社会主义共同理想的时候，不仅是指中国人民对社会主义理想的向往和追求，而且也包含着对“中国道路”的认同。<br>对</p>
</li>
<li><p>中国特色社会主义新时代为当代大学生提供了施展人生才华的极为有利的历史机遇。<br>对</p>
</li>
<li><p>共产主义远大理想不只属于中国人民，而是属于全人类的。<br>对</p>
</li>
<li><p>没有共同理想的实现，远大理想就没有现实的基础。<br>对</p>
</li>
<li><p>社会主义运动的实践，特别是社会主义国家的兴起和不断发展，已经并正在用事实证明共产主义理想实现的必然性。<br>对</p>
</li>
<li><p>社会主义社会与共产主义社会具有根本性质上的一致性。<br>对</p>
</li>
<li><p>共产主义共同愿望来自于人民群众的根本利益和需要，也来自他们对现实生活的感受。<br>对</p>
</li>
<li><p>“工人阶级”和“无产阶级”是两个不同阶级，有一定的交叉性。<br>错</p>
</li>
<li><p>在无产阶级产生以前，任何阶级都不可能实现消灭剥削和压迫的社会理想。<br>对</p>
</li>
<li><p>马克思主义的诞生使无产阶级有了科学理论指导和坚强的领导核心。<br>对</p>
</li>
<li><p>不具备主观客观条件下的革命，是不可能成功和建立起共产主义新社会的。<br>对</p>
</li>
<li><p>马克思. 恩格斯在剩余价值学说的基础上，准确地判断了资本主义具体何时灭亡的问题。<br>错</p>
</li>
<li><p>资本主义社会灭亡后将直接进入共产主义社会的高级阶段。<br>错</p>
</li>
<li><p>社会主义的充分发展和共产主义的实现将是一个漫长的历史过程。<br>对</p>
</li>
<li><p>共产主义不是教义，而是运动。<br>对</p>
</li>
<li><p>在共产主义社会，乐意为社会公共事业作出贡献已经成为人的自觉。<br>对</p>
</li>
</ol>
]]></content>
      <categories>
        <category>马克思</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>马克思</tag>
      </tags>
  </entry>
</search>
