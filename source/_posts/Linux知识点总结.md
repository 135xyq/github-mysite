---
title: Linux期末知识点总结
date: 2021-12-30 18:50:45
description: Linux知识点总结
categories: "Linux" #分类
tags:   #标签
    - 课程学习
    - Linux
---


# Linux知识点总结

## Linux概述

### Linux系统的优缺点

1. 优点：Linux系统主打网络服务，专业性强，免费开源，主要用于搭建服务器，性能稳定，长时间开机不出现卡顿，漏洞少，更安全；
2. 缺点：Linux式子专业系统，对业余人员不友好，操作难度较高。

### Linux系统的特点

1. 一切皆文件
2. 完全兼容可移植操作系统接口POSIX1.0标准
3. 多用户、多任务
4. 完全免费

### Linux的含义

Linux是指在GPL协议下发行的遵循可移植性操作系统POSIX标准的操作系统内核。
通常说的Linux是指基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。
Linux是类UNIX操作系统。

### Linux的诞生、发展和成长过程依赖五个重要支柱

1. UXIX操作系统
2. MINIX操作系统
3. GNU计划
4. POSIX标准
5. Internet


### Linux内核的组成

1. 内存管理器：对内存资源的访问控制。
2. 进程管理器：对CPU的访问控制。
3. 设备驱动程序：实际控制操作系统和硬件设备之间的交互，并且提供一组操作系统可理解的抽象接口，完成和操作系统之间的交互，与硬件相关的具体操作细节也由设备驱动程序完成。
4. 虚拟文件系统：VFS隐藏各种文件系统的具体细节，为文件系统提供统一的接口。
5. 网络管理：管理各种网络设备，并实现各种网络协议栈，最终通过网络连接其他系统。

### shell 分为

1. GLI命令行界面
2. GUI图用户界面

### Linux文件系统

Linux一切皆文件；
文件系统是指文件存放在磁盘等存储设备上的组织方法。

## Linux基本操作

### 基本命令

**命令格式**： command [options] [arguments]  ，命令名：[选项]：[参数]

### 获取帮助

```shell 
man [option] filename
```

```shell
--help |more
```
### 日志

Linux 日志文件存放在 /var/log目录下

日志记录了程序的运行状态，包括各种错误信息、警告信息和其他的提示信息。

## 文件系统和文件管理

### Linux文件类型

1. 普通文件
2. 目录文件
3. 链接文件
4. 设备文件
5. 管道文件


#### 普通文件

- 普通文件是指以**字节**为单位的**数据流**类型文件，其特点是不包含文件系统的结构信息。
- 通常用户接触到的文件，如图形文件、数据文件、文档文件、声音文件等都属于普通文件。
- 按其内部结构分为文本文件和二进制文件。

#### 目录文件

- 目录文件不存放常规数据，它是用来**组织**、**访问**其他文件的，是内核组织文件系统的基本节点。
- 目录文件可以包含下一级目录文件或普通文件。
- 目录文件是一种文件，是Linux文件中的一种


#### 链接文件

- 链接文件是一种特殊的文件，是指向一个真实存在的文件链接(类似于Windows的快捷方式)。
- 根据链接文件的不同，分为**硬链接**（Hard Link）文件和**符号链接**（Symbolic Link，又称为软链接）文件


#### 设备文件
- 设备文件是Linux中最特殊的文件，可以方便地访问外部设备。
- Linux为外部设备提供一种标准接口，将外部设备视为一种特殊的文件。用户可以像访问普通文件一样访问任何外部设备，使Linux系统可以很方便地适应不断变化的外部设备。
- 设备文件放在/dev目录下，设备文件使用设备的主设备号和次设备号来指定某外部设备。
- 根据访问数据方式的不同，设备文件分为：块设备和字符设备文件。

#### 管道文件
- 管道文件是一种很特殊的文件，主要用于不同进程的信息传递。
- 当两个进程间需要传递数据或信息时，可以使用管道文件。一个进程将需传递的数据或信息写入管道的一端，另一进程则从管道另一端取得所需的数据或信息。

### 文件类型判断
```shell
file [option] filename
```

### 查看文件的详细属性

使用stat命令，例如，文件的名称、大小、权限、atime、ctime、mtime等

```shell
state [option] filename
```


### 显示当前工作目录

```shell
pwd
```

### 绝对路径和相对路径

- 绝对路径是以根目录“/”开始，递归每级目录直到目标路径。
- 相对路径是以当前目录为起点，到达目标的路径。

### 显示目录下的文件结构

```shell
tree filename
```
### 切换目录

```shell
cd [directory]
```
```cd - ```表示返回到上次目录。
```cd ..```表示返回到上一级目录

### ls命令

```shell
ls [option] [names]

```
- 显示所有隐藏文件
```shell
ls -a
```
- 显示所有以a开头的文件
```shell
ls a*
```

### 目录的创建和删除

#### 创建

```shell
mkdir [option] [dirname]
```
dirname : 目录名称
参数：-p :创建多层目录，-v：显示创建过程信息
#### 删除

**rmdir命令只能用来删除空目录**

```shell
rmdir [option] [dirname]
```
dirname : 目录名称

### 文件的创建、查看、复制、移动、删除、排序

#### 创建

```shell
touch [option] filename
```

#### 查看
```
 cat [option] filename
```
- 用来显示文件内容， 依次读取其后所指文件的内容并将其输出到标准输出设备上。
- 能够用来连接两个或者多个文件，形成新文件。

more命令以逐页的方式显示文件的内容.
less命令也是对文件或其他输出进行分页显示。
head命令可以查看文件的前几行的内容。
tail命令查看文件的后几行的内容

#### 复制

```shell
cp [option] source  dest
```
source表示需要复制的文件，dest 表示需要复制到的目录。

#### 移动

```shell
mv [option] source dest
```
为文件或目录改名或者将文件由一个目录移动到另一个目录中


#### 删除
```shell
rm [option] filename
```
- 删除一个目录中的一个或者多个文件。
- 将某个目录及其下的所有文件及子目录均删除。
- 对于链接文件，只是删除了链接，原有文件均保持不变

#### 排序

对文件中的各行进行排序。
```shell
sort [option] filename
```

### 文件查找

以指定的查找模式搜索文件，通知用户在什么文件中搜索到与指定模式匹配的字符串，并且打印出所有包含该字符的文本行，该文本行的最前面是该行所在的文件名。

```shell
grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][–help][范本样式][文件或目录…]
```


find:从指定的目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对其采取相关的操作。

```shell
find [pathname] [option] filename
```


### linux 文件链接

#### 硬链接

- 默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。
- 创建一个硬链接时，也为这个文件创建了一个额外的目录条目。

##### 硬链接的局限性
（1）硬链接不能引用自身文件系统之外的文件，即不能引用不在同一磁盘分区的文件。
（2）硬链接无法引用目录。

当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在，除非该文件的所有链接都被删除了

#### 符号链接（软链接）

符号链接指向的文件与符号链接自身几乎没有区别。

### 文件时间

在Linux系统中，文件是没有创建时间的，如果新创建一个文件，它的三个时间都是与创建的时间相同。


#### 1.访问时间（Access time）

对文件内容进行一次读操作时间。

#### 2.修改时间（Change time）

文件内容被最后一次修改的时间。

ls -l 命令显示出来的文件时间就是这个时间

#### 3.状态时间（Modify time）

当文件的状态被改变时，状态时间就会改变

## Linux用户管理

超级用户可以对普通用户进行跟踪，并限制它们的访问权限，以保证系统安全。

Linux系统并不能识别用户账号名称信息，所以每个用户都有一个唯一的系统可识别的UID

id命令可以查看当前用户登录信息。
- UID(User Identification)为用户的ID。
- GID(Group Identification)为用户所属组的ID。
- groups为用户属于的所有组的ID。


ps aux | less命令查看进程



### 用户分类

1. root用户：拥有最高权限，ID为0。
2. 普通用户：可以登录，由管理员创建，使用权限有限。
3. 系统用户：不具有登录的能力，但是系统运行不可或缺的。


### 管理用户组

- useradd用来添加用户。
- passwd修改用户口令。
- usermod修改用户信息。
- userdel删除用户。

#### 添加用户

添加用户就是在系统中创建一个新账号，并为新账号分配用户ID、用户组、主目录和登录Shell等资源。

```shell
useradd [option] username
```
username表示新账号的登录名

#### 修改用户口令

用户账号刚创建时没有口令，无法使用，必须为其指定口令后才可以使用，即使是空口令。

```shell
passwd [option] [username]
```

- username参数没有指定时，表示修改当前用户的口令。
- 如果指定了该参数，则表示修改指定用户的口令，只有root用户才有修改指定用户口令的权限

#### 删除用户

删除用户就是删除与用户有关的系统配置文件中的记录（如/etc/passwd）

```shell
userdel [option] username
```

#### 修改用户信息

修改用户信息就是更改用户的属性，如用户 ID、主目录、用户所在组、登录Shell等。

```shell
usermod [option] username
```

gpasswd命令--从用户组中移出一个用户
```shell
gpasswd [-a user][-d user][-A user,...][-M user,...][-r][-R]groupname
```



### 管理用户组

用户组是具有相同特征用户的集合，每个用户都有一个用户组，方便系统集中管理一个用户组中的所有用户

#### 添加用户组
```shell
groupadd [option] group_name
```


#### 删除用户组
```shell
groupdel group_name
```

#### 修改用户组
```shell
groupmod [option] group_name
```

#### 查看用户的分组
1. groups命令查看。命令：
```shell
groups
groups user1 user2
```
2. 查看文件/etc/group法，通过grep命令查询某个用户所在的用户组。
3. id命令法，只执行id命令就可以查看。命令：
```shell
id
id user2
```

### 和用户相关的一些系统文件
1. /etc/passwd文件保存用户信息。
2. /etc/shadow文件保存加密的用户密码。
3. /etc/group文件保存用户组信息。
4. /etc/login.defs配置文件。

**su root**可以返回root 


## 文件权限

权限的意义在于允许某一个用户或某个用户组以规定的方式去访问某个文件。

### U G O

U: owner为属主，文件所有者。
G：group为属组，同组用户。
O：other为其他用户。

### UGO方式每组的3个字符具体意义如下：

r:read，数字设定值为4
w:write,数字设定值为2
x:execute,数字设定值为1


### 设置文件属性和权限

#### 改变文件所属用户命令chown
文件所有者修改为指定的用户
```shell
chown [-cfhvR] [--help] [--version] user[:group] file...
```

|option | explanation|
|:---:|:---:|
|-c | 显示更改的部分的信息|
|-f | 忽略错误信息|
|-h |修复符号链接|
|-v  |显示详细的处理信息|
|-R  |处理指定目录以及其子目录下的所有文件|
|--help|  显示辅助说明|
|--version|   显示版本|


#### 改变文件所在组命令chgrp

变更目录和文件的所属组，只有超级用户才拥有此权限。

```shell
chgrp [option] group file
```

|option | explanation|
|:---:|:---:|
|-c或–changes   |  效果类似”-v”参数，但仅回报更改部分。|
|-f或–quiet或–silent|   不显示错误信息。|
|-h或–no-dereference|  只对符号连接的文件作修改，而不更动其他任何相关文件。|
|-R或–recursive   |递归处理，将指定目录下的所有文件及子目录一并处理。|
|-v或–verbose |显示指令执行过程。|
|–reference=&lt  |参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。|

#### 修改文件或目录的权限chmod

```shell
chmod [ugoa...][[+-=][rwxX]...][,...]
```
u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。
+表示增加权限、-表示取消权限、=表示唯一设定权限。
r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

##### 修改文件权限的方法有2种
1. 符号法（表达式法）
```shell
chmod [who] [operator] [mode] file
```
- who指定用户身份，若此参数省略，则表示对所有用户进行操作。
- operator表示添加或取消某个权限，取值为“+”或“-”。
- mode指定读、写、执行权限，取值为 r、 w、 x 的任意组合。

2. 数字法
```shell
chmod 数字 file
```

### 存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。


### 基础权限ACL

主要提供传统的UGO的r、w、x权限之外的具体权限设置，对单一用户，单一文件或目录进行权限设置。

#### getfacl命令

```shell
getfacl [-aceEsRLPtpndvh] file ...
```

#### setfacl命令可以设置ACL权限
```shell
setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...
```

## linux编程基础

make可以获知所管理项目中源文件的修改情况，根据程序员设定的规则，自动编译被修改过的部分，

make通过makefile文件描述的内容自动维护编译工作。




## shell编程

Shell脚本是一个包含一系列命令的文件。 
Shell自动读取这个文件，并执行这些命令，与直接输入命令行得到结果一样。

### 用Shell脚本的原因：
1. 效率高：如果让Shell记住这些命令并自动完成输入将会大大提升效率。 
2. 简单性： 通过Shell高级语言，可以简洁地表达复杂的操作。
3. 可移植性：使用POSIX定义的功能，可以做到脚本无须修改就可在不同系统上执行。
4. 开发容易：可以在短时间内完成一个功能强大又好用的脚本。

### Shell分类：
1. 用于用户交互接口的Shell称为交互式Shell。
2. 作为命令解析器的Shell称为非交互式Shell。

### ```#!/bin/bash```
脚本第一行开头的“#!”是一个约定的标记，称为shebang，用来告知操作系统需要用什么解析器来执行此脚本，


Shell的注释以“#”开头，注释的内容不会执行。


给文件helloxiangtian.sh增加可执行权限
```shell
chomd +x helloxiangtan.sh
```

### Shell变量命名规则：

变量名必须由大写字母（A～Z）、小写字母（a～z）、数字（0～9）或下画线构成；变量名的第一个字符不能是数字。 

### shell变量分类

Shell变量分为自定义变量、环境变量、位置变量和预定义变量。

根据工作要求临时定义的变量称为自定义变量。
环境变量一般是指用export内置命令导出的变量，用于定义Shell的运行环境，保证Shell命令的正确执行，如$0、$1、$#。
从命令行、函数或脚本执行等处传递参数时，$0、$1称为特殊位置变量。
预定义变量是在bash（默认Shell）中已有的变量，可以直接使用，如$@、$\*等。

Shell变量只有字符串一种类型，即无论给 Shell变量赋予什么值，在存储时都会转换为字符串。

#### 自定义变量
| | |
|:---:|:---:|
|定义自定义变量| 变量名=变量值，变量名必须以字母和下划线开头，如ipl=192.197.1.1。|
|使用自定义变量| $变量名|
|查看自定义变量| echo $变量名 set（所有变量：自定义变量和环境变量）|
|取消自定义变量| unset 变量名|
|自定义变量作用范围|   仅在当前shell中有效|

#### 环境变量

在各种编程语言中会提及全局变量概念。
全局变量可以在程序的任何地方使用。
在Shell编程中该功能由环境变量实现。
系统中的所有进程都可以使用环境变量。
环境变量与全局变量区别：
子进程对环境变量的修改不会传递到父进程中。

|||
|:---:|:---:|
定义环境变量  |使用export命令声明。例如，export back_dir=/home/user例如，export ipl 将自定义变量转换为环境变量。|
|使用环境变量  |$变量名或$｛变量名｝|
|查看环境变量  |echo $变量名 或env，如env |grep back_dir|
|取消环境变量  |unset 变量名|
|环境变量作用范围   | 仅在当前shell和子shell中有效|

#### 位置变量

位置变量用于在命令行、函数或脚本中传递参数，其变量名不用自己定义，其作用也是固定的。
执行脚本时，通过在脚本后面给出具体的参数（多个参数用空格隔开）对相应的位置变量进行赋值。

```shell
$0代表命令本身，$1-$9代表接收的第1~9个参数，$10以上需要用{}括起来，如${20}代表接收的第20个参数。
```

#### 预定义变量

预定义变量在Shell中可以直接使用，位置变量也是预定义变量的一种。

|预定义变量 |  说明|
|:---:|:---|
|$0|  脚本名|
|$*|  所有的参数|
|$@|  所有的参数|
|$#|  参数的个数|
|$$|  当前进程的PID|
|$!|  上一个后台进程的PID|
|$?|  上一个命令的返回值，0表示成功。|


### 变量的操作
变量创建只需要指定变量名称和变量值，它们之间用等号（=）连接，等号两边不能有空格。

变量创建好后，可以用$变量名的方式获取变量的值。


可以使用$符号获取变量的值。

用户可以通过export命令将Shell变量导出为环境变量，但没有办法将环境变量再恢复成Shell变量。

#### 变量的删除

|格式 | 说明|
|:---:|:---:|
|${变量名#关键字符} |变量内容从头开始的数据符合“关键字符”，则将符合的最短数据删除。|
|${变量名##关键字符}|    变量内容从头开始的数据符合“关键字符”，则将符合的最长数据删除。|
|${变量名%关键字符} |变量内容从尾开始的数据符合“关键字符”，则将符合的最短数据删除。|
|${变量名%%关键字符}|    变量内容从尾开始的数据符合“关键字符”，则将符合的最长数据删除。|

#### 变量的替换

|格式  |说明|
|:---:|：---：|
|${变量名/旧字符串/新字符串}|  若变量内容符合“旧字符串”，则第1个“旧字符串”会被“新字符串”替换。|
|${变量名//旧字符串/新字符串} |  若变量内容符合“旧字符串”，则全部“旧字符串”会被“新字符串”替换。|

#### 变量的替代

```shell
${变量名-新的变量名}
```


在Shell中，变量值的类型默认是字符串，不直接进行运算。

用于整数运算的方法有expr、(())和$[]。


### 运算
```shell
expr expression
例：
n1 + n2
expr $n1 + $n2
```
运算符及用于计算的数字两边必须有空格，否则会执行失败。
用expr进行乘法运算时，必须在*前用反斜线转义（Shell可能误解为*号）。



“（（））”或“[ ]”数值运算命令
双小括号 “(())” 的作用是进行整数运算和数值比较，其效率很高，用法也非常灵活，是企业中常见的运算操作符
格式：
“ ((expression))”，或“ [expression]”
括号内部两侧可以有空格，也可省空格。
需要直接输出运算表达式的运算结果时，可以在“ ((表达式))”前加$符
```shell
n1+n2
$(($n1+$n2))
$[$n1+$n2]
```

let数值运算命令

```shell
let expression

例：
let sum = n1+n2;
```

let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量

### shell中的特殊符号

#### 1. “#”表示注释。
- 行首为#（#!是个例外）表示此行是注释。
- 注释也可以放在本行命令的后面，需要注意的是#两边有空格。
- 释也可以放在本行行首空白的后面。

#### 2. " ; "

- “;”在同一行中分隔两个或者两个以上的命令。
- “;”也适用于循环语句

#### 3. “;;”

- 用于终止case语句

#### 4. “:”

- 空命令“:”和true命令作用相同。
- 在while死循环和if/then中也可使用这个命令。


#### 5. “.”

- “.”等价于source命令，是bash中的一个内建命令。
- “.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”。ls命令将不会正常显示出这个文件。
- 当点作为目录名时，一个单独的点代表当前工作目录，而两个点表示上一级目录。

### 输入输出

#### 输出

##### echo
echo命令是最常用的，其功能是将字符串输出到屏幕

```shell
echo [-ne] [string]
```
其中，string表示要输出的字符串。选项n表示输出不换行。选项e表示处理特殊字符

##### printf

输出命令printf的功能是格式化输出数据
```shell
printf format [arguments...]
```

format为输出格式，用单引号或双引号包围都可以。“%s”为格式符，表示输出的格式为字符串，还有“%d”、“%c”、“%f”等，代表的格式与 C 语言中的相同。
arguments为要输出的数据。

#### 输入

##### 1. 直接给变量赋值

例如，name=liming

##### 2. 从键盘读入赋值

- read命令可以通过从标准输入设备（键盘）读取一行数据赋值给变量。
```shell
read  [options] [variable…]
```

##### 3. 使用命令行参数赋值

使用命令行参数赋值是直接在命令后面跟参数，系统用$1来调用第一个参数，用$2调用第二个参数......，这种赋值方法适用于参数经常变化且不需要交互的情况。

##### 4. 利用命令的输出结果赋值

- 在Shell程序中，可以将一个命令的输出结果当作变量的值（需要在赋值语句中使用反向单引号）。
- 把命令的结果作为变量的内容进行赋值的方法，在脚本开发时很常见，如按天打包网站的站点目录程序，生成不同文件名

##### 5. 从文件中读入数据赋值

这种方式就适合处理大批量的数据，直接把相应的数据写入文件中，通过脚本中的命令把文件中的数据读取到脚本程序中以便使用。

#### 引用
```
1. 转义字符：用于引用任意的单个字符。
2. 单引号引用（强引用），不管引号里面是否有变量或者其他的表达式，都是原样输出。
3. 双引号引用（弱引用），用于引用包含的字符串，但保留$、 \和`的特殊含义，即引号里面的变量或者函数会先解析再输出内容。
```

### 条件测试

#### 文件测试
1. test
```shell
“test  <expression>”
```
2. “<测试表达式>”

也可以使用“<测试表达式>”，就是使用中括号。
语法格式：
“ [  <expression> ]”
注意：[]与expression之间必须有空格。 
通过[]进行条件测试的方法，与test命令用法相同，推荐使用此方法。

#### 整数测试

整数测试通常用于数值之间的运算。
```shell
语法格式：
       [ 整数1 操作符 整数2 ]
或   test 整数1 操作符 整数2。
```

|操作符1  |  操作符2(部分能用)  意义|
|:---:|:---:|
|-eq ==|  等于（Equal）|
|-ge >=|  大于等于（Greater or Equal）|
|-gt > |  大于（Greater Than-le）|
|-le <=|  小于等于（Lesser or Equal）|
|-lt   |  <   小于（Lesser Than）|
|-ne !=|  不等于（Not Equal）|

#### 字符串测试

字符串测试操作包括比较字符串是否相同、测试字符串的长度是否为0。

```shell
[ 字符串1 = 字符串2 ]
[ 字符串1 ！= 字符串2 ]或[ -z 字符串 ]
```

#### 逻辑运算符

```shell
[ expression1 op expression2 ]
or       command1 op commnad2

```

|Operator |   意义|
|:---:|:---:|
|! expr | 如果表达式评估为假，则为真|
|expr1 -a expr2 | 如果 expr1 和 expr2 都为真，则结果为真，&&|
|expr1 -o expr2  |如果 expr1 或 expr2 为真，则结果为真，|||

### if语句格式

```shell
语句格式：
if [ expression ];then  code
fi


if [ expression ]  
then code
fi
```


```shell
if [ expression ];then  code1
else code2
fi


if [ expression ]  
then   code1
else  code2
```

```shell
if expression; then
 command…
[elif expression; then
 command…]
[else
 command…]
fi
```

### case
```shell
case value in
    [ expression1) code1
    ;;
    expression2) code2
    ;;
    …
    *）code
    ]
esac
```


### 循环

#### while 命令

```shell
while expression; do
       command…
done   
```
#### until命令

```shell
until expression; do
     command…
done
```

#### for循环
```shell
for  variable in [in sequence]
do
    code
done 

```
```shell
for  变量名 in 取值列表；do     循环体 done

```
```shell
for variable [in sequence]; do
          command…
     done
```
```shell
for ((expression1; expression2; expression3;));do
           command…
     done
```


在循环后面加个 & 符号表示在后台执行


### 数组

#### 数组分为普通数组和关联数组。
普通数组中的索引（下标）都是整数。
关联数组的数组索引可以用任意的文本。

两者最大区别：
- 关联数组使用之前需要声明。
- 关联数组是由特定格式的键值对组成

#### 普通数组
定义：
```shell
arrayname=（value_table）
```

value_table中值之间用空格隔开。


#### 关联数组
定义：
```shell
arrayname=（[indexe1]=value1 [indexe2]=value2 ...... [indexen]=valuen)
```
其中：
indexei可以用标识符表示。


声明普通数组方法：
#declare -a arrayname
声明关联数组方法：
#declare -A arrayname

#### 数组定义方法

- 直接定义数组
- 
```shell
arrayname=(value1 value2 value3 ... valuen)
```

- 下标定义数组
- 
```shell
array_name=([index1]=value1 [index2]=value2 ...)
```

- 间接定义数组

```shell
array[0]=value1;array[1]=value2;....
```

- 从文件中读入定义数组。

```shell
array_name=($(command))
array_name=($(`variable`))

or 

array_name=(`command`)
array_name=(`variable`)

```

#### 访问数组表达式



| 语法                 | 描述                         |
| -------------------- | ---------------------------- |
| echo ${!array[*]}    | 访问数组所有索引             |
| echo ${!array[@]}    | 访问数组所有索引             |
| echo ${array[*]}     | 访问数组所有值               |
| echo ${array[@]}     | 访问数组所有值               |
| echo ${#array[@]}    | 统计数组元素个数             |
| echo ${array[0]}     | 访问数组第0个元素            |
| echo ${array[@]:1}   | 从数组下标1开始              |
| echo ${array[@]:1:2} | 从数组下标1开始，访问2个元素 |
| echo ${#array[#]}    | 第#个元素的字符个数          |
| echo ${#array}       | 第0个元素的字符个数          |
| echo ${array[#]}     | 显示第#个元素                |
| echo ${array}        | 显示第0个元素                |


#### 数组删除

删除数组命令格式：
```shell
unset array
```
删除数组中指定元素命令格式：
```shell
unset array[subscript]
```

#### 数组的截取和替换

- 通过${数组名[@或*]:起始位置:长度}切片原先数组，返回的是字符串，中间用空格分开。
- 如果加上“()”，就可以得到切片数组。

### 函数

函数定义：

```shell
function name{
     command…
      [return]
}

or

name(){
   command…
   [return]
}
```

return只能用于函数中，表示将返回值提供给函数的调用命令。 
exit可以用于程序的任意位置，表示退出当前程序并将退出状态返回到父进程。

## Linux多命令协作(I/O重定向与管道）

### 命令行shell数据流定义为

1. 标准输入STDIN(standard input)：是用来采集信息的，命令是通过STDIN接收参数或数据，默认情况下，标准输入就是从键盘读入数据。

2. 标准输出STDOUT(standard out)：是用来输出结果的。
3. 标准错误STDERR(standard error)：是输出状态或错误信息等。


### 重定向

输入ls命令，会显示出当前目录下的文件和目录。如果在ls命令后加入“>”，并指向ls1.txt文件，那么结果就会写入ls1.txt文件中。


#### 文件描述符

每一个进程在运行中都会打开一些文件，每一个文件都会有一个指定的数字标识，这个标识就叫做文件描述符。

- 0表示为标准输入，可以理解为键盘输入。
- 1表示为标准输出，输出到终端。
- 2表示为标准错误，输出到终端。
- 3及以上为常规文件的描述符
- 
#### 重定向标准输出

默认情况下，标准输出在屏幕上显示，而重定向标准输出可以重新定义输出内容到文件。

##### 重定向标准输出格式:

- 重定向符“>”是把标准输出重定向到文件，即将标准输出内容保存到文件中，是覆盖操作。
如果目标文件不存在，则创建文件并将标准输出内容保存进去；如果目标文件存在，则覆盖其中的内容。
- 重定向符号“>>（中间没有空格）”是追加操作，实现连续保存文件中的内容。
即原来的文本内容不会被覆盖，而是在文件尾部添加标准输出的内容。如果文件不存在，也会自动创建。


#### 重定向标准输入

默认情况下，标准输入就是从键盘读入数据，每次一行。
重定向标准输入可以重新定义从文件中读入数据。

通过重定向符“<”，可以把标准输入重定向到文件，即从文件中读入数据作为某条命令的输入数据。

#### 重定向标准错误

默认情况下，标准错误在屏幕上显示，而重定向标准错误可以重新定义输出错误内容到文件

###### 重定向标准错误格式：
通过重定向符“2>”把标准错误内容保存到文件中，是覆盖操作。

- 如果目标文件不存在，则创建文件并将标准错误内容保存进去。
- 如果目标文件存在，则覆盖其中的内容。
- 此命令用于日志中，执行一条指令可能有很多步操作。如果只想保存报错信息，就可用此命令。
重定向符号“2>&1（中间没有空格）”是将标准输出和标准错误结合在一起输出到文件，即将正确结果及错误全部输出到文件。

#### Subshell

- Subshell是指括在圆括号里的命令会在另外的进程中执行。
- 当需要让一组命令在不同的目录下执行时，采用这种方法可以不修改主脚本的目录。
- 对比不加圆括号的命令与加圆括号的命令。

### 管道

管道实际上也是一种重定向，重定向字符控制输出到文件，管道控制输出到其他程序。

管道的作用是把上一个进程的输出作为下一个进程的输入，利用管道可以把若干个命令连接在一起。


#### 统计字数命令wc

```shell
wc [option] [file]
```

| option | explanation                                                  |
| ------ | ------------------------------------------------------------ |
| 缺省   | 统计每个文件的行数、字数、字节数及其汇总。                   |
| -c     | 统计字节数。                                                 |
| -l     | 统计行数。                                                   |
| -m     | 统计字符数。这个标志不能与 -c 标志一起使用。                 |
| -w     | 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 |
| -L     | 打印最长行的长度。                                           |


##### 行、单词、字符的定义如下：
1. 行：以新行字符（如 Enter 键）结尾的一串字符。
2. 单词：是一串连续的字符，用空格、制表符或新行字符分隔。
3. 字符：字母、数字、标点符合、空格、制表符或新行字符。


#### 管道线分流命令tee

tee命令的作用是从标准输入读取数据，并向标准输出和一个或更多的文件发送数据

```shell
tee [-ai] [file...]
```

| option | explanation  |
| ------ | ------------ |
| 缺省   | 覆盖         |
| -a     | 追加         |
| -i     | 忽略中断信号 |


#### 查找重复行命令uniq

消除重复行、选取重复行、选取唯一行和统计重复行的数量。

```shell
uniq [option] [input [output]]
uniq [选项]... [文件]
```

input是输入文件，若指定了该参数，uniq命令从该文件读入数据。
output是输出文件，若指定了该参数，则uniq命令将输出结果保存到该文件中。

| option                                          | explanation                                |
| ----------------------------------------------- | ------------------------------------------ |
| 缺省                                            | 匹配行将在首次出现处被合并。               |
| -c, --count                                     | 在每行前加上表示相应行目出现次数的前缀编号 |
| -d, --repeated                                  | 只输出重复的行                             |
| -D, --all-repeated[=delimit-method              | 显示所有重复的行                           |
| delimit-method={none(default),prepend,separate} | 以空行为界限                               |
| -f, --skip-fields=N                             | 比较时跳过前N 列                           |
| -i, --ignore-case                               | 在比较的时候不区分大小写                   |
| -s, --skip-chars=N                              | 比较时跳过前N个字符                        |
| -u, --unique                                    | 只显示唯一的行                             |
| -z, --zero-terminated                           | 使用'\0'作为行结束符，而不是新换行         |
| -w, --check-chars=N                             | 对每行第N 个字符以后的内容不作对照         |




## linux文本处理

### 文本处理

#### Vim有3种工作模式：
命令模式、插入模式、末行模式

##### 命令描述

Vim启动后，默认进入命令模式

在任何模式下，都可以按Esc键返回到命令模

在命令模式下，可以键入不同的命令完成选择、复制、粘贴、删除等操作，及进入Insert mode下，或者到 last line mode。

##### 插入模式(Insert mode)
只有在Insert mode下，才可以编辑文本内容，按ESC键可回到命令行模式。
在命令行模式下按o、i、a等键可以进入插入模式。

##### 末行模式（last line mode）
在命令模式下按：键进入末行模式。
光标会移到屏幕底部，将文件保存或退出Vim，也可以

| Command    | Explanation                                                  |
| ---------- | ------------------------------------------------------------ |
| h,j,k,l    | 光标上下左右移动。也可以用键盘自带方向键。                   |
| 0和$       | 光标移动到行首、行尾。                                       |
| gg和G      | 光标移动到第一行首个字符的位置和光标移动到最后一行首个字符的位置。 |
| [:]/字符串 | 快速定位到字符所在的行。如果第一次找的关键字不是您想要的，可以一直按n会往后寻找到您要的关键字为止。 |
| /^d        | 定位首字母为d的行。                                          |
| /txt$      | 定位结尾为txt的行。                                          |

| Command | Explanation                                                  |
| ------- | ------------------------------------------------------------ |
| yy      | 复制光标所在行到缓冲区。                                     |
| #yy     | [6yy]表示拷贝从光标所在的该行"往下数"6行文字。               |
| dd      | 删除当前行。                                                 |
| 4dd     | 从光标所在行开始删除4行。                                    |
| p       | 将缓冲区内的字符贴到光标所在位置。注意：所有与"y"有关的复制命令都必须与"p"配合才能完成复制与粘贴功能。 |
| x       | 每按一次，删除光标所在的字符。                               |
| D       | 从光标处删除到行尾。                                         |
| u       | 取消操作。                                                   |
| ^r      | 重做。                                                       |
| r       | 可以用来修改一个字符。                                       |
| yw      | 将光标所在之处到字尾的字符复制到缓冲区中。                   |

| Command | Explanation                                                  |
| ------- | ------------------------------------------------------------ |
| i       | 切换进入插入模式，按"i"进入插入模式后是从光标当前位置开始输入文件。 |
| a       | 进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字。 |
| o       | 进入插入模式后，是插入新的一行，从行首开始输入文字。         |
| :       | 进入「Last line mode」。                                     |
| Esc     | 转到「命令行模式（command mode）」。                         |
| V       | 进入可视模式。                                               |
| v       | 进入可视模式。                                               |
| ^v      | 进入可视块模式。                                             |
| R       | 进入替换模式。                                               |

| Command        | Explanation                                                  |
| -------------- | ------------------------------------------------------------ |
| : w filename   | 将文章以指定的文件名filename保存                             |
| : wq           | 存盘并退出vi                                                 |
| : q!           | 不存盘强制退出vi(!为强制退出，可以与w合用)                   |
| :w             | 存盘                                                         |
| :q             | 退出                                                         |
| :set nu        | 在文件中的每一行前面列出行号                                 |
| :set nonu      | 在文件中的每一行前面不列出行号                               |
| :15            | 跳到文章的第15行                                             |
| :?关键字       | 查找，如果第一次找的关键字不是您想要的，可以一直按n会往前寻找到您要的关键字为止。 |
| :1,10s/abc/def | 在第1行到第10行之间进行查找到每1行的第1个abc，并将其过分替换成def。 |


### 文本切片和切块

#### 剪切命令cut

cut命令是用于在数据中提取需要的部分。
注意：cut命令是以行为对象来进行操作的。

```shell
cut option [file]
```

在执行cut命令时，必须指定-b、-c、-f标志之一。


#### 粘贴命令paste

paste命令的作用与cut命令相反，是向文本中添加信息。

```shell
paste [option] [file1] [file2]
```

若使用paste命令的参数-s，则可以将一个文件中的多行数据合并成一行。
注意：**“-s”只是将文件的内容调整了显示方式，并不会改变原文件的内容形式。**


####  连接命令join

join命令的作用与paste类似，也就是向文本中添加信息

```shell
join [option] filename1 filename2
```

其中option选项可以省略，filename1和filename2必须是有序的，且包含相同的列。

| Option     | Explanation                                                  |
| ---------- | ------------------------------------------------------------ |
| -a<1或2>   | 除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行 |
| -e<字符串> | 若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串 |
| -i         | 比较栏位内容时，忽略大小写的差异                             |
| -o<格式>   | 按照指定的格式来显示结果                                     |
| -t<字符>   | 使用栏位的分割字符                                           |
| -v<1或2>   | 与-a相同，但是只显示文件中没有相同栏位的行                   |
| -1<栏位>   | 连接[文件1]指定的栏位                                        |
| -2<栏位>   | 连接[文件2]指定的栏位                                        |


### 文本比较

#### 有序文件逐行比较命令comm

comm功能是选择或拒绝两个已排序的文本文件的公共的行，是按行进行比较

```shell
comm [option] filename1 filename2
```
其中option选项可以省略，其中-1、-2、-3分别针对comm输出结果中的第1、第2、第3列不显示。

#### 逐行比较命令diff

文件可以是无序的，可以是大的文件集比较，尤其是在程序开发过程中，修改过后，利用 diff可以很方便地查找版本之间的不同之处。

```shell
diff [option] file
```

| Option                                                  | Explanation                                                  |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| 缺省                                                    | 比较文件的异同                                               |
| -<行数>                                                 | 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。     |
| -a或--text                                              | diff预设只会逐行比较文本文件。                               |
| -b或--ignore-space-change                               | 不检查空格字符的不同。                                       |
| -B或--ignore-blank-lines                                | 不检查空白行。                                               |
| -c                                                      | 显示全部内容，并标出不同之处。                               |
| -C<行数>或--context<行数>                               | 与执行“-c-<行数>”指令相同。                                  |
| -d或--minimal                                           | 使用不同的演算法，以小的单位来做比较。                       |
| -D<巨集名称>或ifdef<巨集名称>                           | 此参数的输出格式可用于前置处理器巨集。                       |
| -e或--ed                                                | 此参数的输出格式可用于ed的script文件。                       |
| -f或-forward-ed                                         | 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。 |
| -H或--speed-large-files                                 | 比较大文件时，可加快速度。                                   |
| -l<字符或字符串>或--ignore-matching-lines<字符或字符串> | 若两个文件在某几行有所不同，而之际航同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。 |
| -i或--ignore-case                                       | 不检查大小写的不同。                                         |
| -l或--paginate                                          | 将结果交由pr程序来分页。                                     |
| -n或——rcs                                               | 将比较结果以RCS的格式来显示。                                |
| -N或--new-file                                          | 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较。 |
| -p                                                      | 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称    |
| -P或--unidirectional-new-file                           | 与-N类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。 |
| -q或--brief                                             | 仅显示有无差异，不显示详细的信息。                           |
| -r或--recursive                                         | 比较子目录中的文件。                                         |
| -s或--report-identical-files                            | 若没有发现任何差异，仍然显示信息。                           |
| -S<文件>或--starting-file<文件>                         | 在比较目录时，从指定的文件开始比较。                         |
| -t或--expand-tabs                                       | 在输出时，将tab字符展开。                                    |
| -T或--initial-tab                                       | 在每行前面加上tab字符以便对齐。                              |
| -u，-U<列数>或--unified=<列数>                          | 以合并的方式来显示文件内容的不同。                           |
| -w或--ignore-all-space                                  | 忽略全部的空格字符。                                         |
| -W<宽度>或--width<宽度>                                 | 在使用-y参数时，指定栏宽                                     |
| -x<文件名或目录>或--exclude<文件名或目录>               | 不比较选项中所指定的文件或目录                               |
| -X<文件>或--exclude-from<文件>                          | 可以将文件或目录类型存成文本文件，然后在=<文件>中指定此文本文件。 |
| -y或--side-by-side                                      | 以并列的方式显示文件的异同之处。                             |
| --left-column                                           | 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。 |
| --suppress-common-lines                                 | 在使用-y参数时，仅显示不同之处。                             |


#### 格式化输出printf

```shell
printf format [argument]
```

##### 参数选项表

| Option | Explanation                           |
| ------ | ------------------------------------- |
| %s     | 字符串                                |
| %f     | 浮点格式                              |
| %c     | ASCII字符，即显示对应参数的第一个字符 |
| %d,%i  | 十进制整数                            |
| %o     | 八进制值                              |
| %u     | 不带正负号的十进制值                  |
| %x     | 十六进制值（a-f）                     |
| %X     | 十六进制值（A-F）                     |
| %%     | 表示%本身                             |

##### 常用转义字符

| 转义字符 | Explanation                                      |
| -------- | ------------------------------------------------ |
| \a       | 警告字符，通常为ASCII的BEL字符。                 |
| \b       | 后退                                             |
| \f       | 换页                                             |
| \n       | 换行                                             |
| \r       | 回车                                             |
| \t       | 水平制表符                                       |
| \v       | 垂直制表符                                       |
| \\       | 表示\本身                                        |
| \ddd     | 表示1到3位数八进制值的字符。仅在格式字符串中有效 |
| \0ddd    | 表示1到3位的八进制值字符                         |



#### 格式化段落fmt

fmt命令的作用是格式化段落，使文本看上去更加整齐。

```shell
fmt [option] [filename]
```

#### 行标命令nl

nl命令的功能是为文本创建行号，如果不保存，nl只会在输出中加入行号，阅读起来更加方便，不会影响原文件的文本内容。

```shell
nl [option] [filename]
```


#### 指定行长度命令fold

fold命令是对行进行操作，将文本行进行折叠，长行分解成短行。

```shell
flod [option] [filename]
```


### 文本分析工具

#### awk
awk是一个文本处理工具，完成字符串查找、替换、加工等操作，还包含可以进行模式装入、流控制、数学运算、进程控制等语句。
```shell
awk ‘pattern {action}’ file
```
awk扫描file中的每一行，对符合模式 pattern的行执行操作action。也可以只有pattern或者action，


## 进程管理

### 进程基础

#### 进程概念

-Linux可以同时执行多个用户的多个程序。为了保证程序能够并发执行，需要对程序的执行过程进行动态控制。
- 进程就是用来描述这一控制过程的，组织安排不同程序等待CPU的调度。
- 进程是一个具有一定独立功能的程序或程序段在一组数据集合上的一次动态执行过程，同时也是程序能够并发执行的基础机制。
- 各种资源的分配和管理都是以进程为单位


#### 进程的基本组成结构

- 进程控制块PCB(Processing Control Block)是进程动态特征的反映，主要包括进程的描述信息、控制信息、进程使用资源情况等。用于跟踪管理程序状态。
- 程序段是该进程需要完成功能的程序代码。
- 数据结构集是进程执行时需要访问的工作区和数据对象，即执行进程时需要的系统资源



进程在创建时，会被内核赋予一个PID(非负整数)作为进程**唯一标识号。**
进程PID可以重用，当进程终止后，Linux一般通过延迟重用算法，使得赋予新进程的PID不同于最近终止进程的PID

#### 根据进程的特点和属性，将进程分为

1. 交互进程：由Shell启动的进程，既可以在前台运行，也可以在后台运行，且必须由用户给出某些参数或者信息，进程才能继续执行。
2. 批处理进程：与终端没有联系，是一个进程序列，负责按照顺序启动其他进程。
3. 守护进程：执行系统特定功能或者执行系统相关任务的进程，并在后台运行。
守护进程是一个特殊进程，不是内核的组成部分。
大部分守护进程是在系统启动时启动，直到系统关闭时才停止运行。 


#### 进程运行环境

进程运行环境是由它的程序代码、程序运行所需的数据结构和硬件环境组成的


##### 进程运行环境主要包括：

1. 进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等。
2. 环境变量：提供进程运行所需的环境信息。
3. 系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。
4. 进程访问设备或者文件时的权限。
5. 各种硬件寄存器。
6. 地址转换信息。


进程的运行环境是动态变化的。

在Linux中把系统提供给进程的处于动态变化的运行环境总和称为进程上下文。


### 进程管理

#### Linux进程状态

运行状态、就绪状态、阻塞状态（睡眠状态、暂停状态、僵死状态）

进程之间相互独立，一个进程不能改变另一个进程的状态


##### 运行状态

它是在run_queue队列里的状态，占有CPU处理进程任务，一个进程只能出现在一个CPU的可执行队列里。同一时刻允许有多个进程处于运行状态，但运行状态的进程总数应小于或等于处理器的个数。
运行状态分为**用户运行态**和**内核运行态**两种，在内核态下运行的进程不能被其他进程抢占。

##### 就绪状态

就绪状态。该状态的进程已经拥有除CPU以外的所有请求资源，只等待被核心程序调度。
只要被分配到CPU就可执行，在队列中按照进程优先级进行排队。

##### 睡眠状态

睡眠状态。处于该状态的进程需要被某一事件触发才可继续执行，分为可中断的睡眠状态和不可中断的睡眠状态。
处于可中断的睡眠状态的进程，是在等待资源被释放，一旦得到资源，进程就会被唤醒进入就绪态。
由于CPU数量有限，而进程数量众多，所以很多请求无法及时得到响应，因此大部分进程都处于可中断的睡眠状态。
处于不可中断睡眠状态的进程，只能通过 wake_up( )函数唤醒。 

##### 暂停状态

暂停状态（跟踪状态）。是指进程从内核返回用户时，被核心程序抢先调度了另一个进程，该进程就处于暂停状态。
处于暂停状态的进程只有等待下次调度，才能返回用户态。当进程收到信号SIGSTOP时会进入暂停状态，发送SIGCONT信号，进程可转换到运行状态。

##### 僵死状态

僵死状态。处于该状态的进程已经终止运行，等待父进程询问其状态，收集它的进程控制块所占资源。

#### 三种基本状态

![image-20211207104316412](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211207104316412.png)


（1）运行态：已经分配到CPU，正在处理器上执行。
（2）就绪态：已经具备运行条件，但所需 CPU资源被其他进程占用，需等待分配CPU。
（3）阻塞态：尚不具备运行条件，需要等待某种事件的发生，即使CPU空闲，也无法使用。


#### 查看进程

ps命令可以查看系统中正在运行的进程信息以及进程的状态

```shell
ps [option]
```

| Option(part)   | Explanation                                                  |
| -------------- | ------------------------------------------------------------ |
| a              | 显示现行终端机下的所有程序，包括其他用户的程序。             |
| -A or -e       | 列出所有的行程                                               |
| -w             | 显示加宽可以显示较多的资讯                                   |
| -au            | 显示较详细的资讯                                             |
| -aux           | 显示所有包含其他使用者的行程                                 |
| c              | 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 |
| e              | 列出程序时，显示每个程序所使用的环境变量。                   |
| f              | 用ASCII字符显示树状结构，表达程序间的相互关系。              |
| -H             | 显示树状结构，表示程序间的相互关系。                         |
| -N             | 显示所有的程序，除了执行ps指令终端机下的程序之外。           |
| s              | 采用程序信号的格式显示程序状况。                             |
| S              | 列出程序时，包括已中断的子程序资料。                         |
| -t<终端机编号> | 指定终端机编号，并列出属于该终端机的程序的状况。             |
| u              | 以用户为主的格式来显示程序状况。                             |
| x              | 显示所有程序，不以终端机来区分。                             |
| j              | BSD（Berkeley Software Distribution） job contorl format     |
| -j             | BSD jobs format                                              |

输出信息的意义

| 名称    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 行程拥有者                                                   |
| PID     | pid                                                          |
| %CPU    | 占用的CPU使用率                                              |
| %MEM    | 占用的存储器使用率                                           |
| VSZ     | 占用的虚拟记忆体大小                                         |
| RSS     | 占用的存储器大小                                             |
| TTY     | 终端的次要装置号码 (minor device number of tty)              |
| STAT    | 该行程的状态                                                 |
| START   | 行程开始时间                                                 |
| TIME    | 执行的时间                                                   |
| COMMAND | 所执行的指令                                                 |
| PPID    | 父进程的ID                                                   |
| PRI     | 指进程的执行优先权(Priority的简写)，其值越小越早被执行；     |
| NI      | 这个进程的nice值，其表示进程可被执行的优先级的修正数值。     |
| ADDR    | 这个是内核函数，指出该程序在内存的那个部分。如果是个执行 的程序，一般就是『 - 』。 |
| SZ      | 使用掉的内存大小。                                           |
| WCHAN   | 目前这个程序是否正在运作当中，若为 - 表示正在运作。          |

| STAT | 该行程的状态说明               |
| ---- | ------------------------------ |
| D    | 不可中断的静止                 |
| R    | 正在执行中                     |
| S    | 静止状态                       |
| T    | 暂停执行                       |
| Z    | 不存在但暂时无法消除           |
| W    | 没有足够的记忆体分页可分配     |
| <    | 高优先序的行程                 |
| N    | 低优先序的行程                 |
| L    | 有记忆体分页分配并锁在记忆体内 |


#### 查看指定进程PID的方法

1. 使用cat命令
 ```shell
cat /run/sshd.pid
 ```
2. 使用pidof命令
```shell
pidof sshd
```
3. 使用pgrep命令
```shell
pgrep sshd
```

#### 实时动态显示进程信息命令top

top命令将按照进程活动顺序，持续更新显示当前系统进程的信息。


#### kill命令

kill命令用来终止指定进程的运行。
首先使用ps/pidof/top等工具获取进程PID，然后使用kill命令来杀死该进程。
kill命令是通过向进程发送指定的信号来结束相应的进程。
在默认情况下，采用编号为15的TERM信号。

常用信号

| 信号编号 | 名称    | 特性及意义                                                   |
| -------- | ------- | ------------------------------------------------------------ |
| 1        | SIGHUP  | 启动被终止的进程，重新加载，PID不会发生变化。                |
| 9        | SIGKILL | 强制终止进程，使用此信号可能导致进程无法再次启动。           |
| 15       | SIGTERM | 默认信号，以正常流程终止进程，允许进程释放资源。若进程已经出现问题，无响应，此信号不起作用。 |
| 18       | SIGCONT | 恢复进程。                                                   |
| 19       | SIGSTOP | 暂停进程。                                                   |

进程优先级是一个整数，动态优先级和静态优先级决定了进程被CPU处理的顺序。





















## 指令

### 文件类型判断

```shell
file [option] filename
```
|第一个字符|	文件类型|
|:---:|:---:|
|-	|普通文件（如文本文件、二进制文件、压缩文件、图片等）|
|d	|目录文件（蓝色）|
|b	|设备文件（块设备），存储设备硬盘、U盘、/dev/sda等|
|c	|设备文件（字符设备），打印机、终端、/dev/tty1、/dev/zero|
|s	|套接字文件|
|p	|管道文件|
|l	|链接文件（淡蓝色）|


### 查看文件的详细属性

```shell
state [option] filename
```

### 显示当前工作目录

```shell
pwd
```

### 显示目录下的文件结构

```shell
tree filename
```

### 切换目录

```shell
cd [directory]
```
```cd - ```表示返回到上次目录。
```cd ..```表示返回到上一级目录

### ls命令

```shell
ls [option] [names]

```
- 显示所有隐藏文件
```shell
ls -[[a]]
```
- 显示所有以a开头的文件
```shell
ls a*
```

### 目录的创建和删除

#### 创建

```shell
mkdir [option] [dirname]
```
dirname : 目录名称
参数：-p :创建多层目录，-v：显示创建过程信息
#### 删除

**rmdir命令只能用来删除空目录**

```shell
rmdir [option] [dirname]
```
dirname : 目录名称



### 文件的创建、查看、复制、移动、删除、排序

#### 创建

```shell
touch [option] filename
```

#### 查看
```
 cat [option] filename
```
- 用来显示文件内容， 依次读取其后所指文件的内容并将其输出到标准输出设备上。
- 能够用来连接两个或者多个文件，形成新文件。

more命令以逐页的方式显示文件的内容.
less命令也是对文件或其他输出进行分页显示。
head命令可以查看文件的前几行的内容。
tail命令查看文件的后几行的内容

#### 复制

```shell
cp [option] source  dest
```
source表示需要复制的文件，dest 表示需要复制到的目录。

#### 移动

```shell
mv [option] source dest
```
为文件或目录改名或者将文件由一个目录移动到另一个目录中


#### 删除
```shell
rm [option] filename
```
- 删除一个目录中的一个或者多个文件。
- 将某个目录及其下的所有文件及子目录均删除。
- 对于链接文件，只是删除了链接，原有文件均保持不变

#### 排序

对文件中的各行进行排序。
```shell
sort [option] filename
```

### 文件查找

```shell
grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][–help][范本样式][文件或目录…]
```

```shell
find [pathname] [option] filename
```

### 查看用户登录信息

```shell
id [option][username]
```

### 查看进程

```shell
ps aux | less命令查看进程
```

### 用户分类

1. root用户：拥有最高权限，ID为0。
2. 普通用户：可以登录，由管理员创建，使用权限有限。
3. 系统用户：不具有登录的能力，但是系统运行不可或缺的。


### 管理用户组

- useradd用来添加用户。
- passwd修改用户口令。
- usermod修改用户信息。
- userdel删除用户。

#### 添加用户

添加用户就是在系统中创建一个新账号，并为新账号分配用户ID、用户组、主目录和登录Shell等资源。

```shell
useradd [option] username
```
username表示新账号的登录名

#### 修改用户口令

用户账号刚创建时没有口令，无法使用，必须为其指定口令后才可以使用，即使是空口令。

```shell
passwd [option] [username]
```

- username参数没有指定时，表示修改当前用户的口令。
- 如果指定了该参数，则表示修改指定用户的口令，只有root用户才有修改指定用户口令的权限

#### 删除用户

删除用户就是删除与用户有关的系统配置文件中的记录（如/etc/passwd）

```shell
userdel [option] username
```

#### 修改用户信息

修改用户信息就是更改用户的属性，如用户 ID、主目录、用户所在组、登录Shell等。

```shell
usermod [option] username
```

gpasswd命令--从用户组中移出一个用户
```shell
gpasswd [-a user][-d user][-A user,...][-M user,...][-r][-R]groupname
```

### 管理用户组

用户组是具有相同特征用户的集合，每个用户都有一个用户组，方便系统集中管理一个用户组中的所有用户

#### 添加用户组
```shell
groupadd [option] group_name
```


#### 删除用户组
```shell
groupdel group_name
```

#### 修改用户组
```shell
groupmod [option] group_name
```

### 设置文件属性和权限

#### 改变文件所属用户命令chown
文件所有者修改为指定的用户
```shell
chown [-cfhvR] [--help] [--version] user[:group] file...
```

|option | explanation|
|:---:|:---:|
|-c | 显示更改的部分的信息|
|-f | 忽略错误信息|
|-h |修复符号链接|
|-v  |显示详细的处理信息|
|-R  |处理指定目录以及其子目录下的所有文件|
|--help|  显示辅助说明|
|--version|   显示版本|


#### 改变文件所在组命令chgrp

变更目录和文件的所属组，只有超级用户才拥有此权限。

```shell
chgrp [option] group file
```

|option | explanation|
|:---:|:---:|
|-c或–changes   |  效果类似”-v”参数，但仅回报更改部分。|
|-f或–quiet或–silent|   不显示错误信息。|
|-h或–no-dereference|  只对符号连接的文件作修改，而不更动其他任何相关文件。|
|-R或–recursive   |递归处理，将指定目录下的所有文件及子目录一并处理。|
|-v或–verbose |显示指令执行过程。|
|–reference=&lt  |参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。|

#### 修改文件或目录的权限chmod

```shell
chmod [ugoa...][[+-=][rwxX]...][,...]
```
u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。
+表示增加权限、-表示取消权限、=表示唯一设定权限。
r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

##### 修改文件权限的方法有2种
1. 符号法（表达式法）
```shell
chmod [who] [operator] [mode] file
```
- who指定用户身份，若此参数省略，则表示对所有用户进行操作。
- operator表示添加或取消某个权限，取值为“+”或“-”。
- mode指定读、写、执行权限，取值为 r、 w、 x 的任意组合。

2. 数字法
```shell
chmod 数字 file
```

### 基础权限ACL

主要提供传统的UGO的r、w、x权限之外的具体权限设置，对单一用户，单一文件或目录进行权限设置。

#### getfacl命令

```shell
getfacl [-aceEsRLPtpndvh] file ...
```

#### setfacl命令可以设置ACL权限
```shell
setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...
```
